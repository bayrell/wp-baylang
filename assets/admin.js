"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.BuilderOpCode = function()
{
	Runtime.BaseObject.apply(this, arguments);
};
BayLang.BuilderOpCode.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.BuilderOpCode.prototype.constructor = BayLang.BuilderOpCode;
Object.assign(BayLang.BuilderOpCode.prototype,
{
	/**
	 * Add slot
	 */
	addSlot: function(op_code, name)
	{
		var slot = new BayLang.OpCodes.OpHtmlSlot(Runtime.Map.from({"name":name,"items":new BayLang.OpCodes.OpHtmlItems()}));
		op_code.items.items.push(slot);
		return slot;
	},
	/**
	 * Add tag
	 */
	addTag: function(op_code, name)
	{
		var tag = new BayLang.OpCodes.OpHtmlTag(Runtime.Map.from({"attrs":Runtime.Vector.from([]),"items":new BayLang.OpCodes.OpHtmlItems(),"tag_name":name}));
		op_code.items.items.push(tag);
		return tag;
	},
});
Object.assign(BayLang.BuilderOpCode, Runtime.BaseObject);
Object.assign(BayLang.BuilderOpCode,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.BuilderOpCode";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.BuilderOpCode);
window["BayLang.BuilderOpCode"] = BayLang.BuilderOpCode;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.BuilderOpCode;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.Caret = function(items)
{
	if (items == undefined) items = null;
	Runtime.BaseObject.call(this);
	if (items)
	{
		if (items.has("file_name"))
		{
			this.file_name = items.get("file_name");
		}
		if (items.has("content"))
		{
			this.content = items.get("content");
		}
		if (items.has("content_sz"))
		{
			this.content_sz = items.get("content_sz");
		}
		if (items.has("content") && !items.has("content_sz"))
		{
			this.content_sz = Runtime.rs.strlen(this.content.ref);
		}
		if (items.has("tab_size"))
		{
			this.tab_size = items.get("tab_size");
		}
		if (items.has("pos"))
		{
			this.pos = items.get("pos");
		}
		if (items.has("x"))
		{
			this.x = items.get("x");
		}
		if (items.has("y"))
		{
			this.y = items.get("y");
		}
	}
};
BayLang.Caret.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Caret.prototype.constructor = BayLang.Caret;
Object.assign(BayLang.Caret.prototype,
{
	/**
	 * Clone
	 */
	clone: function(items)
	{
		if (items == undefined) items = null;
		return new BayLang.Caret(Runtime.Map.from({"file_name":(items) ? (items.get("file_name", this.file_name)) : (this.file_name),"content":(items) ? (items.get("content", this.content)) : (this.content),"content_sz":(items) ? (items.get("content_sz", this.content_sz)) : (this.content_sz),"tab_size":(items) ? (items.get("tab_size", this.tab_size)) : (this.tab_size),"pos":(items) ? (items.get("pos", this.pos)) : (this.pos),"x":(items) ? (items.get("x", this.x)) : (this.x),"y":(items) ? (items.get("y", this.y)) : (this.y)}));
	},
	/**
	 * Copy caret
	 */
	copy: function(items)
	{
		if (items == undefined) items = null;
		return this.clone(items);
	},
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "pos", data);
		serializer.process(this, "x", data);
		serializer.process(this, "y", data);
	},
	/**
	 * Seek caret
	 */
	seek: function(caret)
	{
		this.pos = caret.pos;
		this.x = caret.x;
		this.y = caret.y;
	},
	/**
	 * Returns true if eof
	 */
	eof: function()
	{
		return this.pos >= this.content_sz;
	},
	/**
	 * Returns next X
	 */
	nextX: function(ch, direction)
	{
		if (direction == undefined) direction = 1;
		if (ch == "\t")
		{
			return this.x + this.tab_size * direction;
		}
		if (ch == "\n")
		{
			return 0;
		}
		return this.x + direction;
	},
	/**
	 * Returns next Y
	 */
	nextY: function(ch, direction)
	{
		if (direction == undefined) direction = 1;
		if (ch == "\n")
		{
			return this.y + direction;
		}
		return this.y;
	},
	/**
	 * Returns next char
	 */
	nextChar: function()
	{
		return Runtime.rs.charAt(this.content.ref, this.pos, 1);
	},
	/**
	 * Returns string
	 */
	getString: function(start_pos, count)
	{
		return Runtime.rs.substr(this.content.ref, start_pos, count);
	},
	/**
	 * Returns next string
	 */
	nextString: function(count)
	{
		return Runtime.rs.substr(this.content.ref, this.pos, count);
	},
	/**
	 * Returns true if next char
	 */
	isNextChar: function(ch)
	{
		return this.nextChar() == ch;
	},
	/**
	 * Returns true if next string
	 */
	isNextString: function(s)
	{
		return this.nextString(Runtime.rs.strlen(s)) == s;
	},
	/**
	 * Shift by char
	 */
	shift: function(ch)
	{
		this.x = this.nextX(ch);
		this.y = this.nextY(ch);
		this.pos = this.pos + 1;
	},
	/**
	 * Read char
	 */
	readChar: function()
	{
		var ch = Runtime.rs.charAt(this.content.ref, this.pos);
		this.shift(ch);
		return ch;
	},
	/**
	 * Read char
	 */
	readString: function(count)
	{
		var s = this.nextString(count);
		var count = Runtime.rs.strlen(s);
		for (var i = 0; i < count; i++)
		{
			var ch = Runtime.rs.charAt(s, i);
			this.shift(ch);
		}
		return s;
	},
	/**
	 * Match char
	 */
	matchChar: function(ch)
	{
		var next = this.nextChar();
		if (next != ch)
		{
			throw new BayLang.Exceptions.ParserExpected(ch, this, this.file_name)
		}
		this.readChar();
	},
	/**
	 * Match string
	 */
	matchString: function(s)
	{
		var count = Runtime.rs.strlen(s);
		var next_string = this.nextString(count);
		if (next_string != s)
		{
			throw new BayLang.Exceptions.ParserExpected(s, this, this.file_name)
		}
		this.readString(count);
	},
	/**
	 * Skip chars
	 */
	skipChar: function(ch)
	{
		if (this.nextChar() == ch)
		{
			this.readChar();
			return true;
		}
		return false;
	},
	/**
	 * Skip space
	 */
	skipSpace: function()
	{
		while (!this.eof() && this.constructor.isSkipChar(this.nextChar()))
		{
			this.readChar();
		}
	},
	/**
	 * Returns true if token char
	 */
	isTokenChar: function(ch)
	{
		return Runtime.rs.indexOf("qazwsxedcrfvtgbyhnujmikolp0123456789_", Runtime.rs.lower(ch)) !== -1;
	},
	/**
	 * Read next token
	 */
	readToken: function()
	{
		var items = Runtime.Vector.from([]);
		this.skipSpace();
		if (this.eof())
		{
			return "";
		}
		if (!this.isTokenChar(this.nextChar()))
		{
			return this.readChar();
		}
		while (!this.eof() && this.isTokenChar(this.nextChar()))
		{
			items.push(this.readChar());
		}
		return Runtime.rs.join("", items);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.file_name = null;
		this.content = null;
		this.content_sz = 0;
		this.pos = 0;
		this.x = 0;
		this.y = 0;
		this.tab_size = 4;
	},
});
Object.assign(BayLang.Caret, Runtime.BaseObject);
Object.assign(BayLang.Caret,
{
	/**
	 * Return true if is char
	 * @param char ch
	 * @return boolean
	 */
	isChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.Caret.isChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("qazwsxedcrfvtgbyhnujmikolp", Runtime.rs.lower(ch)) !== -1;
		Runtime.rtl._memorizeSave("BayLang.Caret.isChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if is number
	 * @param char ch
	 * @return boolean
	 */
	isNumber: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.Caret.isNumber", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("0123456789", ch) !== -1;
		Runtime.rtl._memorizeSave("BayLang.Caret.isNumber", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	isHexChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.Caret.isHexChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("0123456789abcdef", Runtime.rs.lower(ch)) !== -1;
		Runtime.rtl._memorizeSave("BayLang.Caret.isHexChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if is string of numbers
	 * @param string s
	 * @return boolean
	 */
	isStringOfNumbers: function(s)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.Caret.isStringOfNumbers", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var sz = Runtime.rs.strlen(s);
		for (var i = 0; i < sz; i++)
		{
			if (!this.isNumber(Runtime.rs.charAt(s, i)))
			{
				var __memorize_value = false;
				Runtime.rtl._memorizeSave("BayLang.Caret.isStringOfNumbers", arguments, __memorize_value);
				return __memorize_value;
			}
		}
		var __memorize_value = true;
		Runtime.rtl._memorizeSave("BayLang.Caret.isStringOfNumbers", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if char is system or space. ASCII code <= 32.
	 * @param char ch
	 * @return boolean
	 */
	isSkipChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.Caret.isSkipChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (Runtime.rs.ord(ch) <= 32)
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.Caret.isSkipChar", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = false;
		Runtime.rtl._memorizeSave("BayLang.Caret.isSkipChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.Caret";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
	__implements__:
	[
		Runtime.SerializeInterface,
	],
});
Runtime.rtl.defClass(BayLang.Caret);
window["BayLang.Caret"] = BayLang.Caret;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Caret;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.CoreParser = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.CoreParser.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.CoreParser.prototype.constructor = BayLang.CoreParser;
Object.assign(BayLang.CoreParser.prototype,
{
	/**
	 * Returns true if eof
	 */
	isEof: function()
	{
		return this.caret.pos >= this.content_sz;
	},
	/**
	 * Returns caret
	 */
	getCaret: function()
	{
		return this.caret.clone(Runtime.Map.from({"file_name":this.file_name,"content":this.content,"content_sz":this.content_sz}));
	},
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.tab_size = 4;
		this.file_name = "";
		this.content = null;
		this.content_sz = 0;
		this.caret = null;
		this.find_ident = true;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "tab_size")return this.tab_size;
		else if (k == "file_name")return this.file_name;
		else if (k == "content")return this.content;
		else if (k == "content_sz")return this.content_sz;
		else if (k == "caret")return this.caret;
		else if (k == "find_ident")return this.find_ident;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.CoreParser, Runtime.BaseStruct);
Object.assign(BayLang.CoreParser,
{
	/**
	 * Reset parser
	 */
	reset: function(parser)
	{
		return parser.copy(Runtime.Map.from({"caret":new BayLang.Caret(Runtime.Map.from({})),"token":null}));
	},
	/**
	 * Set content
	 */
	setContent: function(parser, content)
	{
		return parser.copy(Runtime.Map.from({"content":new Runtime.Reference(content),"content_sz":Runtime.rs.strlen(content)}));
	},
	/**
	 * Parse file and convert to BaseOpCode
	 */
	parse: function(parser, content)
	{
		parser = this.reset(parser);
		parser = this.setContent(parser, content);
		while (parser.caret.pos < parser.content_sz)
		{
			parser = parser.constructor.nextToken(parser);
		}
		return parser;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.CoreParser";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("tab_size");
		a.push("file_name");
		a.push("content");
		a.push("content_sz");
		a.push("caret");
		a.push("find_ident");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.CoreParser);
window["BayLang.CoreParser"] = BayLang.CoreParser;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.CoreParser;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.CoreToken = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.CoreToken.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.CoreToken.prototype.constructor = BayLang.CoreToken;
Object.assign(BayLang.CoreToken.prototype,
{
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.kind = "";
		this.content = "";
		this.caret_start = null;
		this.caret_end = null;
		this.eof = false;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "kind")return this.kind;
		else if (k == "content")return this.content;
		else if (k == "caret_start")return this.caret_start;
		else if (k == "caret_end")return this.caret_end;
		else if (k == "eof")return this.eof;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.CoreToken, Runtime.BaseStruct);
Object.assign(BayLang.CoreToken,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.CoreToken";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("kind");
		a.push("content");
		a.push("caret_start");
		a.push("caret_end");
		a.push("eof");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.CoreToken);
window["BayLang.CoreToken"] = BayLang.CoreToken;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.CoreToken;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.CoreTranslator = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.CoreTranslator.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.CoreTranslator.prototype.constructor = BayLang.CoreTranslator;
Object.assign(BayLang.CoreTranslator.prototype,
{
	/**
	 * Set preprocessor flag
	 */
	setFlag: function(flag_name, value)
	{
		var t = this;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["preprocessor_flags", flag_name]), value);
		return t;
	},
	/**
	 * Find save op code
	 */
	findSaveOpCode: function(op_code)
	{
		return this.save_op_codes.findItem(Runtime.lib.equalAttr("op_code", op_code));
	},
	/**
	 * Increment indent level
	 */
	levelInc: function()
	{
		return this.copy(Runtime.Map.from({"indent_level":this.indent_level + 1}));
	},
	/**
	 * Decrease indent level
	 */
	levelDec: function()
	{
		return this.copy(Runtime.Map.from({"indent_level":this.indent_level - 1}));
	},
	/**
	 * Output content with indent
	 */
	s: function(s, content)
	{
		if (content == undefined) content = null;
		if (s == "")
		{
			return "";
		}
		if (content === "")
		{
			return s;
		}
		return this.crlf + Runtime.rtl.toStr(Runtime.rs.str_repeat(this.indent, this.indent_level)) + Runtime.rtl.toStr(s);
	},
	/**
	 * Output content with indent
	 */
	s2: function(s)
	{
		return this.crlf + Runtime.rtl.toStr(Runtime.rs.str_repeat(this.indent, this.indent_level)) + Runtime.rtl.toStr(s);
	},
	/**
	 * Output content with opcode level
	 */
	o: function(s, opcode_level_in, opcode_level_out)
	{
		if (opcode_level_in < opcode_level_out)
		{
			return "(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(")");
		}
		return s;
	},
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.current_namespace_name = "";
		this.current_class_name = "";
		this.current_class_full_name = "";
		this.current_class_extends_name = "";
		this.current_class = null;
		this.current_function = null;
		this.modules = null;
		this.vars = null;
		this.save_vars = null;
		this.save_op_codes = null;
		this.save_op_code_inc = 0;
		this.is_static_function = false;
		this.is_operation = false;
		this.opcode_level = 0;
		this.indent_level = 0;
		this.indent = "\t";
		this.crlf = "\n";
		this.flag_struct_check_types = false;
		this.preprocessor_flags = null;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "current_namespace_name")return this.current_namespace_name;
		else if (k == "current_class_name")return this.current_class_name;
		else if (k == "current_class_full_name")return this.current_class_full_name;
		else if (k == "current_class_extends_name")return this.current_class_extends_name;
		else if (k == "current_class")return this.current_class;
		else if (k == "current_function")return this.current_function;
		else if (k == "modules")return this.modules;
		else if (k == "vars")return this.vars;
		else if (k == "save_vars")return this.save_vars;
		else if (k == "save_op_codes")return this.save_op_codes;
		else if (k == "save_op_code_inc")return this.save_op_code_inc;
		else if (k == "is_static_function")return this.is_static_function;
		else if (k == "is_operation")return this.is_operation;
		else if (k == "opcode_level")return this.opcode_level;
		else if (k == "indent_level")return this.indent_level;
		else if (k == "indent")return this.indent;
		else if (k == "crlf")return this.crlf;
		else if (k == "flag_struct_check_types")return this.flag_struct_check_types;
		else if (k == "preprocessor_flags")return this.preprocessor_flags;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.CoreTranslator, Runtime.BaseStruct);
Object.assign(BayLang.CoreTranslator,
{
	/**
	 * Translate BaseOpCode
	 */
	translate: function(t, op_code)
	{
		return "";
	},
	/**
	 * Inc save op code
	 */
	nextSaveOpCode: function(t)
	{
		return "__v" + Runtime.rtl.toStr(t.save_op_code_inc);
	},
	/**
	 * Inc save op code
	 */
	incSaveOpCode: function(t)
	{
		var var_name = this.nextSaveOpCode(t);
		var save_op_code_inc = t.save_op_code_inc + 1;
		t = t.copy(Runtime.Map.from({"save_op_code_inc":save_op_code_inc}));
		return Runtime.Vector.from([t,var_name]);
	},
	/**
	 * Add save op code
	 */
	addSaveOpCode: function(t, data)
	{
		var var_name = data.get("var_name", "");
		var content = data.get("content", "");
		var var_content = data.get("var_content", "");
		var save_op_code_inc = t.save_op_code_inc;
		if (var_name == "" && content == "")
		{
			var_name = this.nextSaveOpCode(t);
			data = data.setIm("var_name", var_name);
			save_op_code_inc += 1;
		}
		var s = new BayLang.SaveOpCode(data);
		t = t.copy(Runtime.Map.from({"save_op_codes":t.save_op_codes.pushIm(s),"save_op_code_inc":save_op_code_inc}));
		return Runtime.Vector.from([t,var_name]);
	},
	/**
	 * Clear save op code
	 */
	clearSaveOpCode: function(t)
	{
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), new Runtime.Collection());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), 0);
		return t;
	},
	/**
	 * Output save op code content
	 */
	outputSaveOpCode: function(t, save_op_code_value)
	{
		if (save_op_code_value == undefined) save_op_code_value = 0;
		return "";
	},
	/**
	 * Call f and return result with save op codes
	 */
	saveOpCodeCall: function(t, f, args)
	{
		/* Clear save op codes */
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		var res = Runtime.rtl.apply(f, args.unshiftIm(t));
		t = Runtime.rtl.attr(res, 0);
		var value = Runtime.rtl.attr(res, 1);
		/* Output save op code */
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([t,save,value]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.CoreTranslator";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("current_namespace_name");
		a.push("current_class_name");
		a.push("current_class_full_name");
		a.push("current_class_extends_name");
		a.push("current_class");
		a.push("current_function");
		a.push("modules");
		a.push("vars");
		a.push("save_vars");
		a.push("save_op_codes");
		a.push("save_op_code_inc");
		a.push("is_static_function");
		a.push("is_operation");
		a.push("opcode_level");
		a.push("indent_level");
		a.push("indent");
		a.push("crlf");
		a.push("flag_struct_check_types");
		a.push("preprocessor_flags");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.CoreTranslator);
window["BayLang.CoreTranslator"] = BayLang.CoreTranslator;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.CoreTranslator;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.LangConstant = function()
{
};
Object.assign(BayLang.LangConstant.prototype,
{
});
Object.assign(BayLang.LangConstant,
{
	ERROR_PARSER: -1000,
	ERROR_PARSER_EOF: -1001,
	ERROR_PARSER_EXPECTED: -1002,
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.LangConstant";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangConstant);
window["BayLang.LangConstant"] = BayLang.LangConstant;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangConstant;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.LangUtils = function()
{
};
Object.assign(BayLang.LangUtils.prototype,
{
});
Object.assign(BayLang.LangUtils,
{
	/**
	 * Parse file and convert to BaseOpCode
	 */
	parse: function(parser, text)
	{
		var res = parser.constructor.parse(parser, text);
		return Runtime.rtl.attr(res, 1);
	},
	/**
	 * Translate BaseOpCode to string
	 */
	translate: function(translator, op_code)
	{
		var res = translator.constructor.translate(translator, op_code);
		return Runtime.rtl.attr(res, 1);
	},
	/**
	 * Create translator
	 */
	createTranslator: function(lang)
	{
		if (lang == undefined) lang = "";
		var t = null;
		if (lang == "bay")
		{
			t = new BayLang.LangBay.TranslatorBay();
			t.reset();
		}
		else if (lang == "es6")
		{
			t = new BayLang.LangES6.TranslatorES6();
			t = t.constructor.reset(t);
		}
		else if (lang == "nodejs")
		{
			t = new BayLang.LangNode.TranslatorNode();
			t = t.constructor.reset(t);
		}
		else if (lang == "php")
		{
			t = new BayLang.LangPHP.TranslatorPHP();
			t = t.constructor.reset(t);
		}
		return t;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.LangUtils";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangUtils);
window["BayLang.LangUtils"] = BayLang.LangUtils;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangUtils;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.SaveOpCode = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.SaveOpCode.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.SaveOpCode.prototype.constructor = BayLang.SaveOpCode;
Object.assign(BayLang.SaveOpCode.prototype,
{
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.var_name = "";
		this.var_content = "";
		this.content = "";
		this.op_code = null;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "var_name")return this.var_name;
		else if (k == "var_content")return this.var_content;
		else if (k == "content")return this.content;
		else if (k == "op_code")return this.op_code;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.SaveOpCode, Runtime.BaseStruct);
Object.assign(BayLang.SaveOpCode,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.SaveOpCode";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("var_name");
		a.push("var_content");
		a.push("content");
		a.push("op_code");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.SaveOpCode);
window["BayLang.SaveOpCode"] = BayLang.SaveOpCode;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.SaveOpCode;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.TokenReader = function()
{
	Runtime.BaseObject.apply(this, arguments);
};
BayLang.TokenReader.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.TokenReader.prototype.constructor = BayLang.TokenReader;
Object.assign(BayLang.TokenReader.prototype,
{
	/**
	 * Init token reader
	 */
	init: function(caret)
	{
		this.main_caret = caret;
		this.next_caret = caret.copy();
		this.readToken();
	},
	/**
	 * Returns eof
	 */
	eof: function()
	{
		return this.main_caret.eof();
	},
	/**
	 * Returns next token
	 */
	nextToken: function()
	{
		return this.next_token;
	},
	/**
	 * Read token
	 */
	readToken: function()
	{
		var token = this.next_token;
		this.main_caret.seek(this.next_caret);
		this.next_token = this.next_caret.readToken();
		return token;
	},
	/**
	 * Match next token
	 */
	matchToken: function(ch)
	{
		if (this.nextToken() != ch)
		{
			throw new BayLang.Exceptions.ParserExpected(ch, this.main_caret, this.main_caret.file_name)
		}
		this.readToken();
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.main_caret = null;
		this.next_caret = null;
		this.next_token = "";
	},
});
Object.assign(BayLang.TokenReader, Runtime.BaseObject);
Object.assign(BayLang.TokenReader,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.TokenReader";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.TokenReader);
window["BayLang.TokenReader"] = BayLang.TokenReader;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.TokenReader;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Exceptions == 'undefined') BayLang.Exceptions = {};
BayLang.Exceptions.ParserUnknownError = function(s, code, prev)
{
	if (prev == undefined) prev = null;
	if (code == -1)
	{
		code = BayLang.LangConstant.ERROR_PARSER;
	}
	Runtime.Exceptions.AbstractException.call(this, s, code, prev);
};
BayLang.Exceptions.ParserUnknownError.prototype = Object.create(Runtime.Exceptions.AbstractException.prototype);
BayLang.Exceptions.ParserUnknownError.prototype.constructor = BayLang.Exceptions.ParserUnknownError;
Object.assign(BayLang.Exceptions.ParserUnknownError.prototype,
{
});
Object.assign(BayLang.Exceptions.ParserUnknownError, Runtime.Exceptions.AbstractException);
Object.assign(BayLang.Exceptions.ParserUnknownError,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Exceptions";
	},
	getClassName: function()
	{
		return "BayLang.Exceptions.ParserUnknownError";
	},
	getParentClassName: function()
	{
		return "Runtime.Exceptions.AbstractException";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Exceptions.ParserUnknownError);
window["BayLang.Exceptions.ParserUnknownError"] = BayLang.Exceptions.ParserUnknownError;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Exceptions.ParserUnknownError;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Exceptions == 'undefined') BayLang.Exceptions = {};
BayLang.Exceptions.ParserError = function(s, caret, file, code, prev)
{
	if (file == undefined) file = "";
	if (code == undefined) code = -1;
	if (prev == undefined) prev = null;
	BayLang.Exceptions.ParserUnknownError.call(this, s, code, prev);
	this.error_line = caret.y + 1;
	this.error_pos = caret.x + 1;
	this.error_file = file;
};
BayLang.Exceptions.ParserError.prototype = Object.create(BayLang.Exceptions.ParserUnknownError.prototype);
BayLang.Exceptions.ParserError.prototype.constructor = BayLang.Exceptions.ParserError;
Object.assign(BayLang.Exceptions.ParserError.prototype,
{
	buildErrorMessage: function()
	{
		var error_str = this.getErrorMessage();
		var file = this.getFileName();
		var line = this.getErrorLine();
		var pos = this.getErrorPos();
		if (line != -1)
		{
			error_str += Runtime.rtl.toStr(" at Ln:" + Runtime.rtl.toStr(line) + Runtime.rtl.toStr(((pos != "") ? (", Pos:" + Runtime.rtl.toStr(pos)) : (""))));
		}
		if (file != "")
		{
			error_str += Runtime.rtl.toStr(" in file:'" + Runtime.rtl.toStr(file) + Runtime.rtl.toStr("'"));
		}
		return error_str;
	},
});
Object.assign(BayLang.Exceptions.ParserError, BayLang.Exceptions.ParserUnknownError);
Object.assign(BayLang.Exceptions.ParserError,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Exceptions";
	},
	getClassName: function()
	{
		return "BayLang.Exceptions.ParserError";
	},
	getParentClassName: function()
	{
		return "BayLang.Exceptions.ParserUnknownError";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Exceptions.ParserError);
window["BayLang.Exceptions.ParserError"] = BayLang.Exceptions.ParserError;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Exceptions.ParserError;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Exceptions == 'undefined') BayLang.Exceptions = {};
BayLang.Exceptions.ParserEOF = function(prev)
{
	if (prev == undefined) prev = null;
	BayLang.Exceptions.ParserUnknownError.call(this, "ERROR_PARSER_EOF", BayLang.LangConstant.ERROR_PARSER_EOF, prev);
};
BayLang.Exceptions.ParserEOF.prototype = Object.create(BayLang.Exceptions.ParserUnknownError.prototype);
BayLang.Exceptions.ParserEOF.prototype.constructor = BayLang.Exceptions.ParserEOF;
Object.assign(BayLang.Exceptions.ParserEOF.prototype,
{
});
Object.assign(BayLang.Exceptions.ParserEOF, BayLang.Exceptions.ParserUnknownError);
Object.assign(BayLang.Exceptions.ParserEOF,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Exceptions";
	},
	getClassName: function()
	{
		return "BayLang.Exceptions.ParserEOF";
	},
	getParentClassName: function()
	{
		return "BayLang.Exceptions.ParserUnknownError";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Exceptions.ParserEOF);
window["BayLang.Exceptions.ParserEOF"] = BayLang.Exceptions.ParserEOF;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Exceptions.ParserEOF;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Exceptions == 'undefined') BayLang.Exceptions = {};
BayLang.Exceptions.ParserExpected = function(s, caret, file, prev)
{
	if (file == undefined) file = "";
	if (prev == undefined) prev = null;
	BayLang.Exceptions.ParserError.call(this, s + Runtime.rtl.toStr(" expected"), caret, file, BayLang.LangConstant.ERROR_PARSER_EXPECTED, prev);
};
BayLang.Exceptions.ParserExpected.prototype = Object.create(BayLang.Exceptions.ParserError.prototype);
BayLang.Exceptions.ParserExpected.prototype.constructor = BayLang.Exceptions.ParserExpected;
Object.assign(BayLang.Exceptions.ParserExpected.prototype,
{
});
Object.assign(BayLang.Exceptions.ParserExpected, BayLang.Exceptions.ParserError);
Object.assign(BayLang.Exceptions.ParserExpected,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Exceptions";
	},
	getClassName: function()
	{
		return "BayLang.Exceptions.ParserExpected";
	},
	getParentClassName: function()
	{
		return "BayLang.Exceptions.ParserError";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Exceptions.ParserExpected);
window["BayLang.Exceptions.ParserExpected"] = BayLang.Exceptions.ParserExpected;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Exceptions.ParserExpected;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Exceptions == 'undefined') BayLang.Exceptions = {};
BayLang.Exceptions.DeclaredClass = function(prev)
{
	if (prev == undefined) prev = null;
	Runtime.Exceptions.AbstractException.call(this, "Declared class", -1, prev);
};
BayLang.Exceptions.DeclaredClass.prototype = Object.create(Runtime.Exceptions.AbstractException.prototype);
BayLang.Exceptions.DeclaredClass.prototype.constructor = BayLang.Exceptions.DeclaredClass;
Object.assign(BayLang.Exceptions.DeclaredClass.prototype,
{
});
Object.assign(BayLang.Exceptions.DeclaredClass, Runtime.Exceptions.AbstractException);
Object.assign(BayLang.Exceptions.DeclaredClass,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Exceptions";
	},
	getClassName: function()
	{
		return "BayLang.Exceptions.DeclaredClass";
	},
	getParentClassName: function()
	{
		return "Runtime.Exceptions.AbstractException";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Exceptions.DeclaredClass);
window["BayLang.Exceptions.DeclaredClass"] = BayLang.Exceptions.DeclaredClass;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Exceptions.DeclaredClass;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBay = function()
{
	BayLang.CoreParser.apply(this, arguments);
};
BayLang.LangBay.ParserBay.prototype = Object.create(BayLang.CoreParser.prototype);
BayLang.LangBay.ParserBay.prototype.constructor = BayLang.LangBay.ParserBay;
Object.assign(BayLang.LangBay.ParserBay.prototype,
{
	_init: function()
	{
		BayLang.CoreParser.prototype._init.call(this);
		this.vars = null;
		this.uses = null;
		this.current_namespace = null;
		this.current_class = null;
		this.current_namespace_name = "";
		this.current_class_name = "";
		this.current_class_kind = "";
		this.current_class_abstract = false;
		this.current_class_declare = false;
		this.find_identifier = true;
		this.skip_comments = true;
		this.pipe_kind = "";
		this.is_pipe = false;
		this.is_html = false;
		this.is_local_css = false;
		this.parser_base = null;
		this.parser_expression = null;
		this.parser_html = null;
		this.parser_operator = null;
		this.parser_preprocessor = null;
		this.parser_program = null;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "vars")return this.vars;
		else if (k == "uses")return this.uses;
		else if (k == "current_namespace")return this.current_namespace;
		else if (k == "current_class")return this.current_class;
		else if (k == "current_namespace_name")return this.current_namespace_name;
		else if (k == "current_class_name")return this.current_class_name;
		else if (k == "current_class_kind")return this.current_class_kind;
		else if (k == "current_class_abstract")return this.current_class_abstract;
		else if (k == "current_class_declare")return this.current_class_declare;
		else if (k == "find_identifier")return this.find_identifier;
		else if (k == "skip_comments")return this.skip_comments;
		else if (k == "pipe_kind")return this.pipe_kind;
		else if (k == "is_pipe")return this.is_pipe;
		else if (k == "is_html")return this.is_html;
		else if (k == "is_local_css")return this.is_local_css;
		else if (k == "parser_base")return this.parser_base;
		else if (k == "parser_expression")return this.parser_expression;
		else if (k == "parser_html")return this.parser_html;
		else if (k == "parser_operator")return this.parser_operator;
		else if (k == "parser_preprocessor")return this.parser_preprocessor;
		else if (k == "parser_program")return this.parser_program;
		return BayLang.CoreParser.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangBay.ParserBay, BayLang.CoreParser);
Object.assign(BayLang.LangBay.ParserBay,
{
	/**
	 * Reset parser
	 */
	reset: function(parser)
	{
		return parser.copy(Runtime.Map.from({"vars":new Runtime.Dict(),"uses":new Runtime.Dict(),"caret":new BayLang.Caret(Runtime.Map.from({})),"token":null,"parser_base":new BayLang.LangBay.ParserBayBase(),"parser_expression":new BayLang.LangBay.ParserBayExpression(),"parser_html":new BayLang.LangBay.ParserBayHtml(),"parser_operator":new BayLang.LangBay.ParserBayOperator(),"parser_preprocessor":new BayLang.LangBay.ParserBayPreprocessor(),"parser_program":new BayLang.LangBay.ParserBayProgram()}));
	},
	/**
	 * Parse file and convert to BaseOpCode
	 */
	parse: function(parser, content)
	{
		parser = this.reset(parser);
		parser = this.setContent(parser, content);
		return parser.parser_program.constructor.readProgram(parser);
	},
	/**
	 * Find module name
	 */
	findModuleName: function(parser, module_name)
	{
		if (module_name == "Collection")
		{
			return "Runtime.Collection";
		}
		else if (module_name == "Dict")
		{
			return "Runtime.Dict";
		}
		else if (module_name == "Map")
		{
			return "Runtime.Map";
		}
		else if (module_name == "Vector")
		{
			return "Runtime.Vector";
		}
		else if (module_name == "rs")
		{
			return "Runtime.rs";
		}
		else if (module_name == "rtl")
		{
			return "Runtime.rtl";
		}
		else if (module_name == "ArrayInterface")
		{
			return "";
		}
		else if (parser.uses.has(module_name))
		{
			return parser.uses.item(module_name);
		}
		return module_name;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBay";
	},
	getParentClassName: function()
	{
		return "BayLang.CoreParser";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("vars");
		a.push("uses");
		a.push("current_namespace");
		a.push("current_class");
		a.push("current_namespace_name");
		a.push("current_class_name");
		a.push("current_class_kind");
		a.push("current_class_abstract");
		a.push("current_class_declare");
		a.push("find_identifier");
		a.push("skip_comments");
		a.push("pipe_kind");
		a.push("is_pipe");
		a.push("is_html");
		a.push("is_local_css");
		a.push("parser_base");
		a.push("parser_expression");
		a.push("parser_html");
		a.push("parser_operator");
		a.push("parser_preprocessor");
		a.push("parser_program");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBay);
window["BayLang.LangBay.ParserBay"] = BayLang.LangBay.ParserBay;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBay;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayBase = function()
{
};
Object.assign(BayLang.LangBay.ParserBayBase.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayBase,
{
	/**
	 * Return true if is char
	 * @param char ch
	 * @return boolean
	 */
	isChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("qazwsxedcrfvtgbyhnujmikolp", Runtime.rs.lower(ch)) !== -1;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if is number
	 * @param char ch
	 * @return boolean
	 */
	isNumber: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isNumber", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("0123456789", ch) !== -1;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isNumber", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	isHexChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isHexChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("0123456789abcdef", Runtime.rs.lower(ch)) !== -1;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isHexChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if is string of numbers
	 * @param string s
	 * @return boolean
	 */
	isStringOfNumbers: function(s)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isStringOfNumbers", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var sz = Runtime.rs.strlen(s);
		for (var i = 0; i < sz; i++)
		{
			if (!this.isNumber(Runtime.rs.charAt(s, i)))
			{
				var __memorize_value = false;
				Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isStringOfNumbers", arguments, __memorize_value);
				return __memorize_value;
			}
		}
		var __memorize_value = true;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isStringOfNumbers", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Is system type
	 */
	isSystemType: function(name)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isSystemType", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (name == "var")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "void")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "bool")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "byte")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "int")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "double")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "float")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "char")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "string")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "list")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "scalar")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "primitive")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "html")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Error")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Object")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "DateTime")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Collection")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Dict")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Vector")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "Map")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "rs")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "rtl")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "ArrayInterface")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = false;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSystemType", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Returns true if name is identifier
	 */
	isIdentifier: function(name)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isIdentifier", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (name == "")
		{
			var __memorize_value = false;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isIdentifier", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "@")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isIdentifier", arguments, __memorize_value);
			return __memorize_value;
		}
		if (this.isNumber(Runtime.rs.charAt(name, 0)))
		{
			var __memorize_value = false;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isIdentifier", arguments, __memorize_value);
			return __memorize_value;
		}
		var sz = Runtime.rs.strlen(name);
		for (var i = 0; i < sz; i++)
		{
			var ch = Runtime.rs.charAt(name, i);
			if (this.isChar(ch) || this.isNumber(ch) || ch == "_")
			{
				continue;
			}
			var __memorize_value = false;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isIdentifier", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = true;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isIdentifier", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Returns true if reserved words
	 */
	isReserved: function(name)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isReserved", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (name == "__async_t")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isReserved", arguments, __memorize_value);
			return __memorize_value;
		}
		if (name == "__async_var")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isReserved", arguments, __memorize_value);
			return __memorize_value;
		}
		/*if (name == "__ctx") return true;*/
		/*if (name == "ctx") return true;*/
		if (Runtime.rs.substr(name, 0, 3) == "__v")
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isReserved", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = false;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isReserved", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Returns kind of identifier or thrown Error
	 */
	findIdentifier: function(parser, name, caret)
	{
		var kind = "";
		if (parser.vars.has(name))
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_VARIABLE;
		}
		else if (parser.uses.has(name))
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_CLASS;
		}
		else if (this.isSystemType(name))
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE;
		}
		else if (name == "log")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_SYS_FUNCTION;
		}
		else if (name == "window" || name == "document")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_VARIABLE;
		}
		else if (name == "null" || name == "true" || name == "false")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_CONSTANT;
		}
		else if (name == "fn")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_FUNCTION;
		}
		else if (name == "@" || name == "_")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_CONTEXT;
		}
		else if (name == "static" || name == "self" || name == "this" || name == "parent")
		{
			kind = BayLang.OpCodes.OpIdentifier.KIND_CLASSREF;
		}
		return kind;
	},
	/**
	 * Return true if char is token char
	 * @param {char} ch
	 * @return {boolean}
	 */
	isTokenChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isTokenChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var __memorize_value = Runtime.rs.indexOf("qazwsxedcrfvtgbyhnujmikolp0123456789_", Runtime.rs.lower(ch)) !== -1;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isTokenChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Return true if char is system or space. ASCII code <= 32.
	 * @param char ch
	 * @return boolean
	 */
	isSkipChar: function(ch)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayBase.isSkipChar", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (Runtime.rs.ord(ch) <= 32)
		{
			var __memorize_value = true;
			Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSkipChar", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = false;
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayBase.isSkipChar", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Returns next X
	 */
	nextX: function(parser, ch, x, direction)
	{
		if (direction == undefined) direction = 1;
		if (ch == "\t")
		{
			return x + parser.tab_size * direction;
		}
		if (ch == "\n")
		{
			return 0;
		}
		return x + direction;
	},
	/**
	 * Returns next Y
	 */
	nextY: function(parser, ch, y, direction)
	{
		if (direction == undefined) direction = 1;
		if (ch == "\n")
		{
			return y + direction;
		}
		return y;
	},
	/**
	 * Returns next
	 */
	next: function(parser, s, x, y, pos)
	{
		var sz = Runtime.rs.strlen(s);
		for (var i = 0; i < sz; i++)
		{
			var ch = Runtime.rs.substr(s, i, 1);
			x = this.nextX(parser, ch, x);
			y = this.nextY(parser, ch, y);
			pos = pos + 1;
		}
		return Runtime.Vector.from([x,y,pos]);
	},
	/**
	 * Open comment
	 */
	isCommentOpen: function(parser, str)
	{
		return parser.skip_comments && ((parser.is_html) ? (str == "<!--") : (str == "/*"));
	},
	/**
	 * Close comment
	 */
	isCommentClose: function(parser, str)
	{
		return (parser.is_html) ? (str == "-->") : (str == "*/");
	},
	/**
	 * Skip char
	 */
	skipChar: function(parser, content, start_pos)
	{
		var x = start_pos.x;
		var y = start_pos.y;
		var pos = start_pos.pos;
		var skip_comments = parser.skip_comments;
		/* Check boundaries */
		if (pos >= parser.content_sz)
		{
			throw new BayLang.Exceptions.ParserEOF()
		}
		var ch = Runtime.rs.charAt(content.ref, pos);
		var ch2 = Runtime.rs.substr(content.ref, pos, 2);
		var ch4 = Runtime.rs.substr(content.ref, pos, 4);
		while ((this.isSkipChar(ch) || this.isCommentOpen(parser, ch2) || this.isCommentOpen(parser, ch4)) && pos < parser.content_sz)
		{
			if (this.isCommentOpen(parser, ch2))
			{
				ch2 = Runtime.rs.substr(content.ref, pos, 2);
				while (!this.isCommentClose(parser, ch2) && pos < parser.content_sz)
				{
					x = this.nextX(parser, ch, x);
					y = this.nextY(parser, ch, y);
					pos = pos + 1;
					if (pos >= parser.content_sz)
					{
						break;
					}
					ch = Runtime.rs.charAt(content.ref, pos);
					ch2 = Runtime.rs.substr(content.ref, pos, 2);
				}
				if (this.isCommentClose(parser, ch2))
				{
					x = x + 2;
					pos = pos + 2;
				}
			}
			else if (this.isCommentOpen(parser, ch4))
			{
				var ch3 = Runtime.rs.substr(content.ref, pos, 3);
				while (!this.isCommentClose(parser, ch3) && pos < parser.content_sz)
				{
					x = this.nextX(parser, ch, x);
					y = this.nextY(parser, ch, y);
					pos = pos + 1;
					if (pos >= parser.content_sz)
					{
						break;
					}
					ch = Runtime.rs.charAt(content.ref, pos);
					ch3 = Runtime.rs.substr(content.ref, pos, 3);
				}
				if (this.isCommentClose(parser, ch3))
				{
					x = x + 3;
					pos = pos + 3;
				}
			}
			else
			{
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
			}
			if (pos >= parser.content_sz)
			{
				break;
			}
			ch = Runtime.rs.charAt(content.ref, pos);
			ch2 = Runtime.rs.substr(content.ref, pos, 2);
			ch4 = Runtime.rs.substr(content.ref, pos, 4);
		}
		return new BayLang.Caret(Runtime.Map.from({"pos":pos,"x":x,"y":y}));
	},
	/**
	 * Read special token
	 */
	readSpecialToken: function(parser, content, start_pos)
	{
		var pos = start_pos.pos;
		var s = "";
		s = Runtime.rs.substr(content.ref, pos, 10);
		if (s == "#endswitch")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 7);
		if (s == "#ifcode" || s == "#switch" || s == "#elseif" || s == "%render")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 6);
		if (s == "#endif" || s == "#ifdef" || s == "%while")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 5);
		if (s == "#case" || s == "%else")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 4);
		if (s == "@css" || s == "%for" || s == "%var" || s == "%set")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 3);
		if (s == "!--" || s == "!==" || s == "===" || s == "..." || s == "#if" || s == "%if")
		{
			return s;
		}
		s = Runtime.rs.substr(content.ref, pos, 2);
		if (s == "==" || s == "!=" || s == "<=" || s == ">=" || s == "=>" || s == "->" || s == "|>" || s == "::" || s == "+=" || s == "-=" || s == "~=" || s == "**" || s == "<<" || s == ">>" || s == "++" || s == "--")
		{
			return s;
		}
		return "";
	},
	/**
	 * Read next token and return caret end
	 */
	nextToken: function(parser, content, start_pos)
	{
		var is_first = true;
		var x = start_pos.x;
		var y = start_pos.y;
		var pos = start_pos.pos;
		/* Check boundaries */
		if (pos >= parser.content_sz)
		{
			throw new BayLang.Exceptions.ParserEOF()
		}
		var s = this.readSpecialToken(parser, content, start_pos);
		if (s != "")
		{
			var sz = Runtime.rs.strlen(s);
			for (var i = 0; i < sz; i++)
			{
				var ch = Runtime.rs.charAt(s, i);
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
			}
			return new BayLang.Caret(Runtime.Map.from({"pos":pos,"x":x,"y":y}));
		}
		var ch = Runtime.rs.charAt(content.ref, pos);
		if (!this.isTokenChar(ch))
		{
			x = this.nextX(parser, ch, x);
			y = this.nextY(parser, ch, y);
			pos = pos + 1;
		}
		else
		{
			while (this.isTokenChar(ch))
			{
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= parser.content_sz)
				{
					break;
				}
				ch = Runtime.rs.charAt(content.ref, pos);
			}
		}
		return new BayLang.Caret(Runtime.Map.from({"pos":pos,"x":x,"y":y}));
	},
	/**
	 * Read back
	 */
	readBack: function(parser, search)
	{
		if (search == undefined) search = "";
		var content = parser.content;
		var caret = parser.caret;
		var x = caret.x;
		var y = caret.y;
		var pos = caret.pos;
		var search_sz = Runtime.rs.strlen(search);
		var s = "";
		while (pos >= 0)
		{
			var ch = Runtime.rs.charAt(content.ref, pos);
			x = this.nextX(parser, ch, x, -1);
			y = this.nextY(parser, ch, y, -1);
			pos--;
			s = Runtime.rs.substr(content.ref, pos, search_sz);
			if (s == search)
			{
				break;
			}
		}
		return parser.copy(Runtime.Map.from({"caret":new BayLang.Caret(Runtime.Map.from({"pos":pos,"x":x,"y":y}))}));
	},
	/**
	 * Read next token
	 */
	readToken: function(parser)
	{
		var caret_start = null;
		var caret_end = null;
		var eof = false;
		try
		{
			caret_start = this.skipChar(parser, parser.content, parser.caret);
			caret_end = this.nextToken(parser, parser.content, caret_start);
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserEOF)
			{
				var e = _ex;
				
				if (caret_start == null)
				{
					caret_start = parser.caret;
				}
				if (caret_end == null)
				{
					caret_end = caret_start;
				}
				eof = true;
			}
			else if (true)
			{
				var e = _ex;
				
				throw e
			}
			else
			{
				throw _ex;
			}
		}
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"caret":caret_end})),new BayLang.CoreToken(Runtime.Map.from({"content":Runtime.rs.substr(parser.content.ref, caret_start.pos, caret_end.pos - caret_start.pos),"caret_start":caret_start,"caret_end":caret_end,"eof":eof}))]);
	},
	/**
	 * Look next token
	 */
	lookToken: function(parser, token)
	{
		var token_content = "";
		var content = parser.content;
		var caret_start = null;
		var caret_end = null;
		var sz = Runtime.rs.strlen(token);
		var eof = false;
		var find = false;
		try
		{
			caret_start = this.skipChar(parser, content, parser.caret);
			var pos = caret_start.pos;
			var x = caret_start.x;
			var y = caret_start.y;
			token_content = Runtime.rs.substr(content.ref, pos, sz);
			if (token_content == token)
			{
				find = true;
			}
			var res = this.next(parser, token_content, x, y, pos);
			x = Runtime.rtl.attr(res, 0);
			y = Runtime.rtl.attr(res, 1);
			pos = Runtime.rtl.attr(res, 2);
			caret_end = new BayLang.Caret(Runtime.Map.from({"pos":pos,"x":x,"y":y}));
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserEOF)
			{
				var e = _ex;
				
				if (caret_start == null)
				{
					caret_start = parser.caret;
				}
				if (caret_end == null)
				{
					caret_end = caret_start;
				}
				eof = true;
			}
			else if (true)
			{
				var e = _ex;
				
				throw e
			}
			else
			{
				throw _ex;
			}
		}
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"caret":caret_end})),new BayLang.CoreToken(Runtime.Map.from({"content":token_content,"caret_start":caret_start,"caret_end":caret_end,"eof":eof})),find]);
	},
	/**
	 * Match next token
	 */
	matchToken: function(parser, next_token)
	{
		var token = null;
		/* Look token */
		var res = this.lookToken(parser, next_token);
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var find = Runtime.rtl.attr(res, 2);
		if (!find)
		{
			throw new BayLang.Exceptions.ParserExpected(next_token, token.caret_start, parser.file_name)
		}
		return Runtime.Vector.from([parser,token]);
	},
	/**
	 * Match next string
	 */
	matchString: function(parser, str1)
	{
		var caret = parser.caret;
		var sz = Runtime.rs.strlen(str1);
		var str2 = Runtime.rs.substr(parser.content.ref, caret.pos, sz);
		if (str1 != str2)
		{
			throw new BayLang.Exceptions.ParserExpected(str1, caret, parser.file_name)
		}
		var res = this.next(parser, str1, caret.x, caret.y, caret.pos);
		caret = new BayLang.Caret(Runtime.Map.from({"x":Runtime.rtl.attr(res, 0),"y":Runtime.rtl.attr(res, 1),"pos":Runtime.rtl.attr(res, 2)}));
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read number
	 */
	readNumber: function(parser, flag_negative)
	{
		if (flag_negative == undefined) flag_negative = false;
		var token = null;
		var start = parser;
		/* Read token */
		var res = this.readToken(parser);
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (token.content == "")
		{
			throw new BayLang.Exceptions.ParserExpected("Number", caret_start, parser.file_name)
		}
		if (!this.isStringOfNumbers(token.content))
		{
			throw new BayLang.Exceptions.ParserExpected("Number", caret_start, parser.file_name)
		}
		var value = token.content;
		/* Look dot */
		var res = this.readToken(parser);
		var look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == ".")
		{
			value += Runtime.rtl.toStr(".");
			var res = this.readToken(look);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			value += Runtime.rtl.toStr(token.content);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpNumber(Runtime.Map.from({"value":value,"caret_start":caret_start,"caret_end":parser.caret,"negative":flag_negative}))]);
	},
	/**
	 * Read string
	 */
	readUntilStringArr: function(parser, arr, flag_include)
	{
		if (flag_include == undefined) flag_include = true;
		var token = null;
		var look = null;
		var content = parser.content;
		var content_sz = parser.content_sz;
		var pos = parser.caret.pos;
		var x = parser.caret.x;
		var y = parser.caret.y;
		/* Search next string in arr */
		var search = (pos) =>
		{
			for (var i = 0; i < arr.count(); i++)
			{
				var item = arr.item(i);
				var sz = Runtime.rs.strlen(item);
				var str = Runtime.rs.substr(content.ref, pos, sz);
				if (str == item)
				{
					return i;
				}
			}
			return -1;
		};
		/* Start and end positionss */
		var start_pos = pos;
		var end_pos = pos;
		/* Read string value */
		var ch = "";
		var arr_pos = search(pos);
		while (pos < content_sz && arr_pos == -1)
		{
			ch = Runtime.rs.charAt(content.ref, pos);
			x = this.nextX(parser, ch, x);
			y = this.nextY(parser, ch, y);
			pos = pos + 1;
			if (pos >= content_sz)
			{
				throw new BayLang.Exceptions.ParserExpected(Runtime.rs.join(",", arr), new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), parser.file_name)
			}
			arr_pos = search(pos);
		}
		if (arr_pos == -1)
		{
			throw new BayLang.Exceptions.ParserExpected("End of string", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), parser.file_name)
		}
		if (!flag_include)
		{
			end_pos = pos;
		}
		else
		{
			var item = arr.item(arr_pos);
			var sz = Runtime.rs.strlen(item);
			for (var i = 0; i < sz; i++)
			{
				ch = Runtime.rs.charAt(content.ref, pos);
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
			}
			end_pos = pos;
		}
		/* Return result */
		var caret_end = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":end_pos}));
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"caret":caret_end})),Runtime.rs.substr(content.ref, start_pos, end_pos - start_pos)]);
	},
	/**
	 * Read string
	 */
	readString: function(parser)
	{
		var token = null;
		var look = null;
		/* Read token */
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var str_char = token.content;
		/* Read begin string char */
		if (str_char != "'" && str_char != "\"")
		{
			throw new BayLang.Exceptions.ParserExpected("String", caret_start, parser.file_name)
		}
		var content = look.content;
		var content_sz = look.content_sz;
		var pos = look.caret.pos;
		var x = look.caret.x;
		var y = look.caret.y;
		/* Read string value */
		var value_str = "";
		var ch = Runtime.rs.charAt(content.ref, pos);
		while (pos < content_sz && ch != str_char)
		{
			if (ch == "\\")
			{
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= content_sz)
				{
					throw new BayLang.Exceptions.ParserExpected("End of string", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), parser.file_name)
				}
				var ch2 = Runtime.rs.charAt(content.ref, pos);
				if (ch2 == "n")
				{
					value_str += Runtime.rtl.toStr("\n");
				}
				else if (ch2 == "r")
				{
					value_str += Runtime.rtl.toStr("\r");
				}
				else if (ch2 == "t")
				{
					value_str += Runtime.rtl.toStr("\t");
				}
				else if (ch2 == "s")
				{
					value_str += Runtime.rtl.toStr(" ");
				}
				else if (ch2 == "\\")
				{
					value_str += Runtime.rtl.toStr("\\");
				}
				else if (ch2 == "'")
				{
					value_str += Runtime.rtl.toStr("'");
				}
				else if (ch2 == "\"")
				{
					value_str += Runtime.rtl.toStr("\"");
				}
				else
				{
					value_str += Runtime.rtl.toStr(ch + Runtime.rtl.toStr(ch2));
				}
				x = this.nextX(parser, ch2, x);
				y = this.nextY(parser, ch2, y);
				pos = pos + 1;
			}
			else
			{
				value_str += Runtime.rtl.toStr(ch);
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
			}
			if (pos >= content_sz)
			{
				throw new BayLang.Exceptions.ParserExpected("End of string", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), parser.file_name)
			}
			ch = Runtime.rs.charAt(content.ref, pos);
		}
		/* Read end string char */
		if (ch != "'" && ch != "\"")
		{
			throw new BayLang.Exceptions.ParserExpected("End of string", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), parser.file_name)
		}
		x = this.nextX(parser, ch, x);
		y = this.nextY(parser, ch, y);
		pos = pos + 1;
		/* Return result */
		var caret_end = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"caret":caret_end})),new BayLang.OpCodes.OpString(Runtime.Map.from({"value":value_str,"caret_start":caret_start,"caret_end":caret_end}))]);
	},
	/**
	 * Read comment
	 */
	readComment: function(parser)
	{
		var start = parser;
		var token = null;
		var look = null;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = BayLang.LangBay.ParserBayBase.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		if (token.content == "/")
		{
			parser = look;
			var content = look.content;
			var content_sz = look.content_sz;
			var pos = look.caret.pos;
			var x = look.caret.x;
			var y = look.caret.y;
			var pos_start = pos;
			var ch = Runtime.rs.charAt(content.ref, pos);
			var ch2 = Runtime.rs.substr(content.ref, pos, 2);
			while (!this.isCommentClose(parser, ch2) && pos < content_sz)
			{
				x = this.nextX(parser, ch, x);
				y = this.nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= parser.content_sz)
				{
					break;
				}
				ch = Runtime.rs.charAt(content.ref, pos);
				ch2 = Runtime.rs.substr(content.ref, pos, 2);
			}
			var pos_end = pos;
			if (this.isCommentClose(parser, ch2))
			{
				x = x + 2;
				pos = pos + 2;
			}
			else
			{
				throw new BayLang.Exceptions.ParserExpected("End of comment", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), start.file_name)
			}
			/* Return result */
			var value_str = Runtime.rs.substr(content.ref, pos_start + 1, pos_end - pos_start - 1);
			var caret_end = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
			return Runtime.Vector.from([start.copy(Runtime.Map.from({"caret":caret_end})),new BayLang.OpCodes.OpComment(Runtime.Map.from({"value":value_str,"caret_start":caret_start,"caret_end":caret_end}))]);
		}
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read identifier
	 */
	readIdentifier: function(parser, find_ident)
	{
		if (find_ident == undefined) find_ident = false;
		var start = parser;
		var token = null;
		var look = null;
		var name = "";
		var res = BayLang.LangBay.ParserBayBase.readToken(parser);
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "")
		{
			throw new BayLang.Exceptions.ParserExpected("Identifier", token.caret_start, parser.file_name)
		}
		if (!this.isIdentifier(token.content))
		{
			throw new BayLang.Exceptions.ParserExpected("Identifier", token.caret_start, parser.file_name)
		}
		if (this.isReserved(token.content))
		{
			throw new BayLang.Exceptions.ParserExpected("Identifier " + Runtime.rtl.toStr(token.content) + Runtime.rtl.toStr(" is reserverd"), token.caret_start, parser.file_name)
		}
		name = token.content;
		var kind = this.findIdentifier(parser, name, token.caret_start);
		if (parser.find_ident && find_ident && kind == "")
		{
			throw new BayLang.Exceptions.ParserError("Unknown identifier '" + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("'"), token.caret_start, parser.file_name)
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":kind,"value":name,"caret_start":token.caret_start,"caret_end":token.caret_end}))]);
	},
	/**
	 * Read entity name
	 */
	readEntityName: function(parser, find_ident)
	{
		if (find_ident == undefined) find_ident = true;
		var look = null;
		var token = null;
		var ident = null;
		var names = new Runtime.Vector();
		var res = parser.parser_base.constructor.readIdentifier(parser, find_ident);
		parser = Runtime.rtl.attr(res, 0);
		ident = Runtime.rtl.attr(res, 1);
		var caret_start = ident.caret_start;
		var name = ident.value;
		names.push(name);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content == ".")
		{
			var res = parser.parser_base.constructor.matchToken(parser, ".");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			ident = Runtime.rtl.attr(res, 1);
			name = ident.value;
			names.push(name);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"names":names}))]);
	},
	/**
	 * Read type identifier
	 */
	readTypeIdentifier: function(parser, find_ident)
	{
		if (find_ident == undefined) find_ident = true;
		var start = parser;
		var look = null;
		var token = null;
		var op_code = null;
		var entity_name = null;
		var template = null;
		var res = this.readEntityName(parser, find_ident);
		parser = Runtime.rtl.attr(res, 0);
		entity_name = Runtime.rtl.attr(res, 1);
		var caret_start = entity_name.caret_start;
		var flag_open_caret = false;
		var flag_end_caret = false;
		var res = this.lookToken(parser, "<");
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		flag_open_caret = Runtime.rtl.attr(res, 2);
		if (flag_open_caret)
		{
			template = new Runtime.Vector();
			var res = this.matchToken(parser, "<");
			parser = Runtime.rtl.attr(res, 0);
			var res = this.lookToken(parser, ">");
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			flag_end_caret = Runtime.rtl.attr(res, 2);
			while (!token.eof && !flag_end_caret)
			{
				var parser_value = null;
				var res = this.readTypeIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
				parser_value = Runtime.rtl.attr(res, 1);
				template.push(parser_value);
				var res = this.lookToken(parser, ">");
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				flag_end_caret = Runtime.rtl.attr(res, 2);
				if (!flag_end_caret)
				{
					var res = this.matchToken(parser, ",");
					parser = Runtime.rtl.attr(res, 0);
					var res = this.lookToken(parser, ">");
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
					flag_end_caret = Runtime.rtl.attr(res, 2);
				}
			}
			var res = this.matchToken(parser, ">");
			parser = Runtime.rtl.attr(res, 0);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":entity_name,"template":template,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read collection
	 */
	readCollection: function(parser)
	{
		var start = parser;
		var look = null;
		var token = null;
		var values = new Runtime.Vector();
		var ifdef_condition = null;
		var flag_ifdef = false;
		var res = this.matchToken(parser, "[");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content != "]")
		{
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "#ifdef")
			{
				parser = look;
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				ifdef_condition = Runtime.rtl.attr(res, 1);
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
				var res = parser.parser_base.constructor.matchToken(parser, "then");
				parser = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				flag_ifdef = true;
			}
			var parser_value = null;
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ",")
			{
				parser = look;
				var res = this.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
			}
			if (flag_ifdef)
			{
				parser_value = new BayLang.OpCodes.OpPreprocessorIfDef(Runtime.Map.from({"items":parser_value,"condition":ifdef_condition}));
			}
			values.push(parser_value);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		var res = this.matchToken(parser, "]");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpCollection(Runtime.Map.from({"values":values,"caret_start":caret_start,"caret_end":token.caret_end}))]);
	},
	/**
	 * Read collection
	 */
	readDict: function(parser)
	{
		var look = null;
		var token = null;
		var values = new Runtime.Vector();
		var ifdef_condition = null;
		var flag_ifdef = false;
		var res = this.matchToken(parser, "{");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content != "}")
		{
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "#ifdef")
			{
				parser = look;
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				ifdef_condition = Runtime.rtl.attr(res, 1);
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
				var res = parser.parser_base.constructor.matchToken(parser, "then");
				parser = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				flag_ifdef = true;
			}
			var parser_value = null;
			var res = this.readString(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			var key = parser_value.value;
			var res = this.matchToken(parser, ":");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ",")
			{
				parser = look;
			}
			values.push(new BayLang.OpCodes.OpDictPair(Runtime.Map.from({"key":key,"value":parser_value,"condition":ifdef_condition})));
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		var res = this.matchToken(parser, "}");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpDict(Runtime.Map.from({"values":values,"caret_start":caret_start,"caret_end":token.caret_end}))]);
	},
	/**
	 * Read fixed
	 */
	readFixed: function(parser)
	{
		var look = null;
		var token = null;
		var start = parser;
		var caret_start = parser.caret;
		var flag_negative = false;
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "")
		{
			throw new BayLang.Exceptions.ParserExpected("Identifier", token.caret_start, look.file_name)
		}
		/* Read string */
		if (token.content == "'" || token.content == "\"")
		{
			return this.readString(parser);
		}
		/* Read Collection */
		if (token.content == "[")
		{
			return this.readCollection(parser);
		}
		/* Read Dict */
		if (token.content == "{")
		{
			return this.readDict(parser);
		}
		/* Negative number */
		if (token.content == "-")
		{
			flag_negative = true;
			parser = look;
			var res = this.readToken(look);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		/* Read Number */
		if (this.isStringOfNumbers(token.content))
		{
			return this.readNumber(parser, flag_negative);
		}
		return this.readIdentifier(parser, true);
	},
	/**
	 * Read call args
	 */
	readCallArgs: function(parser)
	{
		var look = null;
		var token = null;
		var items = new Runtime.Vector();
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "{")
		{
			var res = this.readDict(parser);
			parser = Runtime.rtl.attr(res, 0);
			var d = Runtime.rtl.attr(res, 1);
			items = Runtime.Vector.from([d]);
		}
		else if (token.content == "(")
		{
			var res = this.matchToken(parser, "(");
			parser = Runtime.rtl.attr(res, 0);
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			while (!token.eof && token.content != ")")
			{
				var parser_value = null;
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				parser_value = Runtime.rtl.attr(res, 1);
				items.push(parser_value);
				var res = this.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content == ",")
				{
					parser = look;
					var res = this.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
				}
			}
			var res = this.matchToken(parser, ")");
			parser = Runtime.rtl.attr(res, 0);
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Read new instance
	 */
	readNew: function(parser, match_new)
	{
		if (match_new == undefined) match_new = true;
		var look = null;
		var token = null;
		var op_code = null;
		var caret_start = parser.caret;
		var args = Runtime.Vector.from([]);
		if (match_new)
		{
			var res = this.matchToken(parser, "new");
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			caret_start = token.caret_start;
		}
		var res = this.readTypeIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var res = this.readToken(parser);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "(" || token.content == "{")
		{
			var res = this.readCallArgs(parser);
			parser = Runtime.rtl.attr(res, 0);
			args = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpNew(Runtime.Map.from({"args":args,"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read method
	 */
	readMethod: function(parser, match)
	{
		if (match == undefined) match = true;
		var look = null;
		var token = null;
		var parser_value = null;
		var op_code = null;
		var value1 = "";
		var value2 = "";
		var kind = "";
		var caret_start = parser.caret;
		if (match)
		{
			var res = this.matchToken(parser, "method");
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		var save = parser;
		/* Read static method */
		try
		{
			var res = this.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			var res = this.matchToken(parser, "::");
			parser = Runtime.rtl.attr(res, 0);
			var res = this.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_VARIABLE)
			{
				kind = BayLang.OpCodes.OpMethod.KIND_STATIC;
			}
			else
			{
				kind = BayLang.OpCodes.OpMethod.KIND_CLASS;
			}
			value1 = op_code;
			value2 = token.content;
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserError)
			{
				var e = _ex;
			}
			else
			{
				throw _ex;
			}
		}
		/* Read instance method */
		if (kind == "")
		{
			parser = save;
			try
			{
				var res = this.readIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				var res = this.matchToken(parser, ".");
				parser = Runtime.rtl.attr(res, 0);
				var res = this.readToken(parser);
				parser = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				kind = BayLang.OpCodes.OpMethod.KIND_ATTR;
				value1 = op_code;
				value2 = token.content;
			}
			catch (_ex)
			{
				if (_ex instanceof BayLang.Exceptions.ParserError)
				{
					var e = _ex;
				}
				else
				{
					throw _ex;
				}
			}
		}
		/* Error */
		if (kind == "")
		{
			throw new BayLang.Exceptions.ParserExpected("'.' or '::'", parser.caret, parser.file_name)
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpMethod(Runtime.Map.from({"value1":value1,"value2":value2,"kind":kind,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read curry
	 */
	readCurry: function(parser)
	{
		var look = null;
		var token = null;
		var obj = null;
		var args = new Runtime.Vector();
		var res = this.matchToken(parser, "curry");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = this.readDynamic(parser, 14);
		parser = Runtime.rtl.attr(res, 0);
		obj = Runtime.rtl.attr(res, 1);
		var res = this.matchToken(parser, "(");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content != ")")
		{
			var arg = null;
			if (token.content == "?")
			{
				var pos = 0;
				parser = look;
				var res = this.readToken(look);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (this.isStringOfNumbers(token.content))
				{
					pos = Runtime.rtl.to(token.content, {"e":"int"});
					parser = look;
				}
				arg = new BayLang.OpCodes.OpCurryArg(Runtime.Map.from({"pos":pos}));
				args.push(arg);
			}
			else
			{
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				arg = Runtime.rtl.attr(res, 1);
				args.push(arg);
			}
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ",")
			{
				parser = look;
				var res = this.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
			}
		}
		var res = this.matchToken(parser, ")");
		parser = Runtime.rtl.attr(res, 0);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpCurry(Runtime.Map.from({"obj":obj,"args":args}))]);
	},
	/**
	 * Read base item
	 */
	readBaseItem: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = look.caret;
		if (token.content == "new")
		{
			var res = this.readNew(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else if (token.content == "method")
		{
			var res = this.readMethod(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else if (token.content == "classof")
		{
			var res = this.readClassOf(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else if (token.content == "classref")
		{
			var res = this.readClassRef(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else if (token.content == "(")
		{
			var save_parser = parser;
			parser = look;
			/* Try to read OpTypeConvert */
			try
			{
				var res = this.readTypeIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
				var op_type = Runtime.rtl.attr(res, 1);
				var res = this.readToken(parser);
				parser = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content == ")")
				{
					var res = this.readDynamic(parser);
					parser = Runtime.rtl.attr(res, 0);
					op_code = Runtime.rtl.attr(res, 1);
					return Runtime.Vector.from([parser,new BayLang.OpCodes.OpTypeConvert(Runtime.Map.from({"pattern":op_type,"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
				}
			}
			catch (_ex)
			{
				if (_ex instanceof BayLang.Exceptions.ParserError)
				{
					var e = _ex;
				}
				else
				{
					throw _ex;
				}
			}
			/* Read Expression */
			var res = this.matchToken(save_parser, "(");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			var res = this.matchToken(parser, ")");
			parser = Runtime.rtl.attr(res, 0);
		}
		else
		{
			var res = this.readFixed(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read classof
	 */
	readClassOf: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var res = this.matchToken(parser, "classof");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = this.readEntityName(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpClassOf(Runtime.Map.from({"entity_name":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read classref
	 */
	readClassRef: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var res = this.matchToken(parser, "classref");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpClassRef(Runtime.Map.from({"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read dynamic
	 */
	readDynamic: function(parser, dynamic_flags)
	{
		if (dynamic_flags == undefined) dynamic_flags = -1;
		var look = null;
		var token = null;
		var parser_items = null;
		var op_code = null;
		var op_code_first = null;
		var is_await = false;
		var is_context_call = true;
		var caret_start = null;
		/* Dynamic flags */
		var flag_call = 1;
		var flag_attr = 2;
		var flag_static = 4;
		var flag_dynamic = 8;
		var f_next = (s) =>
		{
			if ((dynamic_flags & 1) == 1)
			{
				if (s == "{" || s == "(" || s == "@")
				{
					return true;
				}
			}
			if ((dynamic_flags & 2) == 2)
			{
				if (s == ".")
				{
					return true;
				}
			}
			if ((dynamic_flags & 4) == 4)
			{
				if (s == "::")
				{
					return true;
				}
			}
			if ((dynamic_flags & 8) == 8)
			{
				if (s == "[")
				{
					return true;
				}
			}
			return false;
		};
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "await")
		{
			caret_start = token.caret_start;
			is_await = true;
			parser = look;
		}
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "@")
		{
			var res = this.readToken(look);
			var look2 = Runtime.rtl.attr(res, 0);
			var token2 = Runtime.rtl.attr(res, 1);
			if (!f_next(token2.content))
			{
				if (this.isIdentifier(token2.content))
				{
					parser = look;
					is_context_call = false;
				}
			}
		}
		var res = this.readBaseItem(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		op_code_first = op_code;
		if (caret_start == null)
		{
			caret_start = op_code.caret_start;
		}
		if (op_code instanceof BayLang.OpCodes.OpIdentifier && (op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_CONTEXT || op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_FUNCTION))
		{
			is_context_call = false;
		}
		var res = this.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (f_next(token.content))
		{
			if (op_code instanceof BayLang.OpCodes.OpIdentifier)
			{
				if (parser.find_ident && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_SYS_FUNCTION && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_VARIABLE && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_CLASS && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_CLASSREF && op_code.kind != BayLang.OpCodes.OpIdentifier.KIND_CONTEXT)
				{
					throw new BayLang.Exceptions.ParserExpected("Module or variable '" + Runtime.rtl.toStr(op_code.value) + Runtime.rtl.toStr("'"), op_code.caret_start, parser.file_name)
				}
			}
			else if (op_code instanceof BayLang.OpCodes.OpNew || op_code instanceof BayLang.OpCodes.OpCollection || op_code instanceof BayLang.OpCodes.OpDict)
			{
			}
			else
			{
				throw new BayLang.Exceptions.ParserExpected("Module or variable", op_code.caret_start, parser.file_name)
			}
		}
		/* If is pipe */
		if (parser.is_pipe && op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			op_code = new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":parser.pipe_kind,"obj":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":BayLang.OpCodes.OpIdentifier.KIND_PIPE,"caret_start":op_code.caret_start,"caret_end":op_code.caret_end})),"value":op_code,"caret_start":op_code.caret_start,"caret_end":op_code.caret_end}));
		}
		while (!token.eof && f_next(token.content))
		{
			var token_content = token.content;
			/* Static call */
			if (token_content == "(" || token_content == "{" || token_content == "@")
			{
				if ((dynamic_flags & flag_call) != flag_call)
				{
					throw new BayLang.Exceptions.ParserError("Call are not allowed", token.caret_start, parser.file_name)
				}
				if (token_content == "@")
				{
					parser = look;
					is_context_call = false;
				}
				var res = this.readCallArgs(parser);
				parser = Runtime.rtl.attr(res, 0);
				parser_items = Runtime.rtl.attr(res, 1);
				op_code = new BayLang.OpCodes.OpCall(Runtime.Map.from({"obj":op_code,"args":parser_items,"caret_start":caret_start,"caret_end":parser.caret,"is_await":is_await,"is_context":is_context_call}));
				is_context_call = true;
			}
			else if (token_content == "." || token_content == "::" || token_content == "[")
			{
				var kind = "";
				var look_values = null;
				var look_value = null;
				parser = look;
				is_context_call = true;
				if (token_content == ".")
				{
					kind = BayLang.OpCodes.OpAttr.KIND_ATTR;
					if ((dynamic_flags & flag_attr) != flag_attr)
					{
						throw new BayLang.Exceptions.ParserError("Attr are not allowed", token.caret_start, parser.file_name)
					}
				}
				else if (token_content == "::")
				{
					kind = BayLang.OpCodes.OpAttr.KIND_STATIC;
					if ((dynamic_flags & flag_static) != flag_static)
					{
						throw new BayLang.Exceptions.ParserError("Static attr are not allowed", token.caret_start, parser.file_name)
					}
				}
				else if (token_content == "[")
				{
					kind = BayLang.OpCodes.OpAttr.KIND_DYNAMIC;
					if ((dynamic_flags & flag_dynamic) != flag_dynamic)
					{
						throw new BayLang.Exceptions.ParserError("Dynamic attr are not allowed", token.caret_start, parser.file_name)
					}
				}
				if (token_content == "[")
				{
					var res = parser.parser_expression.constructor.readExpression(parser);
					parser = Runtime.rtl.attr(res, 0);
					look_value = Runtime.rtl.attr(res, 1);
					var res = this.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
					if (token.content == ",")
					{
						look_values = new Runtime.Vector();
						look_values.push(look_value);
					}
					while (token.content == ",")
					{
						parser = look;
						var res = parser.parser_expression.constructor.readExpression(parser);
						parser = Runtime.rtl.attr(res, 0);
						look_value = Runtime.rtl.attr(res, 1);
						look_values.push(look_value);
						var res = this.readToken(parser);
						look = Runtime.rtl.attr(res, 0);
						token = Runtime.rtl.attr(res, 1);
					}
					var res = this.matchToken(parser, "]");
					parser = Runtime.rtl.attr(res, 0);
					if (look_values != null)
					{
						kind = BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS;
					}
				}
				else
				{
					var res = this.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
					if (token.content == "@")
					{
						parser = look;
						is_context_call = false;
					}
					var res = this.readIdentifier(parser);
					parser = Runtime.rtl.attr(res, 0);
					look_value = Runtime.rtl.attr(res, 1);
				}
				op_code = new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":kind,"obj":op_code,"attrs":(look_values != null) ? (look_values) : (null),"value":(look_values == null) ? (look_value) : (null),"caret_start":caret_start,"caret_end":parser.caret}));
			}
			else
			{
				throw new BayLang.Exceptions.ParserExpected("Next attr", token.caret_start, parser.file_name)
			}
			var res = this.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (op_code instanceof BayLang.OpCodes.OpAttr && op_code.kind == BayLang.OpCodes.OpAttr.KIND_PIPE && token.content != "(" && token.content != "{")
			{
				throw new BayLang.Exceptions.ParserExpected("Call", token.caret_start, parser.file_name)
			}
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayBase";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayBase);
window["BayLang.LangBay.ParserBayBase"] = BayLang.LangBay.ParserBayBase;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayBase;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayExpression = function()
{
};
Object.assign(BayLang.LangBay.ParserBayExpression.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayExpression,
{
	/**
	 * Read negative
	 */
	readNegative: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (token.content == "-")
		{
			var op_code = null;
			var res = parser.parser_base.constructor.readDynamic(look);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([parser,new BayLang.OpCodes.OpNegative(Runtime.Map.from({"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
		}
		return parser.parser_base.constructor.readDynamic(parser);
	},
	/**
	 * Read bit not
	 */
	readBitNot: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (token.content == "!")
		{
			var op_code = null;
			var res = this.readNegative(look);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([parser,new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"math":"!","caret_start":caret_start,"caret_end":parser.caret}))]);
		}
		return this.readNegative(parser);
	},
	/**
	 * Read bit shift
	 */
	readBitShift: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readBitNot(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == ">>" || token.content == "<<"))
		{
			math = token.content;
			var res = this.readBitNot(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read bit and
	 */
	readBitAnd: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readBitShift(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content == "&")
		{
			math = token.content;
			var res = this.readBitShift(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read bit or
	 */
	readBitOr: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readBitAnd(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == "|" || token.content == "xor"))
		{
			math = token.content;
			var res = this.readBitAnd(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read factor
	 */
	readFactor: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readBitOr(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == "*" || token.content == "/" || token.content == "%" || token.content == "div" || token.content == "mod"))
		{
			math = token.content;
			var res = this.readBitOr(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read arithmetic
	 */
	readArithmetic: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readFactor(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == "+" || token.content == "-"))
		{
			math = token.content;
			var res = this.readFactor(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read concat
	 */
	readConcat: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readArithmetic(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content == "~")
		{
			math = token.content;
			var res = this.readArithmetic(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read compare
	 */
	readCompare: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readConcat(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var content = token.content;
		if (content == "===" || content == "!==" || content == "==" || content == "!=" || content == ">=" || content == "<=" || content == ">" || content == "<")
		{
			var math = token.content;
			var res = this.readConcat(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":parser.caret}));
			parser = look;
		}
		else if (content == "is" || content == "implements" || content == "instanceof")
		{
			var math = token.content;
			var res = parser.parser_base.constructor.readTypeIdentifier(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":math,"caret_start":caret_start,"caret_end":parser.caret}));
			parser = look;
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read not
	 */
	readNot: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (token.content == "not")
		{
			var op_code = null;
			var start = parser;
			var res = this.readCompare(look);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([parser,new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"math":"not","caret_start":caret_start,"caret_end":parser.caret}))]);
		}
		return this.readCompare(parser);
	},
	/**
	 * Read and
	 */
	readAnd: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readNot(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == "and" || token.content == "&&"))
		{
			math = token.content;
			var res = this.readNot(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":"and","caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read or
	 */
	readOr: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var look_value = null;
		var res = this.readAnd(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var math = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (token.content == "or" || token.content == "||"))
		{
			math = token.content;
			var res = this.readAnd(look);
			look = Runtime.rtl.attr(res, 0);
			look_value = Runtime.rtl.attr(res, 1);
			op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"value1":op_code,"value2":look_value,"math":"or","caret_start":caret_start,"caret_end":look.caret}));
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read element
	 */
	readElement: function(parser)
	{
		/* Try to read function */
		if (parser.parser_operator.constructor.tryReadFunction(parser, false))
		{
			return parser.parser_operator.constructor.readDeclareFunction(parser, false);
		}
		return this.readOr(parser);
	},
	/**
	 * Read ternary operation
	 */
	readTernary: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var condition = null;
		var if_true = null;
		var if_false = null;
		var res = this.readElement(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "?")
		{
			condition = op_code;
			var res = this.readExpression(look);
			parser = Runtime.rtl.attr(res, 0);
			if_true = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ":")
			{
				var res = this.readExpression(look);
				parser = Runtime.rtl.attr(res, 0);
				if_false = Runtime.rtl.attr(res, 1);
			}
			op_code = new BayLang.OpCodes.OpTernary(Runtime.Map.from({"condition":condition,"if_true":if_true,"if_false":if_false,"caret_start":caret_start,"caret_end":parser.caret}));
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read pipe
	 */
	ExpressionPipe: function(parser)
	{
		var look = null;
		var look_token = null;
		var op_code = null;
		var is_next_attr = false;
		var save_is_pipe = parser.is_pipe;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_pipe"]), false);
		var res = this.readTernary(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_pipe"]), save_is_pipe);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		look_token = Runtime.rtl.attr(res, 1);
		if (look_token.content == "|>")
		{
			while (look_token.content == "|>" || look_token.content == ",")
			{
				parser = look;
				var value = null;
				var kind = "";
				var is_async = false;
				var is_monad = false;
				if (look_token.content == ",")
				{
					is_next_attr = true;
				}
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				look_token = Runtime.rtl.attr(res, 1);
				if (look_token.content == "await")
				{
					is_async = true;
					parser = look;
					var res = parser.parser_base.constructor.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					look_token = Runtime.rtl.attr(res, 1);
				}
				if (look_token.content == "monad")
				{
					is_monad = true;
					parser = look;
					var res = parser.parser_base.constructor.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					look_token = Runtime.rtl.attr(res, 1);
				}
				if (look_token.content == "attr")
				{
					parser = look;
					var res = this.readTernary(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
					kind = BayLang.OpCodes.OpPipe.KIND_ATTR;
				}
				else if (look_token.content == "\"" || look_token.content == "'")
				{
					var res = this.readTernary(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
					kind = BayLang.OpCodes.OpPipe.KIND_ATTR;
				}
				else if (look_token.content == "{")
				{
					parser = look;
					var res = this.readTernary(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
					kind = BayLang.OpCodes.OpPipe.KIND_ATTR;
					var res = parser.parser_base.constructor.matchToken(parser, "}");
					parser = Runtime.rtl.attr(res, 0);
				}
				else if (is_next_attr)
				{
					throw new BayLang.Exceptions.ParserExpected("|>", parser.caret, parser.file_name)
				}
				else if (look_token.content == "default")
				{
					var arg1;
					var arg2;
					kind = BayLang.OpCodes.OpPipe.KIND_CALL;
					is_monad = true;
					try
					{
						var res = parser.parser_base.constructor.readIdentifier(look);
						parser = Runtime.rtl.attr(res, 0);
						arg1 = Runtime.rtl.attr(res, 1);
						var res = this.readTernary(parser);
						parser = Runtime.rtl.attr(res, 0);
						arg2 = Runtime.rtl.attr(res, 1);
						arg1 = new BayLang.OpCodes.OpString(Runtime.Map.from({"value":parser.constructor.findModuleName(parser, arg1.value),"caret_start":arg1.caret_start,"caret_end":arg1.caret_end}));
						value = new BayLang.OpCodes.OpCall(Runtime.Map.from({"args":Runtime.Vector.from([arg1,arg2]),"obj":new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":BayLang.OpCodes.OpAttr.KIND_STATIC,"obj":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE,"caret_start":caret_start,"caret_end":parser.caret,"value":"rtl"})),"value":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"value":"m_to"})),"caret_start":caret_start,"caret_end":parser.caret})),"caret_start":caret_start,"caret_end":parser.caret}));
					}
					catch (_ex)
					{
						if (_ex instanceof BayLang.Exceptions.ParserError)
						{
							var err = _ex;
							
							value = null;
						}
						else
						{
							throw _ex;
						}
					}
					if (value == null)
					{
						var res = this.readTernary(look);
						parser = Runtime.rtl.attr(res, 0);
						arg2 = Runtime.rtl.attr(res, 1);
						value = new BayLang.OpCodes.OpCall(Runtime.Map.from({"args":Runtime.Vector.from([arg2]),"obj":new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":BayLang.OpCodes.OpAttr.KIND_STATIC,"obj":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE,"caret_start":caret_start,"caret_end":parser.caret,"value":"rtl"})),"value":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"value":"m_def"})),"caret_start":caret_start,"caret_end":parser.caret})),"caret_start":caret_start,"caret_end":parser.caret}));
					}
				}
				else if (look_token.content == "method" || look_token.content == "." || look_token.content == ":" || look_token.content == "::")
				{
					parser = look;
					kind = BayLang.OpCodes.OpPipe.KIND_CALL;
					/* Set pipe */
					var save_find_ident = parser.find_ident;
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_pipe"]), true);
					if (look_token.content == ".")
					{
						kind = BayLang.OpCodes.OpPipe.KIND_METHOD;
						parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["pipe_kind"]), BayLang.OpCodes.OpAttr.KIND_ATTR);
					}
					else
					{
						parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["pipe_kind"]), BayLang.OpCodes.OpAttr.KIND_STATIC);
					}
					var res = parser.parser_base.constructor.readDynamic(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
					/* Restore parser */
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_pipe"]), false);
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), save_find_ident);
				}
				else if (look_token.content == "curry")
				{
					kind = BayLang.OpCodes.OpPipe.KIND_CALL;
					var res = parser.parser_base.constructor.readCurry(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
				}
				else
				{
					kind = BayLang.OpCodes.OpPipe.KIND_CALL;
					var res = parser.parser_base.constructor.readDynamic(parser);
					parser = Runtime.rtl.attr(res, 0);
					value = Runtime.rtl.attr(res, 1);
				}
				op_code = new BayLang.OpCodes.OpPipe(Runtime.Map.from({"obj":op_code,"kind":kind,"value":value,"is_async":is_async,"is_monad":is_monad,"caret_start":caret_start,"caret_end":parser.caret}));
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				look_token = Runtime.rtl.attr(res, 1);
				is_next_attr = false;
			}
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read expression
	 */
	readExpression: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "<")
		{
			return parser.parser_html.constructor.readHTML(parser);
		}
		else if (token.content == "curry")
		{
			return parser.parser_base.constructor.readCurry(parser);
		}
		else if (token.content == "@css")
		{
			return parser.parser_html.constructor.readCss(parser);
		}
		return this.ExpressionPipe(parser);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayExpression";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayExpression);
window["BayLang.LangBay.ParserBayExpression"] = BayLang.LangBay.ParserBayExpression;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayExpression;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayHtml = function()
{
	Runtime.BaseObject.apply(this, arguments);
};
BayLang.LangBay.ParserBayHtml.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.ParserBayHtml.prototype.constructor = BayLang.LangBay.ParserBayHtml;
Object.assign(BayLang.LangBay.ParserBayHtml.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayHtml, Runtime.BaseObject);
Object.assign(BayLang.LangBay.ParserBayHtml,
{
	/**
	 * Hash function
	 * @param string
	 * @return int hash
	 */
	hash: function(s, last, x, p)
	{
		if (last == undefined) last = true;
		if (x == undefined) x = 257;
		if (p == undefined) p = 1000000007;
		var h = 0;
		var sz = Runtime.rs.strlen(s);
		for (var i = 0; i < sz; i++)
		{
			var ch = Runtime.rs.ord(Runtime.rs.substr(s, i, 1));
			h = (h * x + ch) % p;
		}
		if (last)
		{
			h = h * x % p;
		}
		return h;
	},
	/**
	 * Convert int to hex
	 * @param int
	 * @return string
	 */
	toHex: function(h)
	{
		var r = "";
		var a = "0123456789abcdef";
		while (h >= 0)
		{
			var c = h & 15;
			h = h >> 4;
			r = Runtime.rs.substr(a, c, 1) + Runtime.rtl.toStr(r);
			if (h == 0)
			{
				break;
			}
		}
		return r;
	},
	/**
	 * Retuns css hash
	 * @param string component class name
	 * @return string hash
	 */
	getCssHash: function(s)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangBay.ParserBayHtml.getCssHash", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		var h = this.hash(s, true, 337, 65537) + 65537;
		var res = this.toHex(h);
		var __memorize_value = Runtime.rs.substr(res, -4);
		Runtime.rtl._memorizeSave("BayLang.LangBay.ParserBayHtml.getCssHash", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * Read css component name
	 */
	readCssComponentName: function(parser)
	{
		var flag = false;
		var class_name = "";
		/* Get caret */
		var caret = parser.getCaret();
		/* Read char */
		var ch = caret.nextChar();
		if (ch == "(")
		{
			flag = true;
			/* Read ( */
			caret.readChar();
			/* Next char */
			ch = caret.nextChar();
			/* Read class name */
			var start_pos = caret.pos;
			while (!caret.eof() && ch != ")")
			{
				caret.readChar();
				ch = caret.nextChar();
			}
			class_name = caret.getString(start_pos, caret.pos - start_pos);
			/* Recognize class name */
			if (parser.uses.has(class_name))
			{
				class_name = parser.uses.item(class_name);
			}
			/* Read ) */
			caret.matchChar(")");
		}
		parser = parser.copy(Runtime.Map.from({"caret":caret}));
		return Runtime.Vector.from([parser,class_name,flag]);
	},
	/**
	 * Read css class name
	 */
	readCssClassName: function(parser, default_component_name)
	{
		if (default_component_name == undefined) default_component_name = true;
		/* Get caret */
		var caret = parser.getCaret();
		/* Component name */
		var use_component_name = default_component_name;
		var component_name = parser.current_namespace_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(parser.current_class_name);
		/* Read start selector */
		var start_ch = caret.nextChar();
		if (start_ch == "." || start_ch == "%")
		{
			caret.readChar();
		}
		else if (start_ch == "&")
		{
			caret.readChar();
			use_component_name = false;
		}
		else if (start_ch == "#" || start_ch == ":")
		{
			caret.readChar();
			if (start_ch == ":")
			{
				use_component_name = false;
			}
		}
		else if (start_ch == "*")
		{
			caret.readChar();
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			return Runtime.Vector.from([parser,"*"]);
		}
		else
		{
			start_ch = "";
			use_component_name = false;
		}
		/* Save caret */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		/* Read class name */
		if (start_ch == "%")
		{
			start_ch = ".";
			var res = this.readCssComponentName(parser);
			parser = Runtime.rtl.attr(res, 0);
			if (Runtime.rtl.attr(res, 2) != "")
			{
				component_name = Runtime.rtl.attr(res, 1);
				use_component_name = true;
			}
		}
		/* Start position */
		caret = parser.getCaret();
		var start_pos = caret.pos;
		/* Read selector */
		var ch = caret.nextChar();
		while (!caret.eof() && ch != " " && ch != "," && ch != ":" && ch != "[" && ch != "{")
		{
			caret.readChar();
			ch = caret.nextChar();
		}
		var postfix = caret.getString(start_pos, caret.pos - start_pos);
		postfix = Runtime.rs.trim(postfix);
		/* Read suffix */
		var start_pos = caret.pos;
		while (!caret.eof() && ch != " " && ch != "," && ch != "." && ch != "{")
		{
			caret.readChar();
			ch = caret.nextChar();
		}
		var suffix = caret.getString(start_pos, caret.pos - start_pos);
		suffix = Runtime.rs.trim(suffix);
		var class_name = start_ch + Runtime.rtl.toStr(postfix) + Runtime.rtl.toStr(((use_component_name) ? (".h-" + Runtime.rtl.toStr(this.getCssHash(component_name))) : (""))) + Runtime.rtl.toStr(suffix);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		return Runtime.Vector.from([parser,class_name]);
	},
	/**
	 * Read css selector
	 */
	readCssSelector: function(parser, default_component_name)
	{
		if (default_component_name == undefined) default_component_name = true;
		/* Get caret */
		var caret = parser.getCaret();
		var selectors = new Runtime.Vector();
		while (!caret.eof())
		{
			var res = this.readCssClassName(parser, default_component_name);
			parser = Runtime.rtl.attr(res, 0);
			var selector = Runtime.rtl.attr(res, 1);
			default_component_name = false;
			selectors.push(selector);
			/* Skip empty chars */
			var caret = parser.parser_base.constructor.skipChar(parser, parser.content, parser.caret);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			/* Get caret */
			caret = parser.caret.clone(Runtime.Map.from({"file_name":parser.file_name,"content":parser.content,"content_sz":parser.content_sz}));
			var ch = caret.nextChar();
			if (ch == "{" || ch == "}" || ch == "<" || ch == ",")
			{
				break;
			}
		}
		var selector = Runtime.rs.join(" ", selectors);
		return Runtime.Vector.from([parser,selector]);
	},
	/**
	 * Concat op_code_item with selector
	 */
	readCssBodyConcatItem: function(caret_start, caret_end, selector, op_code_item)
	{
		if (op_code_item instanceof BayLang.OpCodes.OpString)
		{
			op_code_item = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":caret_end,"value":op_code_item.value + Runtime.rtl.toStr("}")}));
		}
		else
		{
			op_code_item = new BayLang.OpCodes.OpMath(Runtime.Map.from({"caret_start":caret_start,"caret_end":caret_end,"value1":op_code_item,"value2":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":"}"})),"math":"~"}));
		}
		if (op_code_item instanceof BayLang.OpCodes.OpString)
		{
			op_code_item = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":caret_end,"value":selector + Runtime.rtl.toStr("{") + Runtime.rtl.toStr(op_code_item.value)}));
		}
		else
		{
			op_code_item = new BayLang.OpCodes.OpMath(Runtime.Map.from({"caret_start":caret_start,"caret_end":caret_end,"value1":new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":caret_end,"value":selector + Runtime.rtl.toStr("{")})),"value2":op_code_item,"math":"~"}));
		}
		return op_code_item;
	},
	/**
	 * Returns true if next string is css selector
	 */
	isNextSelector: function(caret)
	{
		caret = caret.clone();
		var ch = caret.nextChar();
		if (ch == "@" || ch == "%" || ch == "&" || ch == "." || ch == ":" || ch == "#" || ch == "*")
		{
			return true;
		}
		if (!caret.constructor.isChar(ch))
		{
			return false;
		}
		while (!caret.eof() && ch != "{" && ch != "}" && ch != "<")
		{
			if (ch == ";" || ch == "(" || ch == ")" || ch == "$")
			{
				return false;
			}
			caret.nextChar();
			ch = caret.readChar();
		}
		if (ch == "{")
		{
			return true;
		}
		return false;
	},
	/**
	 * Split selector by dot
	 */
	splitSelector: function(selector)
	{
		var arr1 = Runtime.rs.split(" ", selector);
		var prefix = Runtime.rs.join(" ", arr1.slice(0, -1));
		if (prefix != "")
		{
			prefix = prefix + Runtime.rtl.toStr(" ");
		}
		var arr2 = Runtime.rs.split(".", arr1.last());
		var first = "";
		var second = "";
		if (arr2.get(0) == "")
		{
			first = "." + Runtime.rtl.toStr(arr2.get(1));
			second = Runtime.rs.join(".", arr2.slice(2));
		}
		else
		{
			first = arr2.get(0);
			second = Runtime.rs.join(".", arr2.slice(1));
		}
		if (second != "")
		{
			second = "." + Runtime.rtl.toStr(second);
		}
		return Runtime.Vector.from([prefix + Runtime.rtl.toStr(first),second]);
	},
	/**
	 * Concat selectors
	 */
	concatSelectors: function(prev_selector, selector)
	{
		if (prev_selector == "")
		{
			return selector;
		}
		/* If first symbol is & */
		if (Runtime.rs.charAt(selector, 0) == "&")
		{
			var res = this.splitSelector(prev_selector);
			return res.get(0) + Runtime.rtl.toStr(Runtime.rs.substr(selector, 1)) + Runtime.rtl.toStr(res.get(1));
		}
		return prev_selector + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(selector);
	},
	/**
	 * Get selectors from collection
	 */
	getSelectors: function(start_selectors)
	{
		var result = Runtime.Vector.from([""]);
		for (var i = 0; i < start_selectors.count(); i++)
		{
			var prev_result = result;
			result = Runtime.Vector.from([]);
			var items = start_selectors.get(i);
			for (var j = 0; j < prev_result.count(); j++)
			{
				var prev_selector = prev_result.get(j);
				for (var k = 0; k < items.count(); k++)
				{
					var selector = items.get(k);
					result.push(this.concatSelectors(prev_selector, selector));
				}
			}
		}
		return result;
	},
	/**
	 * Read css body
	 */
	readCssBodyItems: function(parser, items, start_selectors, end_tag, default_component_name)
	{
		var css_content = Runtime.Vector.from([]);
		var sub_items = Runtime.Vector.from([]);
		/* Get caret */
		var caret_start = parser.getCaret();
		/* Skip empty chars */
		var caret = parser.parser_base.constructor.skipChar(parser, parser.content, parser.caret);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		caret = parser.getCaret();
		var op_code = null;
		while (!caret.eof() && caret.nextChar() != end_tag && caret.nextChar() != "}")
		{
			var op_code_item = null;
			/* Read media css */
			if (caret.isNextString("@media"))
			{
				/* Read selector */
				var arr = new Runtime.Vector();
				var ch = caret.nextChar();
				while (!caret.eof() && ch != "{")
				{
					if (ch != "\t" && ch != "\n")
					{
						arr.push(ch);
					}
					caret.readChar();
					ch = caret.nextChar();
				}
				var media_selector = Runtime.rs.trim(Runtime.rs.join("", arr));
				/* Setup caret */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				var caret_start_item2 = parser.getCaret();
				/* Read body */
				var new_items = new Runtime.Vector();
				var res = parser.parser_base.constructor.matchToken(parser, "{");
				parser = Runtime.rtl.attr(res, 0);
				parser = this.readCssBodyItems(parser, new_items, start_selectors, "}", default_component_name);
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
				/* Items */
				for (var i = 0; i < new_items.count(); i++)
				{
					var item = new_items.get(i);
					item = this.readCssBodyConcatItem(item.caret_start, item.caret_end, media_selector, item);
					items.push(item);
				}
				/* Get caret */
				caret = parser.getCaret();
			}
			else if (this.isNextSelector(caret))
			{
				var selectors = Runtime.Vector.from([]);
				/* Read css selector */
				while (this.isNextSelector(caret))
				{
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
					var res = this.readCssSelector(parser, default_component_name);
					parser = Runtime.rtl.attr(res, 0);
					selectors.push(Runtime.rtl.attr(res, 1));
					caret = parser.getCaret();
					if (caret.isNextChar(","))
					{
						caret.readChar();
						caret.skipSpace();
					}
				}
				/* Setup caret */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				var caret_start_item2 = parser.getCaret();
				/* Read body */
				var res = parser.parser_base.constructor.matchToken(parser, "{");
				parser = Runtime.rtl.attr(res, 0);
				parser = this.readCssBodyItems(parser, sub_items, start_selectors.pushIm(selectors), "}", default_component_name);
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
				/* Get caret */
				caret = parser.getCaret();
			}
			else
			{
				var arr = new Runtime.Vector();
				var ch = caret.nextChar();
				var ch2 = caret.nextString(2);
				while (!caret.eof() && ch != "}" && ch != ";")
				{
					if (ch2 == "${")
					{
						/* Save caret */
						caret.matchString("${");
						parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
						/* Read expression */
						var res = parser.parser_expression.constructor.readExpression(parser);
						parser = Runtime.rtl.attr(res, 0);
						/* Append to css content */
						if (arr.count() != 0)
						{
							css_content.push(Runtime.rs.join("", arr));
						}
						css_content.push(Runtime.rtl.attr(res, 1));
						arr = Runtime.Vector.from([]);
						/* Restore caret */
						caret = parser.getCaret();
						caret.skipSpace();
						caret.matchChar("}");
					}
					else
					{
						if (ch != "\t" && ch != "\n")
						{
							arr.push(ch);
						}
						caret.readChar();
					}
					ch = caret.nextChar();
					ch2 = caret.nextString(2);
				}
				/* Skip semicolon */
				if (caret.skipChar(";"))
				{
					arr.push(";");
				}
				var s = Runtime.rs.trim(Runtime.rs.join("", arr));
				css_content.push(s);
				/* Setup caret */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			}
			/* Skip empty chars */
			caret = parser.parser_base.constructor.skipChar(parser, parser.content, caret);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			caret = parser.getCaret();
		}
		/* Add CSS content to items */
		if (css_content.count() > 0)
		{
			/* Filter css content */
			css_content = css_content.filter((item) =>
			{
				return item != "";
			});
			/* Remove last semicolon */
			if (css_content.count() > 0 && Runtime.rtl.isString(css_content.last()))
			{
				var item = css_content.last();
				if (Runtime.rs.substr(item, -1) == ";")
				{
					item = Runtime.rs.substr(item, 0, -1);
				}
				css_content.set(css_content.count() - 1, item);
			}
			/* Extend op code */
			var extendItem = (op_code_item, arr) =>
			{
				if (arr.count() > 0)
				{
					var css_str_op_code = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.getCaret(),"value":Runtime.rs.join("", arr)}));
					if (op_code_item != null)
					{
						op_code_item = new BayLang.OpCodes.OpMath(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.getCaret(),"value1":op_code_item,"value2":css_str_op_code,"math":"~"}));
					}
					else
					{
						op_code_item = css_str_op_code;
					}
				}
				return op_code_item;
			};
			/* Init arr */
			var arr = new Runtime.Vector();
			var selectors = this.getSelectors(start_selectors);
			arr.push(Runtime.rs.join(",", selectors) + Runtime.rtl.toStr("{"));
			/* Build op_code_item */
			var op_code_item = null;
			for (var i = 0; i < css_content.count(); i++)
			{
				var item = css_content.get(i);
				if (Runtime.rtl.isString(item))
				{
					arr.push(item);
				}
				else
				{
					op_code_item = extendItem(op_code_item, arr);
					if (op_code_item != null)
					{
						op_code_item = new BayLang.OpCodes.OpMath(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.getCaret(),"value1":op_code_item,"value2":item,"math":"~"}));
					}
					else
					{
						op_code_item = item;
					}
					arr = Runtime.Vector.from([]);
				}
			}
			/* Add close bracket */
			arr.push("}");
			/* Extend op_code */
			op_code_item = extendItem(op_code_item, arr);
			/* Append op_code */
			items.push(op_code_item);
		}
		/* Add sub items */
		items.appendItems(sub_items);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		return parser;
	},
	/**
	 * Read css body
	 */
	readCssBody: function(parser, end_tag, default_component_name)
	{
		if (end_tag == undefined) end_tag = "}";
		if (default_component_name == undefined) default_component_name = true;
		/* Get caret */
		var caret_start = parser.getCaret();
		var op_code = null;
		var items = new Runtime.Vector();
		/* Read items */
		parser = this.readCssBodyItems(parser, items, Runtime.Vector.from([]), end_tag, default_component_name);
		for (var i = 0; i < items.count(); i++)
		{
			var op_code_item = items.get(i);
			if (op_code == null)
			{
				op_code = op_code_item;
			}
			else
			{
				if (op_code instanceof BayLang.OpCodes.OpString && op_code_item instanceof BayLang.OpCodes.OpString)
				{
					op_code = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":op_code.caret_start,"caret_end":op_code_item.caret_end,"value":op_code.value + Runtime.rtl.toStr(op_code_item.value)}));
				}
				else
				{
					op_code = new BayLang.OpCodes.OpMath(Runtime.Map.from({"caret_start":op_code.caret_start,"caret_end":op_code_item.caret_end,"value1":op_code,"value2":op_code_item,"math":"~"}));
				}
			}
		}
		if (op_code == null)
		{
			op_code = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"value":""}));
		}
		op_code = Runtime.rtl.setAttr(op_code, Runtime.Collection.from(["caret_start"]), caret_start);
		op_code = Runtime.rtl.setAttr(op_code, Runtime.Collection.from(["caret_end"]), parser.caret);
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read css
	 */
	readCss: function(parser)
	{
		var caret_start = parser.caret;
		var res = parser.parser_base.constructor.matchToken(parser, "@css");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "{");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readCssBody(parser);
		parser = Runtime.rtl.attr(res, 0);
		var op_code = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, "}");
		parser = Runtime.rtl.attr(res, 0);
		if (op_code == null)
		{
			op_code = new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"value":""}));
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read style
	 */
	readStyle: function(parser, item_attrs, items, caret_start)
	{
		/* Save vars */
		var save_vars = parser.vars;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm("vars", true));
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_local_css"]), true);
		/* Check if local css */
		var is_global = item_attrs.get("global", "");
		if (is_global == "true")
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_local_css"]), false);
		}
		/* Read css */
		var res = this.readCssBody(parser, "<", parser.is_local_css);
		parser = Runtime.rtl.attr(res, 0);
		var css_op_code = Runtime.rtl.attr(res, 1);
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		/* Read style footer */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "/");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "style");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		/* Get style content */
		var start_pos = css_op_code.caret_start.pos;
		var end_pos = css_op_code.caret_end.pos;
		var style_content = Runtime.rs.trim(Runtime.rs.substr(parser.content.ref, start_pos, end_pos - start_pos));
		/* Create op code */
		var op_code = new BayLang.OpCodes.OpHtmlStyle(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"content":style_content,"is_global":is_global,"value":css_op_code}));
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read html comment
	 */
	readHTMLComment: function(parser)
	{
		var start = parser;
		var token = null;
		var look = null;
		var caret_start = parser.caret;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "!--");
		parser = Runtime.rtl.attr(res, 0);
		var content = parser.content;
		var content_sz = parser.content_sz;
		var pos = parser.caret.pos;
		var x = parser.caret.x;
		var y = parser.caret.y;
		var pos_start = pos;
		var ch = Runtime.rs.charAt(content.ref, pos);
		var ch3 = Runtime.rs.substr(content.ref, pos, 3);
		while (ch3 != "-->" && pos < content_sz)
		{
			x = parser.parser_base.constructor.nextX(parser, ch, x);
			y = parser.parser_base.constructor.nextY(parser, ch, y);
			pos = pos + 1;
			if (pos >= parser.content_sz)
			{
				break;
			}
			ch = Runtime.rs.charAt(content.ref, pos);
			ch3 = Runtime.rs.substr(content.ref, pos, 3);
		}
		var pos_end = pos;
		if (ch3 == "-->")
		{
			x = x + 3;
			pos = pos + 3;
		}
		else
		{
			throw new BayLang.Exceptions.ParserExpected("End of comment", new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos})), start.file_name)
		}
		/* Return result */
		var value_str = Runtime.rs.substr(content.ref, pos_start, pos_end - pos_start);
		var caret_end = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		return Runtime.Vector.from([start.copy(Runtime.Map.from({"caret":caret_end})),new BayLang.OpCodes.OpComment(Runtime.Map.from({"value":value_str,"caret_start":caret_start,"caret_end":caret_end}))]);
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read html value
	 */
	readHTMLValue: function(parser)
	{
		var item = null;
		var caret = parser.caret;
		var content = parser.content;
		var pos = parser.caret.pos;
		var x = parser.caret.x;
		var y = parser.caret.y;
		var ch = Runtime.rs.substr(content.ref, pos, 1);
		var ch2 = Runtime.rs.substr(content.ref, pos, 2);
		if (ch == "<")
		{
			var res = this.readHTMLTag(parser);
			parser = Runtime.rtl.attr(res, 0);
			item = Runtime.rtl.attr(res, 1);
		}
		else if (ch == "{")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "{");
			parser = Runtime.rtl.attr(res, 0);
			/* Look token */
			var flag = false;
			var res = parser.parser_base.constructor.readToken(parser);
			var look = Runtime.rtl.attr(res, 0);
			var token = Runtime.rtl.attr(res, 1);
			if (token.content == "{")
			{
				flag = true;
				parser = look;
			}
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			item = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "}");
			parser = Runtime.rtl.attr(res, 0);
			if (flag)
			{
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
			}
		}
		else if (ch == "@")
		{
			x = parser.parser_base.constructor.nextX(parser, ch, x);
			y = parser.parser_base.constructor.nextY(parser, ch, y);
			pos = pos + 1;
			var ch3 = Runtime.rs.substr(content.ref, pos, 3);
			var ch4 = Runtime.rs.substr(content.ref, pos, 4);
			if (ch3 == "raw" || ch4 == "json" || ch4 == "html")
			{
				var res;
				if (ch3 == "raw")
				{
					res = parser.parser_base.constructor.next(parser, ch3, x, y, pos);
				}
				if (ch4 == "json")
				{
					res = parser.parser_base.constructor.next(parser, ch4, x, y, pos);
				}
				if (ch4 == "html")
				{
					res = parser.parser_base.constructor.next(parser, ch4, x, y, pos);
				}
				x = Runtime.rtl.attr(res, 0);
				y = Runtime.rtl.attr(res, 1);
				pos = Runtime.rtl.attr(res, 2);
			}
			caret = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			var res = parser.parser_base.constructor.matchToken(parser, "{");
			parser = Runtime.rtl.attr(res, 0);
			/* Look bracket */
			var res = parser.parser_base.constructor.lookToken(parser, "{");
			var look = Runtime.rtl.attr(res, 0);
			var find_bracket = Runtime.rtl.attr(res, 2);
			if (find_bracket)
			{
				parser = look;
			}
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			item = Runtime.rtl.attr(res, 1);
			if (ch3 == "raw")
			{
				item = new BayLang.OpCodes.OpHtmlValue(Runtime.Map.from({"kind":BayLang.OpCodes.OpHtmlValue.KIND_RAW,"value":item,"caret_start":caret,"caret_end":parser.caret}));
			}
			else if (ch4 == "json")
			{
				item = new BayLang.OpCodes.OpHtmlValue(Runtime.Map.from({"kind":BayLang.OpCodes.OpHtmlValue.KIND_JSON,"value":item,"caret_start":caret,"caret_end":parser.caret}));
			}
			else if (ch4 == "html")
			{
				item = new BayLang.OpCodes.OpHtmlValue(Runtime.Map.from({"kind":BayLang.OpCodes.OpHtmlValue.KIND_HTML,"value":item,"caret_start":caret,"caret_end":parser.caret}));
			}
			var res = parser.parser_base.constructor.matchToken(parser, "}");
			parser = Runtime.rtl.attr(res, 0);
			if (find_bracket)
			{
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
			}
		}
		return Runtime.Vector.from([parser,item]);
	},
	/**
	 * Read html attribute key
	 */
	readHTMLAttrKey: function(parser)
	{
		var token = null;
		var look = null;
		var ident = null;
		var key = "";
		/* Look token */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "@")
		{
			parser = look;
			key = "@";
		}
		var res = parser.parser_base.constructor.readIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		ident = Runtime.rtl.attr(res, 1);
		key += Runtime.rtl.toStr(ident.value);
		/* Read attr */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (token.content == "-")
		{
			var res = parser.parser_base.constructor.readIdentifier(look);
			parser = Runtime.rtl.attr(res, 0);
			ident = Runtime.rtl.attr(res, 1);
			key += Runtime.rtl.toStr("-" + Runtime.rtl.toStr(ident.value));
			/* Look next token */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		/* Look token */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == ":")
		{
			parser = look;
			key += Runtime.rtl.toStr(":");
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			ident = Runtime.rtl.attr(res, 1);
			key += Runtime.rtl.toStr(ident.value);
		}
		return Runtime.Vector.from([parser,key]);
	},
	/**
	 * Read html attribute value
	 */
	readHTMLAttrValue: function(parser, attr_key)
	{
		var token = null;
		var look = null;
		var op_code = null;
		var ident = null;
		var pos = parser.caret.pos;
		var content = parser.content;
		var ch = Runtime.rs.substr(content.ref, pos, 1);
		var ch2 = Runtime.rs.substr(content.ref, pos, 2);
		/* Look token */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (Runtime.rs.substr(attr_key, 0, 7) == "@event:")
		{
			/* Look token */
			var res = parser.parser_base.constructor.lookToken(parser, "{");
			var look = Runtime.rtl.attr(res, 0);
			var token = Runtime.rtl.attr(res, 1);
			var is_fn = Runtime.rtl.attr(res, 2);
			if (is_fn)
			{
				var res = parser.parser_base.constructor.matchToken(parser, "{");
				parser = Runtime.rtl.attr(res, 0);
				/* Look token */
				var res = parser.parser_base.constructor.lookToken(parser, "{");
				var look = Runtime.rtl.attr(res, 0);
				var token = Runtime.rtl.attr(res, 1);
				var find = Runtime.rtl.attr(res, 2);
				if (find)
				{
					parser = look;
				}
				/* Add msg to vars */
				var parser_vars = parser.vars;
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.concat(Runtime.Map.from({"component":true,"msg":true})));
				/* Read expression */
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				/* Restore vars */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser_vars);
				/* Parse brackets */
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
				if (find)
				{
					var res = parser.parser_base.constructor.matchToken(parser, "}");
					parser = Runtime.rtl.attr(res, 0);
				}
			}
			else
			{
				var res = parser.parser_base.constructor.readString(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
			}
		}
		else if (ch == "{")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "{");
			parser = Runtime.rtl.attr(res, 0);
			/* Look token */
			var res = parser.parser_base.constructor.lookToken(parser, "{");
			var look = Runtime.rtl.attr(res, 0);
			var token = Runtime.rtl.attr(res, 1);
			var find = Runtime.rtl.attr(res, 2);
			if (find)
			{
				parser = look;
			}
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "}");
			parser = Runtime.rtl.attr(res, 0);
			if (find)
			{
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
			}
		}
		else if (token.content == "@")
		{
			var res = this.readHTMLValue(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else if (token.content == "[")
		{
			var res = parser.parser_base.constructor.readCollection(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		else
		{
			var res = parser.parser_base.constructor.readString(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read html attributes
	 */
	readHTMLAttrs: function(parser)
	{
		var items = new Runtime.Vector();
		var token = null;
		var look = null;
		var content = parser.content;
		var content_sz = parser.content_sz;
		var caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
		var ch = Runtime.rs.substr(content.ref, caret.pos, 1);
		while (ch != "/" && ch != ">" && caret.pos < content_sz)
		{
			var caret_start = caret;
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "...")
			{
				var ident = null;
				var res = parser.parser_base.constructor.matchToken(parser, "...");
				parser = Runtime.rtl.attr(res, 0);
				var res = parser.parser_base.constructor.readIdentifier(look);
				parser = Runtime.rtl.attr(res, 0);
				ident = Runtime.rtl.attr(res, 1);
				items.push(new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"value":ident,"is_spread":true,"caret_start":caret_start,"caret_end":parser.caret})));
			}
			else
			{
				var res = this.readHTMLAttrKey(parser);
				parser = Runtime.rtl.attr(res, 0);
				var key = Runtime.rtl.attr(res, 1);
				var res = parser.parser_base.constructor.matchToken(parser, "=");
				parser = Runtime.rtl.attr(res, 0);
				var res = this.readHTMLAttrValue(parser, key);
				parser = Runtime.rtl.attr(res, 0);
				var value = Runtime.rtl.attr(res, 1);
				items.push(new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":key,"value":value,"caret_start":caret_start,"caret_end":parser.caret})));
			}
			caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
			ch = Runtime.rs.substr(content.ref, caret.pos, 1);
			var ch2 = Runtime.rs.substr(content.ref, caret.pos, 2);
			if (ch2 == "/>")
			{
				break;
			}
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Read html template
	 */
	readHTMLContent: function(parser, end_tag)
	{
		var items = new Runtime.Vector();
		var item = null;
		var token = null;
		var look = null;
		var caret = null;
		var caret_start = parser.caret;
		var content = parser.content;
		var content_sz = parser.content_sz;
		var pos = parser.caret.pos;
		var x = parser.caret.x;
		var y = parser.caret.y;
		var start_pos = pos;
		var end_tag_sz = Runtime.rs.strlen(end_tag);
		var ch_pos = Runtime.rs.substr(content.ref, pos, end_tag_sz);
		var flag_first = true;
		var first_html_tag = false;
		if (end_tag == "")
		{
			first_html_tag = true;
		}
		while ((end_tag == "" || end_tag != "" && ch_pos != end_tag) && pos < content_sz)
		{
			var ch = Runtime.rs.substr(content.ref, pos, 1);
			var ch2 = Runtime.rs.substr(content.ref, pos, 2);
			var ch3 = Runtime.rs.substr(content.ref, pos, 3);
			var ch4 = Runtime.rs.substr(content.ref, pos, 4);
			var ch6 = Runtime.rs.substr(content.ref, pos, 6);
			var ch7 = Runtime.rs.substr(content.ref, pos, 7);
			/* Html comment */
			if (ch4 == "<!--")
			{
				var value = Runtime.rs.substr(content.ref, start_pos, pos - start_pos);
				caret = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
				value = Runtime.rs.trim(value, "\t\r\n");
				value = Runtime.rs.trim(value, " ");
				if (value != "")
				{
					item = new BayLang.OpCodes.OpHtmlContent(Runtime.Map.from({"value":value,"caret_start":caret_start,"caret_end":caret}));
					items.push(item);
				}
				/* Read HTML Comment */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				var res = this.readHTMLComment(parser);
				parser = Runtime.rtl.attr(res, 0);
				items.push(Runtime.rtl.attr(res, 1));
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else if (ch == "<" || ch2 == "{{" || ch == "@")
			{
				var value = Runtime.rs.substr(content.ref, start_pos, pos - start_pos);
				caret = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
				value = Runtime.rs.trim(value, "\t\r\n");
				if (flag_first && first_html_tag)
				{
					value = Runtime.rs.trim(value, " ");
				}
				if (value != "")
				{
					item = new BayLang.OpCodes.OpHtmlContent(Runtime.Map.from({"value":value,"caret_start":caret_start,"caret_end":caret}));
					items.push(item);
				}
				/* Read HTML Value */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				var res = this.readHTMLValue(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				items.push(item);
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else if (ch3 == "%if" || ch4 == "%for" || ch4 == "%var" || ch4 == "%set" || ch6 == "%while" || ch7 == "%render")
			{
				var value = Runtime.rs.substr(content.ref, start_pos, pos - start_pos);
				caret = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
				value = Runtime.rs.trim(value, "\t\r\n");
				value = Runtime.rs.trim(value, " ");
				if (value != "")
				{
					item = new BayLang.OpCodes.OpHtmlContent(Runtime.Map.from({"value":value,"caret_start":caret_start,"caret_end":caret}));
					items.push(item);
				}
				/* Read HTML Operator */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				var res = this.readHTMLOperator(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				items.push(item);
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else
			{
				if (first_html_tag && ch != " " && ch != "\t" && ch != "\r" && ch != "\n")
				{
					break;
				}
				x = parser.parser_base.constructor.nextX(parser, ch, x);
				y = parser.parser_base.constructor.nextY(parser, ch, y);
				pos = pos + 1;
			}
			ch_pos = Runtime.rs.substr(content.ref, pos, end_tag_sz);
		}
		/* Push item */
		var value = Runtime.rs.substr(content.ref, start_pos, pos - start_pos);
		value = Runtime.rs.trim(value, "\t\r\n");
		caret = new BayLang.Caret(Runtime.Map.from({"x":x,"y":y,"pos":pos}));
		if (first_html_tag)
		{
			value = Runtime.rs.trim(value, " ");
		}
		if (value != "")
		{
			item = new BayLang.OpCodes.OpHtmlContent(Runtime.Map.from({"value":value,"caret_start":caret_start,"caret_end":caret}));
			items.push(item);
		}
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"caret":caret})),items]);
	},
	/**
	 * Read html tag
	 */
	readHTMLTag: function(parser)
	{
		var token = null;
		var look = null;
		var ident = null;
		var caret_items_start = null;
		var caret_items_end = null;
		var caret_start = parser.caret;
		var items = null;
		var op_code_name = null;
		var is_single_flag = false;
		var op_code_flag = false;
		var tag_name = "";
		/* Tag start */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		/* Look token */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "{")
		{
			op_code_flag = true;
			var caret1 = parser.caret;
			var res = parser.parser_base.constructor.matchToken(parser, "{");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code_name = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "}");
			parser = Runtime.rtl.attr(res, 0);
			var caret2 = parser.caret;
			tag_name = Runtime.rs.substr(parser.content.ref, caret1.pos, caret2.pos - caret1.pos);
		}
		else if (token.content == ">")
		{
			op_code_flag = true;
			tag_name = "";
		}
		else
		{
			var res = parser.parser_base.constructor.readIdentifier(parser, false);
			parser = Runtime.rtl.attr(res, 0);
			ident = Runtime.rtl.attr(res, 1);
			tag_name = ident.value;
		}
		var res = this.readHTMLAttrs(parser);
		parser = Runtime.rtl.attr(res, 0);
		var attrs = Runtime.rtl.attr(res, 1);
		/* Save vars */
		var save_vars = parser.vars;
		var slot_args = null;
		var slot_use = null;
		/* Read slot args */
		if (tag_name == "slot")
		{
			/* Slot args */
			var args_item = attrs.findItem(Runtime.lib.equalAttr("key", "args"));
			if (args_item)
			{
				var args_str = args_item.value.value;
				/* Create parser */
				var parser2 = new BayLang.LangBay.ParserBay();
				parser2 = parser2.constructor.reset(parser2);
				parser2 = parser2.constructor.setContent(parser2, args_str);
				parser2 = Runtime.rtl.setAttr(parser2, Runtime.Collection.from(["caret"]), new BayLang.Caret(Runtime.Map.from({})));
				/* Parse args */
				var res = parser2.parser_operator.constructor.readDeclareFunctionArgs(parser2, false, false);
				parser2 = Runtime.rtl.attr(res, 0);
				slot_args = Runtime.rtl.attr(res, 1);
				var parser2_vars = parser2.vars;
				/* Add slot args */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser2_vars);
			}
			/* Slot use */
			args_item = attrs.findItem(Runtime.lib.equalAttr("key", "use"));
			if (args_item)
			{
				var args_str = args_item.value.value;
				slot_use = new Runtime.Vector();
				/* Each items */
				var parser2_vars = Runtime.Map.from({});
				var items = Runtime.rs.split(",", args_str);
				for (var i = 0; i < items.count(); i++)
				{
					slot_use.push(new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"value":items.get(i),"kind":BayLang.OpCodes.OpIdentifier.KIND_VARIABLE})));
					parser2_vars.set(items.get(i), true);
				}
				/* Add slot args */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.concat(parser2_vars));
			}
		}
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "/")
		{
			parser = look;
			is_single_flag = true;
		}
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		if (!is_single_flag)
		{
			if (tag_name == "svg")
			{
				var res = parser.parser_base.constructor.readUntilStringArr(parser, Runtime.Vector.from(["</svg>"]), false);
				parser = Runtime.rtl.attr(res, 0);
				var content = Runtime.rtl.attr(res, 1);
				content = Runtime.re.replace("[\t\n]", "", content);
				var items = Runtime.Vector.from([new BayLang.OpCodes.OpHtmlValue(Runtime.Map.from({"kind":BayLang.OpCodes.OpHtmlValue.KIND_RAW,"value":new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":parser.caret,"caret_end":parser.caret,"value":content})),"caret_start":caret_start,"caret_end":parser.caret}))]);
			}
			else
			{
				/* Read items */
				caret_items_start = parser.caret;
				var res = this.readHTMLContent(parser, "</" + Runtime.rtl.toStr(tag_name));
				parser = Runtime.rtl.attr(res, 0);
				var items = Runtime.rtl.attr(res, 1);
				caret_items_end = parser.caret;
			}
			/* Tag end */
			if (op_code_flag)
			{
				var res = parser.parser_base.constructor.matchToken(parser, "<");
				parser = Runtime.rtl.attr(res, 0);
				var res = parser.parser_base.constructor.matchToken(parser, "/");
				parser = Runtime.rtl.attr(res, 0);
				if (tag_name)
				{
					var res = parser.parser_base.constructor.matchString(parser, tag_name);
					parser = Runtime.rtl.attr(res, 0);
				}
				var res = parser.parser_base.constructor.matchToken(parser, ">");
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				var res = parser.parser_base.constructor.matchToken(parser, "<");
				parser = Runtime.rtl.attr(res, 0);
				var res = parser.parser_base.constructor.matchToken(parser, "/");
				parser = Runtime.rtl.attr(res, 0);
				if (ident != null)
				{
					var res = parser.parser_base.constructor.matchToken(parser, tag_name);
					parser = Runtime.rtl.attr(res, 0);
				}
				var res = parser.parser_base.constructor.matchToken(parser, ">");
				parser = Runtime.rtl.attr(res, 0);
			}
		}
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		/* Create op_code */
		var op_code = null;
		if (tag_name == "slot")
		{
			var op_attr_name = attrs.findItem(Runtime.lib.equalAttr("key", "name"));
			/* Filter attrs */
			attrs = attrs.filter(Runtime.lib.equalAttrNot("key", "args"));
			attrs = attrs.filter(Runtime.lib.equalAttrNot("key", "name"));
			attrs = attrs.filter(Runtime.lib.equalAttrNot("key", "use"));
			var name = "";
			if (op_attr_name && op_attr_name.value instanceof BayLang.OpCodes.OpString)
			{
				name = op_attr_name.value.value;
			}
			op_code = new BayLang.OpCodes.OpHtmlSlot(Runtime.Map.from({"args":slot_args,"attrs":attrs,"name":name,"vars":slot_use,"caret_start":caret_start,"caret_end":parser.caret,"items":(items != null) ? (new BayLang.OpCodes.OpHtmlItems(Runtime.Map.from({"caret_start":caret_items_start,"caret_end":caret_items_end,"items":items}))) : (null)}));
		}
		else
		{
			op_code = new BayLang.OpCodes.OpHtmlTag(Runtime.Map.from({"attrs":attrs,"tag_name":tag_name,"op_code_name":op_code_name,"caret_start":caret_start,"caret_end":parser.caret,"items":(items != null) ? (new BayLang.OpCodes.OpHtmlItems(Runtime.Map.from({"caret_start":caret_items_start,"caret_end":caret_items_end,"items":items}))) : (null)}));
		}
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read html operator
	 */
	readHTMLOperator: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "%if")
		{
			return parser.parser_operator.constructor.readIf(parser);
		}
		else if (token.content == "%for")
		{
			return parser.parser_operator.constructor.readFor(parser);
		}
		else if (token.content == "%while")
		{
			return parser.parser_operator.constructor.readWhile(parser);
		}
		else if (token.content == "%var")
		{
			var op_code = null;
			var res = parser.parser_base.constructor.matchToken(parser, "%var");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_operator.constructor.readAssign(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, ";");
			parser = Runtime.rtl.attr(res, 0);
			return Runtime.Vector.from([parser,op_code]);
		}
		else if (token.content == "%set")
		{
			var op_code = null;
			var res = parser.parser_base.constructor.matchToken(parser, "%set");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_operator.constructor.readAssign(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, ";");
			parser = Runtime.rtl.attr(res, 0);
			return Runtime.Vector.from([parser,op_code]);
		}
		else if (token.content == "%render")
		{
			var op_code = null;
			var res = parser.parser_base.constructor.matchToken(parser, "%render");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readDynamic(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			if (op_code instanceof BayLang.OpCodes.OpCall)
			{
				op_code = Runtime.rtl.setAttr(op_code, Runtime.Collection.from(["is_html"]), true);
			}
			var res = parser.parser_base.constructor.matchToken(parser, ";");
			parser = Runtime.rtl.attr(res, 0);
			return Runtime.Vector.from([parser,op_code]);
		}
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read html operator
	 */
	readHTML: function(parser, end_tag)
	{
		if (end_tag == undefined) end_tag = "";
		var caret_start = parser.caret;
		/* Enable html flag */
		var save_is_html = parser.is_html;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_html"]), true);
		var res = this.readHTMLContent(parser, end_tag);
		parser = Runtime.rtl.attr(res, 0);
		var items = Runtime.rtl.attr(res, 1);
		var op_code = new BayLang.OpCodes.OpHtmlItems(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"items":items}));
		/* Disable html flag */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_html"]), save_is_html);
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read html operator
	 */
	readHTMLTemplate: function(parser, item_attrs, caret_start)
	{
		var fn_name = item_attrs.get("name", "render");
		var fn_args_str = item_attrs.get("args", "");
		var parser2_vars = Runtime.Map.from({});
		/*
		Collection<OpDeclareFunctionArg> fn_args =
		[
			new OpDeclareFunctionArg
			{
				"name": "component",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "layout",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "model_path",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "render_params",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "render_content",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
		];
		*/
		var fn_args = Runtime.Vector.from([]);
		if (item_attrs.has("args"))
		{
			var parser2 = parser.constructor.setContent(parser, fn_args_str);
			parser2 = Runtime.rtl.setAttr(parser2, Runtime.Collection.from(["caret"]), new BayLang.Caret(Runtime.Map.from({})));
			/* Parse args */
			var res = parser.parser_operator.constructor.readDeclareFunctionArgs(parser2, false, false);
			parser2 = Runtime.rtl.attr(res, 0);
			var fn_args2 = Runtime.rtl.attr(res, 1);
			parser2_vars = parser2.vars;
			fn_args = fn_args.concat(fn_args2);
		}
		/* If multiblock */
		var is_multiblock = false;
		if (item_attrs.has("multiblock"))
		{
			if (item_attrs.get("multiblock") == "true")
			{
				is_multiblock = true;
			}
			else if (item_attrs.get("multiblock") == "false")
			{
				is_multiblock = false;
			}
		}
		/* Register variable in parser */
		/*parser2_vars = parser2_vars
			.setIm("layout", true)
			.setIm("model", true)
			.setIm("model_path", true)
			.setIm("render_params", true)
			.setIm("render_content", true)
		;*/
		/* Read template content */
		var save_vars = parser.vars;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.concat(parser2_vars));
		var res = this.readHTML(parser, "</template");
		parser = Runtime.rtl.attr(res, 0);
		var expression = Runtime.rtl.attr(res, 1);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		/* Read template footer */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "/");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "template");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		var f = new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"args":fn_args,"vars":Runtime.Vector.from([]),"flags":new BayLang.OpCodes.OpFlags(Runtime.Map.from({"p_static":false,"p_pure":false,"p_multiblock":is_multiblock})),"name":fn_name,"result_type":"html","is_html":true,"expression":expression,"items":null,"caret_start":caret_start,"caret_end":parser.caret}));
		return Runtime.Vector.from([parser,f]);
	},
	/**
	 * Read html attributes
	 */
	readAttrs: function(parser)
	{
		var look = null;
		var op_code = null;
		var token = null;
		var look_token = null;
		var items = new Runtime.Map();
		var content = parser.content;
		var content_sz = parser.content_sz;
		var caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
		var ch = Runtime.rs.substr(content.ref, caret.pos, 1);
		while (ch != "/" && ch != ">" && caret.pos < content_sz)
		{
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "=");
			parser = Runtime.rtl.attr(res, 0);
			var attr_name = token.content;
			/* Look token */
			var res = parser.parser_base.constructor.readToken(parser);
			look_token = Runtime.rtl.attr(res, 1);
			if (look_token.content == "{")
			{
				var res = parser.parser_base.constructor.readDict(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				caret = parser.caret;
				items.set(attr_name, op_code);
			}
			else
			{
				var res = parser.parser_base.constructor.readString(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				items.set(attr_name, op_code.value);
			}
			caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
			ch = Runtime.rs.substr(content.ref, caret.pos, 1);
			var ch2 = Runtime.rs.substr(content.ref, caret.pos, 2);
			if (ch2 == "/>")
			{
				break;
			}
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Read item
	 */
	readWidget: function(parser)
	{
		var settings = new Runtime.Map();
		var items = new Runtime.Vector();
		/* Read item */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "widget");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		var token = null;
		var look = null;
		var caret = parser.getCaret();
		var caret_start = parser.getCaret();
		var end_tag = "</widget>";
		var end_tag_sz = Runtime.rs.strlen(end_tag);
		/* Skip empty chars */
		caret = parser.parser_base.constructor.skipChar(parser, parser.content, caret);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		/* Read next string */
		var caret = parser.getCaret();
		var next_tag = caret.nextString(end_tag_sz);
		while (next_tag != end_tag && !caret.eof())
		{
			/* Save caret */
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			var parser_item = parser;
			var res = parser.parser_base.constructor.matchToken(parser, "<");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			/* HTML Comment */
			if (token.content == "!--")
			{
				var res = this.readHTMLComment(parser_item);
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				var res = parser.parser_base.constructor.matchToken(parser, ">");
				parser = Runtime.rtl.attr(res, 0);
				var props_name = token.content;
				var props_value = "";
				/* Read widget */
				if (props_name == "widget")
				{
					var res = this.readWidget(parser_item);
					parser = Runtime.rtl.attr(res, 0);
					var item = Runtime.rtl.attr(res, 1);
					items.push(item);
				}
				else if (props_name == "style")
				{
					var res = this.readWidgetStyle(parser_item);
					parser = Runtime.rtl.attr(res, 0);
					var item = Runtime.rtl.attr(res, 1);
					items.push(item);
				}
				else
				{
					/* Get caret */
					var caret = parser.getCaret();
					/* Read content */
					var item_ch = caret.nextChar();
					while (item_ch != "<" && !caret.eof())
					{
						props_value += item_ch;
						caret.readChar();
						item_ch = caret.nextChar();
					}
					/* Save caret */
					parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
					settings.set(props_name, new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":caret,"caret_end":parser.caret,"value":props_value})));
					/* Read end tag */
					var res = parser.parser_base.constructor.matchToken(parser, "<");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, "/");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, props_name);
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, ">");
					parser = Runtime.rtl.attr(res, 0);
				}
			}
			/* Skip empty chars */
			caret = parser.parser_base.constructor.skipChar(parser, parser.content, parser.caret);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			/* Read next string */
			var caret = parser.getCaret();
			next_tag = caret.nextString(end_tag_sz);
		}
		/* Read item */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "/");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "widget");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		/* Create widget data */
		var op_code = new BayLang.OpCodes.OpWidget(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"items":items,"settings":settings}));
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read widget data
	 */
	readWidgetData: function(parser)
	{
		var token = null;
		var items = new Runtime.Vector();
		/* Read data */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "data");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		var caret = parser.getCaret();
		var caret_start = parser.getCaret();
		var end_tag = "</data>";
		var end_tag_sz = Runtime.rs.strlen(end_tag);
		/* Skip empty chars */
		caret = parser.parser_base.constructor.skipChar(parser, parser.content, caret);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		/* Read next string */
		var caret = parser.getCaret();
		var next_tag = caret.nextString(end_tag_sz);
		while (next_tag != end_tag && !caret.eof())
		{
			/* Save caret */
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			var parser_item = parser;
			var res = parser.parser_base.constructor.matchToken(parser, "<");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			/* HTML Comment */
			if (token.content == "!--")
			{
				var res = this.readHTMLComment(parser_item);
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				var res = parser.parser_base.constructor.matchToken(parser, ">");
				parser = Runtime.rtl.attr(res, 0);
				var item_name = token.content;
				/* Read widget */
				if (item_name == "widget")
				{
					var res = this.readWidget(parser_item);
					parser = Runtime.rtl.attr(res, 0);
					var item = Runtime.rtl.attr(res, 1);
					items.push(item);
				}
				else if (item_name == "class")
				{
					var res = this.readWidgetClass(parser_item);
					parser = Runtime.rtl.attr(res, 0);
					var item = Runtime.rtl.attr(res, 1);
					items.push(item);
				}
				else
				{
					throw new BayLang.Exceptions.ParserError("Unknown identifier '" + Runtime.rtl.toStr(item_name) + Runtime.rtl.toStr("'"), parser_item.caret, parser.file_name)
				}
			}
			/* Skip empty chars */
			caret = parser.parser_base.constructor.skipChar(parser, parser.content, parser.caret);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			/* Read next string */
			var caret = parser.getCaret();
			next_tag = caret.nextString(end_tag_sz);
		}
		/* Read data */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "/");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "data");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		/* Create widget data */
		var op_code = new BayLang.OpCodes.OpWidgetData(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"widget":items}));
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read UI
	 */
	readUIClass: function(parser)
	{
		var module_items = new Runtime.Vector();
		var items = new Runtime.Vector();
		var components = new Runtime.Vector();
		var class_caret_start = parser.caret;
		var token = null;
		var class_name = "";
		var class_extends = "";
		var class_version = "";
		var class_model = "";
		var item_name = "";
		var namespace_name = "";
		var short_name = "";
		var full_name = "";
		var is_component = "";
		var class_name_last = "";
		var class_annotations = new Runtime.Vector();
		/* Content */
		var content = parser.content;
		var content_sz = parser.content_sz;
		/* Read class header */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "class");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readAttrs(parser);
		parser = Runtime.rtl.attr(res, 0);
		var attrs = Runtime.rtl.attr(res, 1);
		class_name = attrs.get("name", "");
		class_extends = attrs.get("extends", null);
		class_version = attrs.get("version", "1.0");
		class_model = attrs.get("model", "Runtime.Dict");
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		var flag_is_component = true;
		var flag_is_model = false;
		if (attrs.get("type") == "model")
		{
			flag_is_component = false;
			flag_is_model = true;
		}
		/* Default class extends */
		if (class_extends == null)
		{
			if (flag_is_component)
			{
				class_extends = "Runtime.Web.Component";
			}
			else
			{
				class_extends = "Runtime.Web.BaseModel";
			}
		}
		var getClassShortName = (class_name) =>
		{
			var __v0 = new Runtime.Monad(class_name);
			var __v1 = (__varg0) => Runtime.rs.split(".", __varg0);
			__v0 = __v0.call(__v1);
			__v0 = __v0.callMethod("last", []);
			return __v0.value();
		};
		if (class_name == "Runtime.Web.Component")
		{
			class_extends = "Runtime.BaseObject";
		}
		else
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(getClassShortName(class_name), class_name));
		}
		if (class_extends != "" && class_extends != null)
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(getClassShortName(class_extends), class_extends));
			if (class_extends != "Runtime.BaseObject" && class_extends != "Runtime.Web.Component" && class_extends != "Runtime.Web.BaseModel")
			{
				components.push(class_extends);
			}
		}
		if (class_model != "" && class_model != "Runtime.Dict")
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(getClassShortName(class_model), class_model));
		}
		var class_name_arr = Runtime.rs.split(".", class_name);
		class_name_last = class_name_arr.last();
		class_name_arr = class_name_arr.slice(0, -1);
		namespace_name = Runtime.rs.join(".", class_name_arr);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_name"]), class_name_last);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_namespace_name"]), namespace_name);
		var class_extend_op_code = null;
		if (class_extends != null)
		{
			class_extend_op_code = new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"caret_start":class_caret_start,"caret_end":parser.caret,"names":Runtime.rs.split(".", class_extends)})),"template":null,"caret_start":class_caret_start,"caret_end":parser.caret}));
		}
		/* Add namespace */
		module_items.push(new BayLang.OpCodes.OpNamespace(Runtime.Map.from({"name":namespace_name})));
		/* Read class body */
		var caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
		var ch2 = Runtime.rs.substr(content.ref, caret.pos, 2);
		while (ch2 != "</" && caret.pos < content_sz)
		{
			var parser_start = parser;
			var caret_start = parser.caret;
			var res = parser.parser_base.constructor.matchToken(parser, "<");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			var item_token = Runtime.rtl.attr(res, 1);
			item_name = item_token.content;
			/* Html comment */
			if (item_name == "!--")
			{
				var res = this.readHTMLComment(parser_start);
				parser = Runtime.rtl.attr(res, 0);
				items.push(Runtime.rtl.attr(res, 1));
				caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
				ch2 = Runtime.rs.substr(content.ref, caret.pos, 2);
				continue;
			}
			var res = this.readAttrs(parser);
			parser = Runtime.rtl.attr(res, 0);
			var item_attrs = Runtime.rtl.attr(res, 1);
			if (item_name == "annotation")
			{
				var annotation_name = item_attrs.get("name", "");
				var annotation_op_code = item_attrs.get("value", null);
				class_annotations.push(new BayLang.OpCodes.OpAnnotation(Runtime.Map.from({"name":new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"names":Runtime.rs.split(".", annotation_name)}))})),"params":annotation_op_code})));
			}
			else if (item_name == "use")
			{
				full_name = item_attrs.get("name", "");
				short_name = item_attrs.get("as", "");
				is_component = item_attrs.get("component", "false");
				is_component = is_component == "true" || is_component == "1";
				if (short_name == "")
				{
					short_name = Runtime.rs.split(".", full_name).last();
				}
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(short_name, full_name));
				if (is_component)
				{
					components.push(full_name);
				}
				module_items.push(new BayLang.OpCodes.OpUse(Runtime.Map.from({"name":full_name,"alias":short_name,"is_component":is_component})));
			}
			/* Read body */
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ">")
			{
				if (item_name == "template")
				{
					var res = this.readHTMLTemplate(parser, item_attrs, caret_start);
					parser = Runtime.rtl.attr(res, 0);
					var op_code = Runtime.rtl.attr(res, 1);
					items.push(op_code);
				}
				else if (item_name == "style")
				{
					var res = this.readStyle(parser, item_attrs, items, caret_start);
					parser = Runtime.rtl.attr(res, 0);
					var op_code = Runtime.rtl.attr(res, 1);
					items.push(op_code);
				}
				else if (item_name == "script")
				{
					var res = parser.parser_program.constructor.readClassBody(parser, "</");
					parser = Runtime.rtl.attr(res, 0);
					var arr = Runtime.rtl.attr(res, 1);
					items.appendItems(arr);
					/* Read script footer */
					var res = parser.parser_base.constructor.matchToken(parser, "<");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, "/");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, "script");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.matchToken(parser, ">");
					parser = Runtime.rtl.attr(res, 0);
				}
				else
				{
					throw new BayLang.Exceptions.ParserError("Unknown identifier '" + Runtime.rtl.toStr(item_name) + Runtime.rtl.toStr("'"), item_token.caret_start, parser.file_name)
				}
			}
			else if (token.content == "/")
			{
				var res = parser.parser_base.constructor.matchToken(parser, ">");
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				throw new BayLang.Exceptions.ParserError("Unknown identifier '" + Runtime.rtl.toStr(token.content) + Runtime.rtl.toStr("'"), token.caret_start, parser.file_name)
			}
			caret = parser.parser_base.constructor.skipChar(parser, content, parser.caret);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
			ch2 = Runtime.rs.substr(content.ref, caret.pos, 2);
		}
		/* Add components function */
		if (components.count() > 0)
		{
			var f = new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"args":Runtime.Vector.from([]),"vars":Runtime.Vector.from([]),"flags":new BayLang.OpCodes.OpFlags(Runtime.Map.from({"p_static":true,"p_pure":true})),"name":"components","result_type":"var","expression":new BayLang.OpCodes.OpCollection(Runtime.Map.from({"caret_start":parser.caret,"caret_end":parser.caret,"values":components.map((class_name) =>
			{
				return new BayLang.OpCodes.OpString(Runtime.Map.from({"caret_start":parser.caret,"caret_end":parser.caret,"value":class_name}));
			})})),"items":null,"caret_start":parser.caret,"caret_end":parser.caret}));
			items.push(f);
		}
		/* Read class footer */
		var res = parser.parser_base.constructor.matchToken(parser, "<");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "/");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "class");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, ">");
		parser = Runtime.rtl.attr(res, 0);
		/* Analyze class body */
		var class_body = parser.parser_program.constructor.classBodyAnalyze(parser, items);
		/* Add class */
		module_items.push(new BayLang.OpCodes.OpDeclareClass(Runtime.Map.from({"kind":BayLang.OpCodes.OpDeclareClass.KIND_CLASS,"name":class_name_last,"is_static":true,"is_component":flag_is_component,"is_model":flag_is_model,"is_declare":false,"class_extends":class_extend_op_code,"class_implements":null,"annotations":Runtime.Vector.from([]),"template":null,"vars":class_body.item("vars"),"annotations":class_annotations,"functions":class_body.item("functions"),"fn_create":class_body.item("fn_create"),"fn_destroy":class_body.item("fn_destroy"),"items":items,"caret_start":class_caret_start,"caret_end":parser.caret})));
		return Runtime.Vector.from([parser,module_items]);
	},
	/**
	 * Read UI
	 */
	readUI: function(parser)
	{
		var look = null;
		var token = null;
		var items = new Runtime.Vector();
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		while (token.content == "<")
		{
			var parser_start = parser;
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "class")
			{
				var res = this.readUIClass(parser_start);
				parser = Runtime.rtl.attr(res, 0);
				items.appendItems(Runtime.rtl.attr(res, 1));
			}
			else if (token.content == "!--")
			{
				var res = this.readHTMLComment(parser_start);
				parser = Runtime.rtl.attr(res, 0);
				items.push(Runtime.rtl.attr(res, 1));
			}
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpModule(Runtime.Map.from({"is_component":true,"uses":parser.uses,"items":items,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayHtml";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayHtml);
window["BayLang.LangBay.ParserBayHtml"] = BayLang.LangBay.ParserBayHtml;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayHtml;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayOperator = function()
{
};
Object.assign(BayLang.LangBay.ParserBayOperator.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayOperator,
{
	/**
	 * Read return
	 */
	readReturn: function(parser)
	{
		var token = null;
		var op_code = null;
		var look = null;
		var res = parser.parser_base.constructor.matchToken(parser, "return");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content != ";")
		{
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpReturn(Runtime.Map.from({"expression":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read delete
	 */
	readDelete: function(parser)
	{
		var token = null;
		var op_code = null;
		var res = parser.parser_base.constructor.matchToken(parser, "delete");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readDynamic(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpDelete(Runtime.Map.from({"op_code":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read throw
	 */
	readThrow: function(parser)
	{
		var token = null;
		var op_code = null;
		var res = parser.parser_base.constructor.matchToken(parser, "throw");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpThrow(Runtime.Map.from({"expression":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read try
	 */
	readTry: function(parser)
	{
		var look = null;
		var token = null;
		var op_try = null;
		var items = new Runtime.Vector();
		var res = parser.parser_base.constructor.matchToken(parser, "try");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		/* Try */
		var res = this.readOperators(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_try = Runtime.rtl.attr(res, 1);
		/* Catch */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content == "catch")
		{
			parser = look;
			var op_catch = null;
			var var_op_code = null;
			var pattern = null;
			var item_caret_start = token.caret_start;
			/* Read ident */
			var res = parser.parser_base.constructor.matchToken(parser, "(");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readTypeIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			pattern = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			var_op_code = Runtime.rtl.attr(res, 1);
			var var_name = var_op_code.value;
			var res = parser.parser_base.constructor.matchToken(parser, ")");
			parser = Runtime.rtl.attr(res, 0);
			/* Save vars */
			var save_vars = parser.vars;
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm(var_name, true));
			/* Catch operators */
			var res = this.readOperators(parser);
			parser = Runtime.rtl.attr(res, 0);
			op_catch = Runtime.rtl.attr(res, 1);
			/* Restore vars */
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
			var item = new BayLang.OpCodes.OpTryCatchItem(Runtime.Map.from({"name":var_name,"pattern":pattern,"value":op_catch,"caret_start":item_caret_start,"caret_end":parser.caret}));
			items.push(item);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpTryCatch(Runtime.Map.from({"op_try":op_try,"items":items,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read then
	 */
	readThen: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "then")
		{
			return Runtime.Vector.from([look,token]);
		}
		return Runtime.Vector.from([parser,token]);
	},
	/**
	 * Read do
	 */
	readDo: function(parser)
	{
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "do")
		{
			return Runtime.Vector.from([look,token]);
		}
		return Runtime.Vector.from([parser,token]);
	},
	/**
	 * Read if
	 */
	readIf: function(parser)
	{
		var look = null;
		var look2 = null;
		var token = null;
		var token2 = null;
		var if_condition = null;
		var if_true = null;
		var if_false = null;
		var if_else = new Runtime.Vector();
		var res = parser.parser_base.constructor.matchToken(parser, (parser.is_html) ? ("%if") : ("if"));
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		/* Read expression */
		var res = parser.parser_base.constructor.matchToken(parser, "(");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		if_condition = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ")");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readThen(parser);
		parser = Runtime.rtl.attr(res, 0);
		/* If true */
		var res = this.readOperators(parser);
		parser = Runtime.rtl.attr(res, 0);
		if_true = Runtime.rtl.attr(res, 1);
		/* Else */
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && (parser.is_html && (token.content == "%else" || token.content == "%elseif") || !parser.is_html && (token.content == "else" || token.content == "elseif")))
		{
			var res = parser.parser_base.constructor.readToken(look);
			look2 = Runtime.rtl.attr(res, 0);
			token2 = Runtime.rtl.attr(res, 1);
			if (token.content == "%elseif" || token.content == "elseif" || token.content == "else" && token2.content == "if" || token.content == "%else" && token2.content == "if")
			{
				var ifelse_condition = null;
				var ifelse_block = null;
				if (token.content == "elseif")
				{
					parser = look;
				}
				else if (token2.content == "%elseif")
				{
					parser = look2;
				}
				else if (token2.content == "if")
				{
					parser = look2;
				}
				else if (token2.content == "%if")
				{
					parser = look2;
				}
				/* Read expression */
				var res = parser.parser_base.constructor.matchToken(parser, "(");
				parser = Runtime.rtl.attr(res, 0);
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				ifelse_condition = Runtime.rtl.attr(res, 1);
				var res = parser.parser_base.constructor.matchToken(parser, ")");
				parser = Runtime.rtl.attr(res, 0);
				var res = this.readThen(parser);
				parser = Runtime.rtl.attr(res, 0);
				var res = this.readOperators(parser);
				parser = Runtime.rtl.attr(res, 0);
				ifelse_block = Runtime.rtl.attr(res, 1);
				if_else.push(new BayLang.OpCodes.OpIfElse(Runtime.Map.from({"condition":ifelse_condition,"if_true":ifelse_block,"caret_start":token2.caret_start,"caret_end":parser.caret})));
			}
			else
			{
				var res = this.readOperators(look);
				parser = Runtime.rtl.attr(res, 0);
				if_false = Runtime.rtl.attr(res, 1);
				break;
			}
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpIf(Runtime.Map.from({"condition":if_condition,"if_true":if_true,"if_false":if_false,"if_else":if_else,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read For
	 */
	readFor: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var expr1 = null;
		var expr2 = null;
		var expr3 = null;
		/* Save vars */
		var save_vars = parser.vars;
		var res = parser.parser_base.constructor.matchToken(parser, (parser.is_html) ? ("%for") : ("for"));
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.matchToken(parser, "(");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = this.readAssign(parser);
		parser = Runtime.rtl.attr(res, 0);
		expr1 = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ";");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		expr2 = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ";");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = this.readOperator(parser);
		parser = Runtime.rtl.attr(res, 0);
		expr3 = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ")");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = this.readOperators(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpFor(Runtime.Map.from({"expr1":expr1,"expr2":expr2,"expr3":expr3,"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read While
	 */
	readWhile: function(parser)
	{
		var look = null;
		var token = null;
		var condition = null;
		var op_code = null;
		var res = parser.parser_base.constructor.matchToken(parser, (parser.is_html) ? ("%while") : ("while"));
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.matchToken(parser, "(");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		condition = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ")");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readDo(parser);
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var res = this.readOperators(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpWhile(Runtime.Map.from({"condition":condition,"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read While
	 */
	readSafe: function(parser)
	{
		var caret_start = parser.caret;
		var res = parser.parser_base.constructor.matchToken(parser, "safe");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.matchToken(parser, "(");
		parser = Runtime.rtl.attr(res, 0);
		var res = parser.parser_base.constructor.readDynamic(parser);
		parser = Runtime.rtl.attr(res, 0);
		var obj = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.matchToken(parser, ")");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readOperators(parser);
		parser = Runtime.rtl.attr(res, 0);
		var items = Runtime.rtl.attr(res, 1);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpSafe(Runtime.Map.from({"obj":obj,"items":items,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read assign
	 */
	readAssign: function(parser)
	{
		var start = parser;
		var save = null;
		var look = null;
		var token = null;
		var pattern = null;
		var op_code = null;
		var reg_name = null;
		var expression = null;
		var names = null;
		var values = null;
		var kind = BayLang.OpCodes.OpAssign.KIND_ASSIGN;
		var var_name = "";
		var res = parser.parser_base.constructor.readIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var_name = op_code.value;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "<=")
		{
			var arr = new Runtime.Vector();
			while (!token.eof && token.content == "<=")
			{
				var name = "";
				parser = look;
				save = parser;
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content == "{")
				{
					var res = parser.parser_base.constructor.matchToken(parser, "{");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_expression.constructor.readExpression(parser);
					parser = Runtime.rtl.attr(res, 0);
					name = Runtime.rtl.attr(res, 1);
					var res = parser.parser_base.constructor.matchToken(parser, "}");
					parser = Runtime.rtl.attr(res, 0);
				}
				else if (token.content == "\"" || token.content == "'")
				{
					var res = parser.parser_base.constructor.readString(parser);
					parser = Runtime.rtl.attr(res, 0);
					name = Runtime.rtl.attr(res, 1);
				}
				else
				{
					var res = parser.parser_base.constructor.readToken(parser);
					parser = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
					name = token.content;
				}
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content != "<=")
				{
					parser = save;
					break;
				}
				else
				{
					arr.push(name);
				}
			}
			names = arr.slice();
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			expression = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([parser,new BayLang.OpCodes.OpAssignStruct(Runtime.Map.from({"caret_start":caret_start,"caret_end":parser.caret,"expression":expression,"var_name":var_name,"names":names}))]);
		}
		if (token.content != "=" && token.content != "+=" && token.content != "-=" && token.content != "~=" && token.content != "." && token.content != "::" && token.content != "[")
		{
			var var_op_code = null;
			kind = BayLang.OpCodes.OpAssign.KIND_DECLARE;
			values = new Runtime.Vector();
			parser = start;
			var res = parser.parser_base.constructor.readTypeIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			pattern = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			var_op_code = Runtime.rtl.attr(res, 1);
			var_name = var_op_code.value;
			/* Read expression */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "=")
			{
				var res = parser.parser_expression.constructor.readExpression(look);
				parser = Runtime.rtl.attr(res, 0);
				expression = Runtime.rtl.attr(res, 1);
			}
			else
			{
				expression = null;
			}
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm(var_name, true));
			values.push(new BayLang.OpCodes.OpAssignValue(Runtime.Map.from({"var_name":var_name,"expression":expression,"caret_start":var_op_code.caret_start,"caret_end":parser.caret})));
			/* Look next token */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			while (!token.eof && token.content == ",")
			{
				var res = parser.parser_base.constructor.readIdentifier(look);
				parser = Runtime.rtl.attr(res, 0);
				var_op_code = Runtime.rtl.attr(res, 1);
				var_name = var_op_code.value;
				/* Read expression */
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content == "=")
				{
					var res = parser.parser_expression.constructor.readExpression(look);
					parser = Runtime.rtl.attr(res, 0);
					expression = Runtime.rtl.attr(res, 1);
				}
				else
				{
					expression = null;
				}
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm(var_name, true));
				values.push(new BayLang.OpCodes.OpAssignValue(Runtime.Map.from({"var_name":var_name,"expression":expression,"caret_start":var_op_code.caret_start,"caret_end":parser.caret})));
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
			}
			var_name = "";
			expression = null;
		}
		else
		{
			parser = start;
			kind = BayLang.OpCodes.OpAssign.KIND_ASSIGN;
			var op = "";
			var res = parser.parser_base.constructor.readDynamic(parser, 2 | 8);
			parser = Runtime.rtl.attr(res, 0);
			var op_code = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.readToken(parser);
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "=" || token.content == "+=" || token.content == "-=" || token.content == "~=")
			{
				op = token.content;
			}
			else
			{
				throw new BayLang.Exceptions.ParserError("Unknown operator " + Runtime.rtl.toStr(token.content), token.caret_start, parser.file_name)
			}
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			expression = Runtime.rtl.attr(res, 1);
			values = Runtime.Vector.from([new BayLang.OpCodes.OpAssignValue(Runtime.Map.from({"op_code":op_code,"expression":expression,"op":op}))]);
			var_name = "";
			expression = null;
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpAssign(Runtime.Map.from({"pattern":pattern,"values":(values != null) ? (values) : (null),"caret_start":caret_start,"caret_end":parser.caret,"expression":expression,"var_name":var_name,"names":names,"kind":kind}))]);
	},
	/**
	 * Read operator
	 */
	readInc: function(parser)
	{
		var look = null;
		var look1 = null;
		var look2 = null;
		var token = null;
		var token1 = null;
		var token2 = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look1 = Runtime.rtl.attr(res, 0);
		token1 = Runtime.rtl.attr(res, 1);
		var caret_start = token1.caret_start;
		var res = parser.parser_base.constructor.readToken(look1);
		look2 = Runtime.rtl.attr(res, 0);
		token2 = Runtime.rtl.attr(res, 1);
		var look1_content = token1.content;
		var look2_content = token2.content;
		if ((look1_content == "++" || look1_content == "--") && parser.parser_base.constructor.isIdentifier(look2_content))
		{
			parser = look2;
			var op_code = new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"value":look2_content,"caret_start":token2.caret_start,"caret_end":token2.caret_end}));
			op_code = new BayLang.OpCodes.OpInc(Runtime.Map.from({"kind":(look1_content == "++") ? (BayLang.OpCodes.OpInc.KIND_PRE_INC) : (BayLang.OpCodes.OpInc.KIND_PRE_DEC),"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}));
			return Runtime.Vector.from([parser,op_code]);
		}
		if ((look2_content == "++" || look2_content == "--") && parser.parser_base.constructor.isIdentifier(look1_content))
		{
			parser = look2;
			var op_code = new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"value":look1_content,"caret_start":token1.caret_start,"caret_end":token1.caret_end}));
			op_code = new BayLang.OpCodes.OpInc(Runtime.Map.from({"kind":(look2_content == "++") ? (BayLang.OpCodes.OpInc.KIND_POST_INC) : (BayLang.OpCodes.OpInc.KIND_POST_DEC),"value":op_code,"caret_start":caret_start,"caret_end":parser.caret}));
			return Runtime.Vector.from([parser,op_code]);
		}
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read call function
	 */
	readCallFunction: function(parser)
	{
		var op_code = null;
		var res = parser.parser_base.constructor.readDynamic(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		if (op_code instanceof BayLang.OpCodes.OpCall || op_code instanceof BayLang.OpCodes.OpPipe)
		{
			return Runtime.Vector.from([parser,op_code]);
		}
		return Runtime.Vector.from([parser,null]);
	},
	/**
	 * Read operator
	 */
	readOperator: function(parser)
	{
		var look = null;
		var token = null;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		if (token.content == "/")
		{
			return parser.parser_base.constructor.readComment(parser);
		}
		else if (token.content == "#switch" || token.content == "#ifcode")
		{
			return parser.parser_preprocessor.constructor.readPreprocessor(parser);
		}
		else if (token.content == "#ifdef")
		{
			return parser.parser_preprocessor.constructor.readPreprocessorIfDef(parser, BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR);
		}
		else if (token.content == "break")
		{
			return Runtime.Vector.from([look,new BayLang.OpCodes.OpBreak(Runtime.Map.from({"caret_start":caret_start,"caret_end":look.caret}))]);
		}
		else if (token.content == "continue")
		{
			return Runtime.Vector.from([look,new BayLang.OpCodes.OpContinue(Runtime.Map.from({"caret_start":caret_start,"caret_end":look.caret}))]);
		}
		else if (token.content == "delete")
		{
			return this.readDelete(parser);
		}
		else if (token.content == "return")
		{
			return this.readReturn(parser);
		}
		else if (token.content == "throw")
		{
			return this.readThrow(parser);
		}
		else if (token.content == "try")
		{
			return this.readTry(parser);
		}
		else if (token.content == "if")
		{
			return this.readIf(parser);
		}
		else if (token.content == "for")
		{
			return this.readFor(parser);
		}
		else if (token.content == "while")
		{
			return this.readWhile(parser);
		}
		else if (token.content == "safe")
		{
			return this.readSafe(parser);
		}
		var op_code = null;
		/* Read op inc */
		var res = this.readInc(parser);
		look = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		if (op_code != null)
		{
			return res;
		}
		/* Read op call function */
		var res = this.readCallFunction(parser);
		look = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		if (op_code != null)
		{
			return res;
		}
		var save_parser = parser;
		/* Try to read pipe */
		var res = parser.parser_base.constructor.readIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var caret_start = op_code.caret_start;
		var var_name = op_code.value;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "|>")
		{
			return parser.parser_expression.constructor.ExpressionPipe(save_parser);
		}
		parser = save_parser;
		return this.readAssign(parser);
	},
	/**
	 * Read operators
	 */
	readOpItems: function(parser, end_tag)
	{
		if (end_tag == undefined) end_tag = "}";
		var look = null;
		var token = null;
		var op_code = null;
		var arr = new Runtime.Vector();
		var caret_start = parser.caret;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		while (!token.eof && token.content != end_tag)
		{
			var parser_value = null;
			var res = this.readOperator(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			if (parser_value != null)
			{
				arr.push(parser_value);
			}
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
			if (token.content == ";")
			{
				parser = look;
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
			}
		}
		op_code = new BayLang.OpCodes.OpItems(Runtime.Map.from({"items":arr,"caret_start":caret_start,"caret_end":parser.caret}));
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read operators
	 */
	readOperators: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		/* Save vars */
		var save_vars = parser.vars;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (!parser.is_html)
		{
			if (token.content == "{")
			{
				var res = parser.parser_base.constructor.matchToken(parser, "{");
				parser = Runtime.rtl.attr(res, 0);
				var res = this.readOpItems(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				var res = this.readOperator(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				var res = parser.parser_base.constructor.matchToken(parser, ";");
				parser = Runtime.rtl.attr(res, 0);
			}
		}
		else
		{
			if (token.content == "{")
			{
				var res = parser.parser_base.constructor.matchToken(parser, "{");
				parser = Runtime.rtl.attr(res, 0);
				var res = parser.parser_html.constructor.readHTML(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				var res = parser.parser_base.constructor.matchToken(parser, "}");
				parser = Runtime.rtl.attr(res, 0);
			}
			else
			{
				var res = parser.parser_html.constructor.readHTML(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
			}
		}
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		return Runtime.Vector.from([parser,op_code]);
	},
	/**
	 * Read flags
	 */
	readFlags: function(parser)
	{
		var look = null;
		var token = null;
		var values = new Runtime.Map();
		var current_flags = BayLang.OpCodes.OpFlags.getFlags();
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && current_flags.indexOf(token.content) >= 0)
		{
			var flag = token.content;
			values.set("p_" + Runtime.rtl.toStr(flag), true);
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpFlags(values)]);
	},
	/**
	 * Read function args
	 */
	readDeclareFunctionArgs: function(parser, find_ident, flag_match)
	{
		if (find_ident == undefined) find_ident = true;
		if (flag_match == undefined) flag_match = true;
		var res = null;
		var look = null;
		var token = null;
		var items = new Runtime.Vector();
		if (flag_match)
		{
			res = parser.parser_base.constructor.matchToken(parser, "(");
			parser = Runtime.rtl.attr(res, 0);
		}
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (!token.eof && token.content != ")")
		{
			var arg_value = null;
			var arg_pattern = null;
			var arg_expression = null;
			var arg_start = parser;
			/* Arg type */
			var res = parser.parser_base.constructor.readTypeIdentifier(parser, find_ident);
			parser = Runtime.rtl.attr(res, 0);
			arg_pattern = Runtime.rtl.attr(res, 1);
			/* Arg name */
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			arg_value = Runtime.rtl.attr(res, 1);
			var arg_name = arg_value.value;
			/* Arg expression */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "=")
			{
				parser = look;
				var save_vars = parser.vars;
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), new Runtime.Dict());
				var res = parser.parser_expression.constructor.readExpression(parser);
				parser = Runtime.rtl.attr(res, 0);
				arg_expression = Runtime.rtl.attr(res, 1);
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
			}
			/* Register variable in parser */
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm(arg_name, true));
			items.push(new BayLang.OpCodes.OpDeclareFunctionArg(Runtime.Map.from({"pattern":arg_pattern,"name":arg_name,"expression":arg_expression,"caret_start":arg_pattern.caret_start,"caret_end":parser.caret})));
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == ",")
			{
				parser = look;
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
			}
		}
		if (flag_match)
		{
			res = parser.parser_base.constructor.matchToken(parser, ")");
			parser = Runtime.rtl.attr(res, 0);
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Read function variables
	 */
	readDeclareFunctionUse: function(parser, vars, find_ident)
	{
		if (vars == undefined) vars = null;
		if (find_ident == undefined) find_ident = true;
		var look = null;
		var token = null;
		var items = new Runtime.Vector();
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "use")
		{
			parser = look;
			var res = parser.parser_base.constructor.matchToken(parser, "(");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			while (!token.eof && token.content != ")")
			{
				var ident = null;
				var res = parser.parser_base.constructor.readIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
				ident = Runtime.rtl.attr(res, 1);
				var name = ident.value;
				if (vars != null && find_ident)
				{
					if (!vars.has(name))
					{
						throw new BayLang.Exceptions.ParserError("Unknown identifier '" + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("'"), ident.caret_start, parser.file_name)
					}
				}
				items.push(name);
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content == ",")
				{
					parser = look;
					var res = parser.parser_base.constructor.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
				}
			}
			var res = parser.parser_base.constructor.matchToken(parser, ")");
			parser = Runtime.rtl.attr(res, 0);
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Read function
	 */
	readDeclareFunction: function(parser, has_name)
	{
		if (has_name == undefined) has_name = true;
		var look = null;
		var parser_value = null;
		var op_code = null;
		var token = null;
		var flags = null;
		/* Clear vars */
		var save_is_html = parser.is_html;
		var save_vars = parser.vars;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), new Runtime.Dict());
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_html"]), false);
		var is_html = false;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "async")
		{
			parser = look;
			flags = new BayLang.OpCodes.OpFlags(Runtime.Map.from({"p_async":true}));
		}
		var res = parser.parser_base.constructor.readTypeIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		parser_value = Runtime.rtl.attr(res, 1);
		var caret_start = parser_value.caret_start;
		var result_type = parser_value;
		var expression = null;
		var is_context = true;
		var name = "";
		if (result_type && result_type instanceof BayLang.OpCodes.OpTypeIdentifier && result_type.entity_name instanceof BayLang.OpCodes.OpEntityName)
		{
			if (result_type.entity_name.names.get(0) == "html")
			{
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_html"]), true);
				is_html = true;
			}
		}
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "@")
		{
			is_context = false;
			parser = look;
		}
		if (has_name)
		{
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			var name = parser_value.value;
		}
		/* Read function arguments */
		var args = null;
		var res = this.readDeclareFunctionArgs(parser);
		parser = Runtime.rtl.attr(res, 0);
		args = Runtime.rtl.attr(res, 1);
		/* Read function variables */
		var vars = null;
		var res = this.readDeclareFunctionUse(parser, save_vars);
		parser = Runtime.rtl.attr(res, 0);
		vars = Runtime.rtl.attr(res, 1);
		/* Add variables */
		vars.each((name) =>
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.setIm(name, true));
		});
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "=>")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "=>");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			expression = Runtime.rtl.attr(res, 1);
			op_code = null;
		}
		else if (token.content == "{")
		{
			var save = parser;
			var res = parser.parser_base.constructor.matchToken(parser, "{");
			parser = Runtime.rtl.attr(res, 0);
			var res = this.readOperators(save);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			if (is_html)
			{
				expression = op_code;
				op_code = null;
			}
		}
		else if (token.content == ";")
		{
			var res = parser.parser_base.constructor.matchToken(parser, ";");
			parser = Runtime.rtl.attr(res, 0);
			expression = null;
			op_code = null;
		}
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["is_html"]), save_is_html);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"args":args,"vars":vars,"flags":flags,"name":name,"is_html":is_html,"is_context":is_context,"result_type":result_type,"expression":expression,"items":op_code,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Returns true if next is function
	 */
	tryReadFunction: function(parser, has_name, flags)
	{
		if (has_name == undefined) has_name = true;
		if (flags == undefined) flags = null;
		var look = null;
		var parser_value = null;
		var token = null;
		/* Clear vars */
		var save_vars = parser.vars;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), new Runtime.Dict());
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
		var res = false;
		try
		{
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "async")
			{
				parser = look;
			}
			var res = parser.parser_base.constructor.readTypeIdentifier(parser, false);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			var caret_start = parser_value.caret_start;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "@")
			{
				parser = look;
			}
			if (has_name)
			{
				var res = parser.parser_base.constructor.readIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
			}
			var res = this.readDeclareFunctionArgs(parser, false);
			parser = Runtime.rtl.attr(res, 0);
			var res = this.readDeclareFunctionUse(parser, null, false);
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (flags != null && flags.p_declare || parser.current_class_abstract || parser.current_class_declare || parser.current_class_kind == "interface")
			{
				if (token.content != ";")
				{
					throw new BayLang.Exceptions.ParserExpected("Function", caret_start, parser.file_name)
				}
			}
			else if (token.content != "=>" && token.content != "{")
			{
				throw new BayLang.Exceptions.ParserExpected("Function", caret_start, parser.file_name)
			}
			res = true;
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserExpected)
			{
				var e = _ex;
				
				res = false;
			}
			else
			{
				throw _ex;
			}
		}
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
		return res;
	},
	/**
	 * Read annotation
	 */
	readAnnotation: function(parser)
	{
		var look = null;
		var token = null;
		var name = null;
		var params = null;
		var res = parser.parser_base.constructor.matchToken(parser, "@");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readTypeIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		name = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "{")
		{
			var res = parser.parser_base.constructor.readDict(parser);
			parser = Runtime.rtl.attr(res, 0);
			params = Runtime.rtl.attr(res, 1);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpAnnotation(Runtime.Map.from({"name":name,"params":params}))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayOperator";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayOperator);
window["BayLang.LangBay.ParserBayOperator"] = BayLang.LangBay.ParserBayOperator;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayOperator;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayPreprocessor = function()
{
};
Object.assign(BayLang.LangBay.ParserBayPreprocessor.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayPreprocessor,
{
	/**
	 * Read namespace
	 */
	readPreprocessor: function(parser)
	{
		var start = parser;
		var look = null;
		var token = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "#switch")
		{
			return this.readPreprocessorSwitch(start);
		}
		if (token.content == "#ifcode")
		{
			return this.readPreprocessorIfCode(start);
		}
		return null;
	},
	/**
	 * Read preprocessor switch
	 */
	readPreprocessorSwitch: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var items = new Runtime.Vector();
		/* Save vars */
		var save_vars = parser.vars;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), parser.vars.concat(Runtime.Map.from({"ES6":true,"NODEJS":true,"JAVASCRIPT":true,"PHP":true,"PYTHON3":true})));
		var res = parser.parser_base.constructor.matchToken(parser, "#switch");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		while (token.content == "#case")
		{
			parser = look;
			/* Skip ifcode */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			if (token.content == "ifcode")
			{
				parser = look;
			}
			/* Read condition */
			var condition = null;
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			condition = Runtime.rtl.attr(res, 1);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
			/* Read then */
			var res = parser.parser_base.constructor.matchToken(parser, "then");
			parser = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			/* Read content */
			var content = "";
			var caret_content = parser.caret;
			var res = parser.parser_base.constructor.readUntilStringArr(parser, Runtime.Vector.from(["#case","#endswitch"]), false);
			parser = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			/* Look content */
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			var ifcode = new BayLang.OpCodes.OpPreprocessorIfCode(Runtime.Map.from({"condition":condition,"content":content,"caret_start":caret_content,"caret_end":parser.caret}));
			items.push(ifcode);
		}
		/* Restore vars */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["vars"]), save_vars);
		/* read endswitch */
		var res = parser.parser_base.constructor.matchToken(parser, "#endswitch");
		parser = Runtime.rtl.attr(res, 0);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpPreprocessorSwitch(Runtime.Map.from({"items":items,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read preprocessor ifcode
	 */
	readPreprocessorIfCode: function(parser)
	{
		var look = null;
		var token = null;
		var caret_start = parser.caret;
		var res = parser.parser_base.constructor.matchToken(parser, "#ifcode");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		/* Read condition */
		var condition = null;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		condition = Runtime.rtl.attr(res, 1);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
		/* Read then */
		var res = parser.parser_base.constructor.matchToken(parser, "then");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		/* Read content */
		var content = "";
		var caret_content = parser.caret;
		var res = parser.parser_base.constructor.readUntilStringArr(parser, Runtime.Vector.from(["#endif"]), false);
		parser = Runtime.rtl.attr(res, 0);
		content = Runtime.rtl.attr(res, 1);
		/* Match endif */
		var res = parser.parser_base.constructor.matchToken(parser, "#endif");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var ifcode = new BayLang.OpCodes.OpPreprocessorIfCode(Runtime.Map.from({"condition":condition,"content":content,"caret_start":caret_content,"caret_end":parser.caret}));
		return Runtime.Vector.from([parser,ifcode]);
	},
	/**
	 * Read preprocessor ifdef
	 */
	readPreprocessorIfDef: function(parser, kind)
	{
		if (kind == undefined) kind = "";
		var items = null;
		var token = null;
		var caret_start = parser.caret;
		var res = parser.parser_base.constructor.matchToken(parser, "#ifdef");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		/* Read condition */
		var condition = null;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), false);
		var res = parser.parser_expression.constructor.readExpression(parser);
		parser = Runtime.rtl.attr(res, 0);
		condition = Runtime.rtl.attr(res, 1);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["find_ident"]), true);
		/* Read then */
		var res = parser.parser_base.constructor.matchToken(parser, "then");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_PROGRAM)
		{
			var res = parser.parser_program.constructor.readProgram(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
			items = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
		}
		else if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_CLASS_BODY)
		{
			var res = parser.parser_program.constructor.readClassBody(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
			items = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
			/*list d = parser.parser_program::classBodyAnalyze(parser, items);
			items = d.item("functions");*/
		}
		else if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR)
		{
			var res = parser.parser_operator.constructor.readOpItems(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
			items = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
		}
		else if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_EXPRESSION)
		{
			var res = parser.parser_expression.constructor.readExpression(parser);
			parser = Runtime.rtl.attr(res, 0);
			items = Runtime.rtl.attr(res, 1);
			var res = parser.parser_base.constructor.matchToken(parser, "#endif");
			parser = Runtime.rtl.attr(res, 0);
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpPreprocessorIfDef(Runtime.Map.from({"items":items,"condition":condition,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayPreprocessor";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayPreprocessor);
window["BayLang.LangBay.ParserBayPreprocessor"] = BayLang.LangBay.ParserBayPreprocessor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayPreprocessor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.ParserBayProgram = function()
{
};
Object.assign(BayLang.LangBay.ParserBayProgram.prototype,
{
});
Object.assign(BayLang.LangBay.ParserBayProgram,
{
	/**
	 * Read namespace
	 */
	readNamespace: function(parser)
	{
		var token = null;
		var name = null;
		var res = parser.parser_base.constructor.matchToken(parser, "namespace");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readEntityName(parser, false);
		parser = Runtime.rtl.attr(res, 0);
		name = Runtime.rtl.attr(res, 1);
		var current_namespace_name = Runtime.rs.join(".", name.names);
		var current_namespace = new BayLang.OpCodes.OpNamespace(Runtime.Map.from({"name":current_namespace_name,"caret_start":caret_start,"caret_end":parser.caret}));
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_namespace"]), current_namespace);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_namespace_name"]), current_namespace_name);
		return Runtime.Vector.from([parser,current_namespace]);
	},
	/**
	 * Read use
	 */
	readUse: function(parser)
	{
		var look = null;
		var token = null;
		var name = null;
		var alias = "";
		var res = parser.parser_base.constructor.matchToken(parser, "use");
		parser = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		var res = parser.parser_base.constructor.readEntityName(parser, false);
		parser = Runtime.rtl.attr(res, 0);
		name = Runtime.rtl.attr(res, 1);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "as")
		{
			var parser_value = null;
			parser = look;
			var res = parser.parser_base.constructor.readIdentifier(parser);
			parser = Runtime.rtl.attr(res, 0);
			parser_value = Runtime.rtl.attr(res, 1);
			alias = parser_value.value;
		}
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpUse(Runtime.Map.from({"name":Runtime.rs.join(".", name.names),"alias":alias,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/**
	 * Read class body
	 */
	readClassBody: function(parser, end_tag)
	{
		if (end_tag == undefined) end_tag = "}";
		var look = null;
		var token = null;
		var items = new Runtime.Vector();
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		while (!token.eof && token.content != end_tag)
		{
			var item = null;
			if (token.content == "/")
			{
				var res = parser.parser_base.constructor.readComment(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				if (item != null)
				{
					items.push(item);
				}
			}
			else if (token.content == "@")
			{
				var res = parser.parser_operator.constructor.readAnnotation(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				items.push(item);
			}
			else if (token.content == "#switch" || token.content == "#ifcode")
			{
				var res = parser.parser_preprocessor.constructor.readPreprocessor(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				if (item != null)
				{
					items.push(item);
				}
			}
			else if (token.content == "#ifdef")
			{
				var res = parser.parser_preprocessor.constructor.readPreprocessorIfDef(parser, BayLang.OpCodes.OpPreprocessorIfDef.KIND_CLASS_BODY);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				if (item != null)
				{
					items.push(item);
				}
			}
			else if (token.content == "<")
			{
				break;
			}
			else
			{
				var flags = null;
				var res = parser.parser_operator.constructor.readFlags(parser);
				parser = Runtime.rtl.attr(res, 0);
				flags = Runtime.rtl.attr(res, 1);
				if (parser.parser_operator.constructor.tryReadFunction(parser, true, flags))
				{
					var res = parser.parser_operator.constructor.readDeclareFunction(parser, true);
					parser = Runtime.rtl.attr(res, 0);
					item = Runtime.rtl.attr(res, 1);
					if (item.expression != null)
					{
						if (!item.is_html)
						{
							var res = parser.parser_base.constructor.matchToken(parser, ";");
							parser = Runtime.rtl.attr(res, 0);
						}
						else
						{
							var res = parser.parser_base.constructor.readToken(parser);
							look = Runtime.rtl.attr(res, 0);
							token = Runtime.rtl.attr(res, 1);
							if (token.content == ";")
							{
								parser = look;
							}
						}
					}
				}
				else
				{
					var res = parser.parser_operator.constructor.readAssign(parser);
					parser = Runtime.rtl.attr(res, 0);
					item = Runtime.rtl.attr(res, 1);
					var res = parser.parser_base.constructor.matchToken(parser, ";");
					parser = Runtime.rtl.attr(res, 0);
				}
				item = Runtime.rtl.setAttr(item, Runtime.Collection.from(["flags"]), flags);
				if (item != null)
				{
					items.push(item);
				}
			}
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		}
		return Runtime.Vector.from([parser,items]);
	},
	/**
	 * Class body analyze
	 */
	classBodyAnalyze: function(parser, arr)
	{
		var names = new Runtime.Map();
		var vars = new Runtime.Vector();
		var functions = new Runtime.Vector();
		var items = new Runtime.Vector();
		var annotations = new Runtime.Vector();
		var comments = new Runtime.Vector();
		var fn_create = null;
		var fn_destroy = null;
		for (var i = 0; i < arr.count(); i++)
		{
			var item = arr.item(i);
			if (item instanceof BayLang.OpCodes.OpAnnotation)
			{
				annotations.push(item);
			}
			else if (item instanceof BayLang.OpCodes.OpComment)
			{
				comments.push(item);
			}
			else if (item instanceof BayLang.OpCodes.OpAssign)
			{
				for (var j = 0; j < item.values.count(); j++)
				{
					var assign_value = item.values.item(j);
					var value_name = assign_value.var_name;
					if (names.has(value_name))
					{
						throw new BayLang.Exceptions.ParserError("Dublicate identifier " + Runtime.rtl.toStr(value_name), assign_value.caret_start, parser.file_name)
					}
					names.set(value_name, true);
				}
				item = item.copy(Runtime.Map.from({"annotations":annotations.slice(),"comments":comments.slice()}));
				vars.push(item);
				annotations.clear();
				comments.clear();
			}
			else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
			{
				item = item.copy(Runtime.Map.from({"annotations":annotations.slice(),"comments":comments.slice()}));
				if (names.has(item.name))
				{
					throw new BayLang.Exceptions.ParserError("Dublicate identifier " + Runtime.rtl.toStr(item.name), item.caret_start, parser.file_name)
				}
				names.set(item.name, true);
				if (item.name == "constructor")
				{
					fn_create = item;
				}
				else if (item.name == "destructor")
				{
					fn_destroy = item;
				}
				else
				{
					functions.push(item);
				}
				annotations.clear();
				comments.clear();
			}
			else if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
			{
				var d = this.classBodyAnalyze(parser, item.items);
				var d_vars = Runtime.rtl.attr(d, "vars");
				d_vars = d_vars.map((v) =>
				{
					v = Runtime.rtl.setAttr(v, Runtime.Collection.from(["condition"]), item.condition);
					return v;
				});
				vars.appendItems(d_vars);
			}
			else
			{
				items.push(item);
			}
		}
		items.appendItems(comments);
		return Runtime.Map.from({"annotations":annotations,"comments":comments,"functions":functions,"items":items,"vars":vars,"fn_create":fn_create,"fn_destroy":fn_destroy});
	},
	/**
	 * Read class
	 */
	readClass: function(parser)
	{
		var look = null;
		var token = null;
		var op_code = null;
		var template = null;
		var is_abstract = false;
		var is_declare = false;
		var is_static = false;
		var is_struct = false;
		var class_kind = "";
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		if (token.content == "abstract")
		{
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			is_abstract = true;
		}
		if (token.content == "declare")
		{
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			is_declare = true;
		}
		if (token.content == "static")
		{
			parser = look;
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			is_static = true;
		}
		if (token.content == "class")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "class");
			parser = Runtime.rtl.attr(res, 0);
			class_kind = BayLang.OpCodes.OpDeclareClass.KIND_CLASS;
		}
		else if (token.content == "struct")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "struct");
			parser = Runtime.rtl.attr(res, 0);
			class_kind = BayLang.OpCodes.OpDeclareClass.KIND_STRUCT;
		}
		else if (token.content == "interface")
		{
			var res = parser.parser_base.constructor.matchToken(parser, "interface");
			parser = Runtime.rtl.attr(res, 0);
			class_kind = BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE;
		}
		else
		{
			var res = parser.parser_base.constructor.matchToken(parser, "class");
		}
		var res = parser.parser_base.constructor.readIdentifier(parser);
		parser = Runtime.rtl.attr(res, 0);
		op_code = Runtime.rtl.attr(res, 1);
		var class_name = op_code.value;
		/* Set class name */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_abstract"]), is_abstract);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_declare"]), is_declare);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_name"]), class_name);
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_kind"]), class_kind);
		/* Register module in parser */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(class_name, parser.current_namespace_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(class_name)));
		var save_uses = parser.uses;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "<")
		{
			template = new Runtime.Vector();
			var res = parser.parser_base.constructor.matchToken(parser, "<");
			parser = Runtime.rtl.attr(res, 0);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			while (!token.eof && token.content != ">")
			{
				var parser_value = null;
				var res = parser.parser_base.constructor.readIdentifier(parser);
				parser = Runtime.rtl.attr(res, 0);
				parser_value = Runtime.rtl.attr(res, 1);
				template.push(parser_value);
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(parser_value.value, parser_value.value));
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
				if (token.content != ">")
				{
					var res = parser.parser_base.constructor.matchToken(parser, ",");
					parser = Runtime.rtl.attr(res, 0);
					var res = parser.parser_base.constructor.readToken(parser);
					look = Runtime.rtl.attr(res, 0);
					token = Runtime.rtl.attr(res, 1);
				}
			}
			var res = parser.parser_base.constructor.matchToken(parser, ">");
			parser = Runtime.rtl.attr(res, 0);
		}
		var class_extends = null;
		var class_implements = null;
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "extends")
		{
			var res = parser.parser_base.constructor.readTypeIdentifier(look);
			parser = Runtime.rtl.attr(res, 0);
			class_extends = Runtime.rtl.attr(res, 1);
		}
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		if (token.content == "implements")
		{
			class_implements = new Runtime.Vector();
			var res = parser.parser_base.constructor.readTypeIdentifier(look);
			parser = Runtime.rtl.attr(res, 0);
			op_code = Runtime.rtl.attr(res, 1);
			class_implements.push(op_code);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			while (!token.eof && token.content == ",")
			{
				parser = look;
				var res = parser.parser_base.constructor.readTypeIdentifier(look);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				class_implements.push(op_code);
				var res = parser.parser_base.constructor.readToken(parser);
				look = Runtime.rtl.attr(res, 0);
				token = Runtime.rtl.attr(res, 1);
			}
		}
		var arr = null;
		var res = parser.parser_base.constructor.matchToken(parser, "{");
		parser = Runtime.rtl.attr(res, 0);
		var res = this.readClassBody(parser);
		parser = Runtime.rtl.attr(res, 0);
		arr = Runtime.rtl.attr(res, 1);
		var d = this.classBodyAnalyze(parser, arr);
		var res = parser.parser_base.constructor.matchToken(parser, "}");
		parser = Runtime.rtl.attr(res, 0);
		var current_class = new BayLang.OpCodes.OpDeclareClass(Runtime.Map.from({"kind":class_kind,"name":class_name,"is_abstract":is_abstract,"is_static":is_static,"is_declare":is_declare,"class_extends":class_extends,"class_implements":(class_implements != null) ? (class_implements) : (null),"template":(template != null) ? (template) : (null),"vars":d.item("vars"),"functions":d.item("functions"),"fn_create":d.item("fn_create"),"fn_destroy":d.item("fn_destroy"),"items":arr,"caret_start":caret_start,"caret_end":parser.caret}));
		/* Restore uses */
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), save_uses);
		return Runtime.Vector.from([parser.copy(Runtime.Map.from({"current_class":current_class})),current_class]);
	},
	/**
	 * Read program
	 */
	readProgram: function(parser, end_tag)
	{
		if (end_tag == undefined) end_tag = "";
		var look = null;
		var token = null;
		var op_code = null;
		var annotations = new Runtime.Vector();
		var comments = new Runtime.Vector();
		var items = new Runtime.Vector();
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
		var res = parser.parser_base.constructor.readToken(parser);
		look = Runtime.rtl.attr(res, 0);
		token = Runtime.rtl.attr(res, 1);
		var caret_start = token.caret_start;
		parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		if (token.eof)
		{
			return Runtime.Vector.from([parser,null]);
		}
		if (token.content == "<")
		{
			return parser.parser_html.constructor.readUI(parser);
		}
		while (!token.eof && (end_tag == "" || end_tag != "" && token.content == end_tag))
		{
			if (token.content == "/")
			{
				var res = parser.parser_base.constructor.readComment(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				if (op_code != null)
				{
					comments.push(op_code);
				}
			}
			else if (token.content == "@")
			{
				var res = parser.parser_operator.constructor.readAnnotation(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				annotations.push(op_code);
			}
			else if (token.content == "#switch" || token.content == "#ifcode")
			{
				/* Append comments */
				items.appendItems(comments);
				comments.clear();
				var res = parser.parser_preprocessor.constructor.readPreprocessor(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				if (op_code != null)
				{
					items.appendItems(comments);
					items.push(op_code);
				}
			}
			else if (token.content == "#ifdef")
			{
				/* Append comments */
				items.appendItems(comments);
				comments.clear();
				var res = parser.parser_preprocessor.constructor.readPreprocessorIfDef(parser, BayLang.OpCodes.OpPreprocessorIfDef.KIND_PROGRAM);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				if (op_code != null)
				{
					items.appendItems(comments);
					items.push(op_code);
				}
			}
			else if (token.content == "namespace")
			{
				/* Append comments */
				items.appendItems(comments);
				comments.clear();
				var res = this.readNamespace(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				items.push(op_code);
				var res = parser.parser_base.constructor.matchToken(parser, ";");
				parser = Runtime.rtl.attr(res, 0);
			}
			else if (token.content == "use")
			{
				/* Append comments */
				items.appendItems(comments);
				comments.clear();
				var res = this.readUse(parser);
				parser = Runtime.rtl.attr(res, 0);
				op_code = Runtime.rtl.attr(res, 1);
				var full_name = op_code.name;
				var short_name = "";
				if (op_code.alias == "")
				{
					short_name = Runtime.rs.split(".", full_name).last();
				}
				else
				{
					short_name = op_code.alias;
				}
				/* Register module in parser */
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), parser.uses.setIm(short_name, full_name));
				items.push(op_code);
				var res = parser.parser_base.constructor.matchToken(parser, ";");
				parser = Runtime.rtl.attr(res, 0);
			}
			else if (token.content == "class" || token.content == "struct" || token.content == "static" || token.content == "declare" || token.content == "interface" || token.content == "abstract")
			{
				var item = null;
				var res = this.readClass(parser);
				parser = Runtime.rtl.attr(res, 0);
				item = Runtime.rtl.attr(res, 1);
				item = item.copy(Runtime.Map.from({"annotations":annotations,"comments":comments}));
				items.push(item);
				annotations.clear();
				comments.clear();
			}
			else
			{
				break;
			}
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), false);
			var res = parser.parser_base.constructor.readToken(parser);
			look = Runtime.rtl.attr(res, 0);
			token = Runtime.rtl.attr(res, 1);
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["skip_comments"]), true);
		}
		items.appendItems(comments);
		return Runtime.Vector.from([parser,new BayLang.OpCodes.OpModule(Runtime.Map.from({"uses":parser.uses.toDict(),"items":items,"caret_start":caret_start,"caret_end":parser.caret}))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.ParserBayProgram";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.ParserBayProgram);
window["BayLang.LangBay.ParserBayProgram"] = BayLang.LangBay.ParserBayProgram;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.ParserBayProgram;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.TranslatorBay = function()
{
	Runtime.BaseObject.apply(this, arguments);
};
BayLang.LangBay.TranslatorBay.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.TranslatorBay.prototype.constructor = BayLang.LangBay.TranslatorBay;
Object.assign(BayLang.LangBay.TranslatorBay.prototype,
{
	/**
	 * Reset translator
	 */
	reset: function()
	{
		this.opcode_level = 0;
		this.indent_level = 0;
		this.preprocessor_flags = Runtime.Map.from({});
	},
	/**
	 * Set flag
	 */
	setFlag: function(flag_name, value)
	{
		this.preprocessor_flags.set(flag_name, value);
		return this;
	},
	/**
	 * Increment indent level
	 */
	levelInc: function()
	{
		this.indent_level = this.indent_level + 1;
	},
	/**
	 * Decrease indent level
	 */
	levelDec: function()
	{
		this.indent_level = this.indent_level - 1;
	},
	/**
	 * Returns new line with indent
	 */
	newLine: function()
	{
		return this.crlf + Runtime.rtl.toStr(Runtime.rs.str_repeat(this.indent, this.indent_level));
	},
	/**
	 * Returns string
	 */
	toString: function(s)
	{
		s = Runtime.re.replace("\\\\", "\\\\", s);
		s = Runtime.re.replace("\"", "\\\"", s);
		s = Runtime.re.replace("\n", "\\n", s);
		s = Runtime.re.replace("\r", "\\r", s);
		s = Runtime.re.replace("\t", "\\t", s);
		return "\"" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr("\"");
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.opcode_level = 0;
		this.indent_level = 0;
		this.indent = "\t";
		this.crlf = "\n";
		this.preprocessor_flags = Runtime.Map.from({});
		this.expression = new BayLang.LangBay.TranslatorBayExpression(this);
		this.operator = new BayLang.LangBay.TranslatorBayOperator(this);
		this.program = new BayLang.LangBay.TranslatorBayProgram(this);
		this.html = new BayLang.LangBay.TranslatorBayHtml(this);
	},
});
Object.assign(BayLang.LangBay.TranslatorBay, Runtime.BaseObject);
Object.assign(BayLang.LangBay.TranslatorBay,
{
	/**
	 * Translate BaseOpCode
	 */
	translate: function(t, op_code)
	{
		var content = Runtime.Vector.from([]);
		if (op_code.is_component)
		{
			t.html.translate(op_code, content);
		}
		else
		{
			t.program.translate(op_code, content);
		}
		var result = Runtime.rs.join("", content);
		return Runtime.Vector.from([t,result]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.TranslatorBay";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.TranslatorBay);
window["BayLang.LangBay.TranslatorBay"] = BayLang.LangBay.TranslatorBay;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.TranslatorBay;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.TranslatorBayExpression = function(translator)
{
	Runtime.BaseObject.call(this);
	this.translator = translator;
};
BayLang.LangBay.TranslatorBayExpression.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.TranslatorBayExpression.prototype.constructor = BayLang.LangBay.TranslatorBayExpression;
Object.assign(BayLang.LangBay.TranslatorBayExpression.prototype,
{
	/**
	 * OpIdentifier
	 */
	OpIdentifier: function(op_code, result)
	{
		result.push(op_code.value);
		this.translator.opcode_level = 20;
	},
	/**
	 * OpNumber
	 */
	OpNumber: function(op_code, result)
	{
		result.push(op_code.value);
		this.translator.opcode_level = 20;
	},
	/**
	 * OpString
	 */
	OpString: function(op_code, result)
	{
		result.push(this.translator.toString(op_code.value));
		this.translator.opcode_level = 20;
	},
	/**
	 * OpTypeTemplate
	 */
	OpTypeTemplate: function(items, result)
	{
		if (items)
		{
			result.push("<");
			var items_count = items.count();
			for (var i = 0; i < items_count; i++)
			{
				var op_code_item = items.get(i);
				if (op_code_item instanceof BayLang.OpCodes.OpIdentifier)
				{
					this.OpIdentifier(op_code_item, result);
				}
				else if (op_code_item instanceof BayLang.OpCodes.OpTypeIdentifier)
				{
					this.OpTypeIdentifier(op_code_item, result);
				}
				if (i < items_count - 1)
				{
					result.push(", ");
				}
			}
			result.push(">");
		}
	},
	/**
	 * OpTypeIdentifier
	 */
	OpTypeIdentifier: function(op_code, result)
	{
		result.push(op_code.entity_name.names.last());
		this.OpTypeTemplate(op_code.template, result);
	},
	/**
	 * OpCollection
	 */
	OpCollection: function(op_code, result)
	{
		var is_multiline = op_code.isMultiLine();
		result.push("[");
		if (is_multiline)
		{
			this.translator.levelInc();
		}
		var i = 0;
		var values_count = op_code.values.count();
		while (i < values_count)
		{
			var op_code_item = op_code.values.get(i);
			if (is_multiline)
			{
				result.push(this.translator.newLine());
			}
			/* Preprocessor */
			if (op_code_item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
			{
				var items = Runtime.Vector.from([]);
				var condition = op_code_item.condition.value;
				while (op_code_item != null && op_code_item instanceof BayLang.OpCodes.OpPreprocessorIfDef && op_code_item.condition.value == condition)
				{
					items.push(op_code_item);
					/* Get next item */
					i++;
					op_code_item = op_code.values.get(i);
				}
				this.OpPreprocessorCollection(items, result);
				continue;
			}
			/* Translate item */
			this.translate(op_code_item, result);
			if (!(op_code_item instanceof BayLang.OpCodes.OpPreprocessorIfDef))
			{
				if (is_multiline)
				{
					result.push(",");
				}
				else if (i < values_count - 1)
				{
					result.push(", ");
				}
			}
			i++;
		}
		if (is_multiline)
		{
			this.translator.levelDec();
			result.push(this.translator.newLine());
		}
		result.push("]");
	},
	/**
	 * Collection preprocessor
	 */
	OpPreprocessorCollection: function(items, result)
	{
		var condition = items.get(0).condition.value;
		result.push("#ifdef " + Runtime.rtl.toStr(condition) + Runtime.rtl.toStr(" then"));
		for (var i = 0; i < items.count(); i++)
		{
			var op_code_item = items.get(i);
			result.push(this.translator.newLine());
			this.translate(op_code_item.items, result);
			result.push(",");
		}
		result.push(this.translator.newLine());
		result.push("#endif");
	},
	/**
	 * OpDict
	 */
	OpDict: function(op_code, result)
	{
		var is_multiline = op_code.isMultiLine();
		if (op_code.values.count() == 0 && !is_multiline)
		{
			result.push("{");
			result.push("}");
			return ;
		}
		/* Begin bracket */
		result.push("{");
		if (is_multiline)
		{
			this.translator.levelInc();
		}
		/* Items */
		var i = 0;
		var values_count = op_code.values.count();
		while (i < values_count)
		{
			var op_code_item = op_code.values.get(i);
			if (is_multiline)
			{
				result.push(this.translator.newLine());
			}
			/* Preprocessor */
			if (op_code_item.condition != null)
			{
				var items = Runtime.Vector.from([]);
				var condition = op_code_item.condition.value;
				while (op_code_item != null && op_code_item.condition != null)
				{
					items.push(op_code_item);
					/* Get next item */
					i++;
					op_code_item = op_code.values.get(i);
				}
				this.OpPreprocessorDict(items, result);
				continue;
			}
			/* Translate item */
			result.push(this.translator.toString(op_code_item.key));
			result.push(": ");
			this.translate(op_code_item.value, result);
			if (is_multiline)
			{
				result.push(",");
			}
			else if (i < values_count - 1)
			{
				result.push(", ");
			}
			i++;
		}
		/* End bracket */
		if (is_multiline)
		{
			this.translator.levelDec();
			result.push(this.translator.newLine());
		}
		result.push("}");
	},
	/**
	 * Dict preprocessor
	 */
	OpPreprocessorDict: function(items, result)
	{
		var condition = items.get(0).condition.value;
		result.push("#ifdef " + Runtime.rtl.toStr(condition) + Runtime.rtl.toStr(" then"));
		for (var i = 0; i < items.count(); i++)
		{
			var op_code_item = items.get(i);
			result.push(this.translator.newLine());
			result.push(this.translator.toString(op_code_item.key));
			result.push(": ");
			this.translate(op_code_item.value, result);
			result.push(",");
		}
		result.push(this.translator.newLine());
		result.push("#endif");
	},
	/**
	 * OpAttr
	 */
	OpAttr: function(op_code, result)
	{
		var attrs = new Runtime.Vector();
		var op_code_first = op_code;
		while (op_code_first instanceof BayLang.OpCodes.OpAttr)
		{
			attrs.push(op_code_first);
			op_code_first = op_code_first.obj;
		}
		attrs = attrs.reverse();
		/* first op_code */
		this.translateItem(op_code_first, result);
		/* Attrs */
		for (var i = 0; i < attrs.count(); i++)
		{
			var item_attr = attrs.get(i);
			if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_ATTR)
			{
				result.push(".");
				result.push(item_attr.value.value);
			}
			else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_STATIC)
			{
				result.push("::");
				result.push(item_attr.value.value);
			}
			else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC)
			{
				result.push("[");
				this.translate(item_attr.value, result);
				result.push("]");
			}
			else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS)
			{
				result.push("[");
				var item_attr_count = item_attr.attrs.count();
				for (var j = 0; j < item_attr_count; j++)
				{
					var op_code_item = item_attr.attrs.get(j);
					this.translate(op_code_item, result);
					if (j < item_attr_count - 1)
					{
						result.push(", ");
					}
				}
				result.push("]");
			}
		}
		this.translator.opcode_level = 20;
	},
	/**
	 * OpClassOf
	 */
	OpClassOf: function(op_code, result)
	{
		result.push("classof ");
		result.push(op_code.entity_name.names.last());
	},
	/**
	 * OpCall
	 */
	OpCall: function(op_code, result)
	{
		this.translateItem(op_code.obj, result);
		if (op_code.args.count() == 1 && op_code.args.get(0) instanceof BayLang.OpCodes.OpDict)
		{
			this.OpDict(op_code.args.get(0), result);
		}
		else
		{
			result.push("(");
			var args_count = op_code.args.count();
			for (var i = 0; i < args_count; i++)
			{
				var op_code_item = op_code.args.get(i);
				this.Expression(op_code_item, result);
				if (i < args_count - 1)
				{
					result.push(", ");
				}
			}
			result.push(")");
		}
		this.translator.opcode_level = 20;
	},
	/**
	 * OpNew
	 */
	OpNew: function(op_code, result)
	{
		result.push("new ");
		this.OpTypeIdentifier(op_code.value, result);
		if (op_code.args.count() == 1 && op_code.args.get(0) instanceof BayLang.OpCodes.OpDict)
		{
			this.OpDict(op_code.args.get(0), result);
		}
		else
		{
			result.push("(");
			var args_count = op_code.args.count();
			for (var i = 0; i < args_count; i++)
			{
				var op_code_item = op_code.args.get(i);
				this.Expression(op_code_item, result);
				if (i < args_count - 1)
				{
					result.push(", ");
				}
			}
			result.push(")");
		}
		this.translator.opcode_level = 20;
	},
	/**
	 * OpMath
	 */
	OpMath: function(op_code, result)
	{
		var result1 = Runtime.Vector.from([]);
		this.Expression(op_code.value1, result1);
		var opcode_level1 = this.translator.opcode_level;
		var op = "";
		var opcode_level = 0;
		if (op_code.math == "!")
		{
			opcode_level = 16;
			op = "!";
		}
		if (op_code.math == ">>")
		{
			opcode_level = 12;
			op = ">>";
		}
		if (op_code.math == "<<")
		{
			opcode_level = 12;
			op = "<<";
		}
		if (op_code.math == "&")
		{
			opcode_level = 9;
			op = "&";
		}
		if (op_code.math == "xor")
		{
			opcode_level = 8;
			op = "^";
		}
		if (op_code.math == "|")
		{
			opcode_level = 7;
			op = "|";
		}
		if (op_code.math == "*")
		{
			opcode_level = 14;
			op = "*";
		}
		if (op_code.math == "/")
		{
			opcode_level = 14;
			op = "/";
		}
		if (op_code.math == "%")
		{
			opcode_level = 14;
			op = "%";
		}
		if (op_code.math == "div")
		{
			opcode_level = 14;
			op = "div";
		}
		if (op_code.math == "mod")
		{
			opcode_level = 14;
			op = "mod";
		}
		if (op_code.math == "+")
		{
			opcode_level = 13;
			op = "+";
		}
		if (op_code.math == "-")
		{
			opcode_level = 13;
			op = "-";
		}
		if (op_code.math == "~")
		{
			opcode_level = 13;
			op = "~";
		}
		if (op_code.math == "===")
		{
			opcode_level = 10;
			op = "===";
		}
		if (op_code.math == "!==")
		{
			opcode_level = 10;
			op = "!==";
		}
		if (op_code.math == "==")
		{
			opcode_level = 10;
			op = "==";
		}
		if (op_code.math == "!=")
		{
			opcode_level = 10;
			op = "!=";
		}
		if (op_code.math == ">=")
		{
			opcode_level = 10;
			op = ">=";
		}
		if (op_code.math == "<=")
		{
			opcode_level = 10;
			op = "<=";
		}
		if (op_code.math == ">")
		{
			opcode_level = 10;
			op = ">";
		}
		if (op_code.math == "<")
		{
			opcode_level = 10;
			op = "<";
		}
		if (op_code.math == "is")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "instanceof")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "implements")
		{
			opcode_level = 10;
			op = "implements";
		}
		if (op_code.math == "not")
		{
			opcode_level = 16;
			op = "not";
		}
		if (op_code.math == "and")
		{
			opcode_level = 6;
			op = "and";
		}
		if (op_code.math == "&&")
		{
			opcode_level = 6;
			op = "and";
		}
		if (op_code.math == "or")
		{
			opcode_level = 5;
			op = "or";
		}
		if (op_code.math == "||")
		{
			opcode_level = 5;
			op = "or";
		}
		if (op_code.math == "not" || op_code.math == "!")
		{
			result.push("not ");
			if (opcode_level1 < opcode_level)
			{
				result.push("(");
				result.appendItems(result1);
				result.push(")");
			}
			else
			{
				result.appendItems(result1);
			}
		}
		else
		{
			if (opcode_level1 < opcode_level)
			{
				result.push("(");
				result.appendItems(result1);
				result.push(")");
			}
			else
			{
				result.appendItems(result1);
			}
			result.push(" " + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" "));
			var result2 = Runtime.Vector.from([]);
			this.Expression(op_code.value2, result2);
			var opcode_level2 = this.translator.opcode_level;
			if (opcode_level2 < opcode_level)
			{
				result.push("(");
				result.appendItems(result2);
				result.push(")");
			}
			else
			{
				result.appendItems(result2);
			}
		}
		this.translator.opcode_level = opcode_level;
	},
	/**
	 * Translate item
	 */
	translateItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpNumber)
		{
			this.OpNumber(op_code, result);
		}
		if (op_code instanceof BayLang.OpCodes.OpString)
		{
			this.OpString(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			this.OpIdentifier(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			this.OpAttr(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpClassOf)
		{
			this.OpClassOf(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCollection)
		{
			this.OpCollection(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDict)
		{
			this.OpDict(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			this.OpCall(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNew)
		{
			this.OpNew(op_code, result);
		}
	},
	/**
	 * Expression
	 */
	Expression: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpMath)
		{
			this.OpMath(op_code, result);
		}
		else
		{
			this.translateItem(op_code, result);
		}
	},
	/**
	 * Translate expression
	 */
	translate: function(op_code, result)
	{
		this.Expression(op_code, result);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.translator = null;
	},
});
Object.assign(BayLang.LangBay.TranslatorBayExpression, Runtime.BaseObject);
Object.assign(BayLang.LangBay.TranslatorBayExpression,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.TranslatorBayExpression";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.TranslatorBayExpression);
window["BayLang.LangBay.TranslatorBayExpression"] = BayLang.LangBay.TranslatorBayExpression;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.TranslatorBayExpression;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.TranslatorBayHtml = function(translator)
{
	Runtime.BaseObject.call(this);
	this.translator = translator;
};
BayLang.LangBay.TranslatorBayHtml.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.TranslatorBayHtml.prototype.constructor = BayLang.LangBay.TranslatorBayHtml;
Object.assign(BayLang.LangBay.TranslatorBayHtml.prototype,
{
	/**
	 * OpAssign
	 */
	OpAssign: function(op_code, result)
	{
		result.push("%set ");
		this.translator.operator.OpAssign(op_code, result);
		result.push(";");
	},
	/**
	 * OpUse
	 */
	OpUse: function(op_code, result)
	{
		var items = Runtime.rs.split(".", op_code.name);
		var last_name = items.last();
		/* Get attrs */
		var attrs = Runtime.Vector.from(["name=\"" + Runtime.rtl.toStr(op_code.name) + Runtime.rtl.toStr("\"")]);
		/* Add alias name */
		if (op_code.alias != "" && op_code.alias != last_name)
		{
			attrs.push("as=\"" + Runtime.rtl.toStr(op_code.alias) + Runtime.rtl.toStr("\""));
		}
		/* Add component */
		if (op_code.is_component)
		{
			attrs.push("component=\"true\"");
		}
		/* Add result */
		result.push("<use " + Runtime.rtl.toStr(Runtime.rs.join(" ", attrs)) + Runtime.rtl.toStr(" />"));
	},
	/**
	 * Translate html content
	 */
	OpHtmlContent: function(op_code, result)
	{
		result.push(op_code.value);
	},
	/**
	 * Translate attrs
	 */
	OpHtmlAttrs: function(op_code_attrs, result)
	{
		/* Filter attrs */
		op_code_attrs = op_code_attrs.filter((op_code_attr) =>
		{
			/* Skip @key_debug attr */
			if (!this.translator.preprocessor_flags.get("DEBUG_COMPONENT") && op_code_attr.key == "@key_debug")
			{
				return false;
			}
			return true;
		});
		var attrs_count = op_code_attrs.count();
		for (var i = 0; i < attrs_count; i++)
		{
			var op_code_attr = op_code_attrs.get(i);
			result.push(op_code_attr.key);
			result.push("=");
			/* Value */
			if (op_code_attr.value instanceof BayLang.OpCodes.OpString)
			{
				this.translator.expression.translate(op_code_attr.value, result);
			}
			else
			{
				result.push("{{ ");
				this.translator.expression.translate(op_code_attr.value, result);
				result.push(" }}");
			}
			if (i < attrs_count - 1)
			{
				result.push(" ");
			}
		}
	},
	/**
	 * Translate html tag
	 */
	OpHtmlTag: function(op_code, result)
	{
		var is_multiline = op_code.isMultiLine();
		/* Component attrs */
		var args_content = Runtime.Vector.from([]);
		this.OpHtmlAttrs(op_code.attrs, args_content);
		var args = Runtime.rs.join("", args_content);
		if (args != "")
		{
			args = " " + Runtime.rtl.toStr(args);
		}
		if (op_code.items == null)
		{
			result.push("<" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(" />"));
		}
		else
		{
			/* Begin tag */
			result.push("<" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(">"));
			if (is_multiline)
			{
				this.translator.levelInc();
			}
			/* Items */
			this.OpHtmlItems(op_code.items, result, is_multiline);
			/* End tag */
			if (is_multiline)
			{
				this.translator.levelDec();
				result.push(this.translator.newLine());
			}
			result.push("</" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr(">"));
		}
	},
	/**
	 * OpHtmlSlot
	 */
	OpHtmlSlot: function(op_code, result)
	{
		/* Slot attrs */
		var args_content = Runtime.Vector.from([]);
		this.OpHtmlAttrs(op_code.attrs, args_content);
		/* Add slot args */
		if (op_code.args)
		{
			var args = op_code.args.map((item) =>
			{
				var res = new Runtime.Vector();
				this.translator.expression.OpTypeIdentifier(item.pattern, res);
				res.push(" ");
				res.push(item.name);
				return Runtime.rs.join("", res);
			});
			if (args_content.count() > 0)
			{
				args_content.push(" ");
			}
			args_content.push("args=\"" + Runtime.rtl.toStr(Runtime.rs.join(",", args)) + Runtime.rtl.toStr("\""));
		}
		/* Add slot vars */
		if (op_code.vars)
		{
			var vars = op_code.vars.map((item) =>
			{
				return item.value;
			});
			if (args_content.count() > 0)
			{
				args_content.push(" ");
			}
			args_content.push("use=\"" + Runtime.rtl.toStr(Runtime.rs.join(",", vars)) + Runtime.rtl.toStr("\""));
		}
		/* Slot args */
		var args = Runtime.rs.join("", args_content);
		if (args != "")
		{
			args = " " + Runtime.rtl.toStr(args);
		}
		/* Begin slot */
		result.push("<slot name=\"" + Runtime.rtl.toStr(op_code.name) + Runtime.rtl.toStr("\"") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(">"));
		/* Items */
		this.translator.levelInc();
		this.OpHtmlItems(op_code.items, result);
		this.translator.levelDec();
		/* End slot */
		result.push(this.translator.newLine());
		result.push("</slot>");
	},
	/**
	 * Translate html item
	 */
	OpHtmlItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			this.OpAssign(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlTag)
		{
			this.OpHtmlTag(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlContent)
		{
			this.OpHtmlContent(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlSlot)
		{
			this.OpHtmlSlot(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall && op_code.is_html)
		{
			result.push("%render ");
			this.translator.expression.translate(op_code, result);
			result.push(";");
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (op_code.kind == "raw")
			{
				result.push("@raw{{ ");
				this.translator.expression.translate(op_code.value, result);
				result.push(" }}");
			}
			else
			{
				result.push("{{ ");
				this.translator.expression.translate(op_code.value, result);
				result.push(" }}");
			}
		}
		else
		{
			result.push("{{ ");
			this.translator.expression.translate(op_code, result);
			result.push(" }}");
		}
	},
	/**
	 * Translate html items
	 */
	OpHtmlItems: function(op_code, result, is_multiline)
	{
		if (is_multiline == undefined) is_multiline = true;
		var items_count = op_code.items.count();
		for (var i = 0; i < items_count; i++)
		{
			if (is_multiline)
			{
				result.push(this.translator.newLine());
			}
			this.OpHtmlItem(op_code.items.get(i), result);
		}
	},
	/**
	 * Translate template
	 */
	translateTemplate: function(op_code, result)
	{
		if (!op_code.is_html)
		{
			return ;
		}
		/* Begin template */
		if (op_code.name == "render")
		{
			result.push("<template>");
		}
		else
		{
			var args_content = Runtime.Vector.from([]);
			if (op_code.args && op_code.args.count() > 0)
			{
				this.translator.program.OpDeclareFunctionArgs(op_code, args_content);
			}
			var args = Runtime.rs.join("", args_content);
			if (args != "")
			{
				args = " args=\"" + Runtime.rtl.toStr(args) + Runtime.rtl.toStr("\"");
			}
			result.push("<template name=\"" + Runtime.rtl.toStr(op_code.name) + Runtime.rtl.toStr("\"") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(">"));
		}
		/* Items */
		this.translator.levelInc();
		this.OpHtmlItems(op_code.expression, result);
		this.translator.levelDec();
		/* End template */
		result.push(this.translator.newLine());
		result.push("</template>");
		result.push(this.translator.newLine());
	},
	/**
	 * Translate class item
	 */
	translateClassItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			this.translateTemplate(op_code, result);
		}
	},
	/**
	 * Translate style
	 */
	translateStyle: function(op_code, result)
	{
		if (op_code.is_global)
		{
			result.push("<style global=\"true\">");
		}
		else
		{
			result.push("<style>");
		}
		result.push(this.translator.newLine());
		if (op_code.content)
		{
			result.push(op_code.content);
			result.push(this.translator.newLine());
		}
		result.push("</style>");
		result.push(this.translator.newLine());
	},
	/**
	 * Translate class
	 */
	translateClassBody: function(op_code, result)
	{
		if (op_code.items.count() == 0)
		{
			return ;
		}
		/* Get styles */
		var styles = op_code.items.filter((op_code) =>
		{
			return op_code instanceof BayLang.OpCodes.OpHtmlStyle;
		});
		/* Translate styles */
		for (var i = 0; i < styles.count(); i++)
		{
			result.push(this.translator.newLine());
			var op_code_item = styles.get(i);
			this.translateStyle(op_code_item, result);
		}
		/* Get templates */
		var templates = op_code.items.filter((op_code) =>
		{
			return op_code instanceof BayLang.OpCodes.OpDeclareFunction && op_code.is_html;
		});
		/* Translate template */
		for (var i = 0; i < templates.count(); i++)
		{
			result.push(this.translator.newLine());
			var op_code_item = templates.get(i);
			this.translateClassItem(op_code_item, result);
		}
		/* Get scripts */
		var scripts = op_code.items.filter((op_code) =>
		{
			return op_code instanceof BayLang.OpCodes.OpAnnotation || op_code instanceof BayLang.OpCodes.OpAssign || op_code instanceof BayLang.OpCodes.OpDeclareFunction && !op_code.is_html && !(op_code.name == "components");
		});
		/* Translate scripts */
		if (scripts.count() > 0)
		{
			result.push(this.translator.newLine());
			result.push("<script>");
			result.push(this.translator.newLine());
			result.push(this.translator.newLine());
			for (var i = 0; i < scripts.count(); i++)
			{
				var op_code_item = scripts.get(i);
				this.translator.program.translateClassItem(op_code_item, result);
				result.push(this.translator.newLine());
			}
			result.push(this.translator.newLine());
			result.push("</script>");
			result.push(this.translator.newLine());
		}
	},
	/**
	 * Translate
	 */
	translate: function(op_code, result)
	{
		var space = op_code.items.findItem(Runtime.lib.isInstance("BayLang.OpCodes.OpNamespace"));
		var component = op_code.items.findItem(Runtime.lib.isInstance("BayLang.OpCodes.OpDeclareClass"));
		var uses = op_code.items.filter(Runtime.lib.isInstance("BayLang.OpCodes.OpUse"));
		if (!component)
		{
			return ;
		}
		/* Get component name */
		var component_names = Runtime.Vector.from([]);
		if (space)
		{
			component_names.push(space.name);
		}
		component_names.push(component.name);
		var component_name = Runtime.rs.join(".", component_names);
		result.push("<class name=\"" + Runtime.rtl.toStr(component_name) + Runtime.rtl.toStr("\">"));
		result.push(this.translator.newLine());
		/* Add uses */
		if (uses.count() > 0)
		{
			result.push(this.translator.newLine());
			for (var i = 0; i < uses.count(); i++)
			{
				var use_item = uses.get(i);
				this.OpUse(use_item, result);
				result.push(this.translator.newLine());
			}
		}
		/* Declare class */
		this.translateClassBody(component, result);
		if (component.items.count() > 0 || uses.count() > 0)
		{
			result.push(this.translator.newLine());
		}
		result.push("</class>");
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.translator = null;
	},
});
Object.assign(BayLang.LangBay.TranslatorBayHtml, Runtime.BaseObject);
Object.assign(BayLang.LangBay.TranslatorBayHtml,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.TranslatorBayHtml";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.TranslatorBayHtml);
window["BayLang.LangBay.TranslatorBayHtml"] = BayLang.LangBay.TranslatorBayHtml;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.TranslatorBayHtml;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.TranslatorBayOperator = function(translator)
{
	Runtime.BaseObject.call(this);
	this.translator = translator;
};
BayLang.LangBay.TranslatorBayOperator.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.TranslatorBayOperator.prototype.constructor = BayLang.LangBay.TranslatorBayOperator;
Object.assign(BayLang.LangBay.TranslatorBayOperator.prototype,
{
	/**
	 * OpAssign
	 */
	OpAssign: function(op_code, result)
	{
		if (op_code.pattern)
		{
			this.translator.expression.OpTypeIdentifier(op_code.pattern, result);
		}
		var values_count = op_code.values.count();
		for (var i = 0; i < values_count; i++)
		{
			var op_code_value = op_code.values.get(i);
			if (op_code.pattern || i > 0)
			{
				result.push(" ");
			}
			if (op_code_value.op_code)
			{
				this.translator.expression.translate(op_code_value.op_code, result);
			}
			else
			{
				result.push(op_code_value.var_name);
			}
			if (op_code_value.expression)
			{
				result.push(" = ");
				this.translator.expression.translate(op_code_value.expression, result);
			}
			if (i < values_count - 1)
			{
				result.push(",");
			}
		}
	},
	/**
	 * OpBreak
	 */
	OpBreak: function(op_code, result)
	{
		result.push("break");
	},
	/**
	 * OpContinue
	 */
	OpContinue: function(op_code, result)
	{
		result.push("continue");
	},
	/**
	 * OpReturn
	 */
	OpReturn: function(op_code, result)
	{
		result.push("return");
		if (op_code.expression)
		{
			result.push(" ");
			this.translator.expression.translate(op_code.expression, result);
		}
	},
	/**
	 * OpInc
	 */
	OpInc: function(op_code, result)
	{
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_INC)
		{
			result.push("++");
			this.translator.expression.translate(op_code.value, result);
		}
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_DEC)
		{
			result.push("--");
			this.translator.expression.translate(op_code.value, result);
		}
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_INC)
		{
			this.translator.expression.translate(op_code.value, result);
			result.push("++");
		}
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_DEC)
		{
			this.translator.expression.translate(op_code.value, result);
			result.push("--");
		}
	},
	/**
	 * OpFor
	 */
	OpFor: function(op_code, result)
	{
		result.push("for (");
		this.translateItem(op_code.expr1, result);
		result.push("; ");
		this.translator.expression.translate(op_code.expr2, result);
		result.push("; ");
		this.translateItem(op_code.expr3, result);
		result.push(")");
		result.push(this.translator.newLine());
		this.translateItems(op_code.value, result);
	},
	/**
	 * OpIf
	 */
	OpIf: function(op_code, result)
	{
		result.push("if (");
		this.translator.expression.translate(op_code.condition, result);
		result.push(")");
		result.push(this.translator.newLine());
		this.translateItems(op_code.if_true, result);
		if (op_code.if_else && op_code.if_else.count() > 0)
		{
			for (var i = 0; i < op_code.if_else.count(); i++)
			{
				var op_code_item = op_code.if_else.get(i);
				result.push(this.translator.newLine());
				result.push("else if (");
				this.translator.expression.translate(op_code_item.condition, result);
				result.push(")");
				result.push(this.translator.newLine());
				this.translateItems(op_code_item.if_true, result);
			}
		}
		if (op_code.if_false)
		{
			result.push(this.translator.newLine());
			result.push("else");
			result.push(this.translator.newLine());
			this.translateItems(op_code.if_false, result);
		}
	},
	/**
	 * OpThrow
	 */
	OpThrow: function(op_code, result)
	{
		result.push("throw ");
		this.translator.expression.translate(op_code.expression, result);
	},
	/**
	 * OpTryCatch
	 */
	OpTryCatch: function(op_code, result)
	{
		result.push("try");
		result.push(this.translator.newLine());
		this.translateItems(op_code.op_try, result);
		if (op_code.items && op_code.items.count() > 0)
		{
			var items_count = op_code.items.count();
			for (var i = 0; i < items_count; i++)
			{
				var op_code_item = op_code.items.get(i);
				result.push(this.translator.newLine());
				result.push("catch (");
				this.translator.expression.OpTypeIdentifier(op_code_item.pattern, result);
				result.push(" ");
				result.push(op_code_item.name);
				result.push(")");
				result.push(this.translator.newLine());
				this.translateItems(op_code_item.value, result);
			}
		}
	},
	/**
	 * OpWhile
	 */
	OpWhile: function(op_code, result)
	{
		result.push("while (");
		this.translator.expression.translate(op_code.condition, result);
		result.push(")");
		result.push(this.translator.newLine());
		this.translateItems(op_code.value, result);
	},
	/**
	 * OpComment
	 */
	OpComment: function(op_code, result)
	{
		result.push("/*");
		result.push(op_code.value);
		result.push("*/");
	},
	/**
	 * Translate item
	 */
	translateItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			this.OpAssign(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpBreak)
		{
			this.OpBreak(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			this.translator.expression.OpCall(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpContinue)
		{
			this.OpContinue(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpReturn)
		{
			this.OpReturn(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpInc)
		{
			this.OpInc(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpFor)
		{
			this.OpFor(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpIf)
		{
			this.OpIf(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpThrow)
		{
			this.OpThrow(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTryCatch)
		{
			this.OpTryCatch(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpWhile)
		{
			this.OpWhile(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpComment)
		{
			this.OpComment(op_code, result);
		}
		else
		{
			return false;
		}
		return true;
	},
	/**
	 * Translate OpItems
	 */
	translateItems: function(op_code, result)
	{
		if (op_code.items.count() == 0)
		{
			result.push("{");
			result.push("}");
			return ;
		}
		/* Begin bracket */
		result.push("{");
		this.translator.levelInc();
		/* Items */
		var items_count = op_code.items.count();
		for (var i = 0; i < items_count; i++)
		{
			var op_code_item = op_code.items.get(i);
			var result_items = Runtime.Vector.from([]);
			var flag = this.translateItem(op_code_item, result_items);
			if (flag)
			{
				result.push(this.translator.newLine());
				result.appendItems(result_items);
				if (op_code_item instanceof BayLang.OpCodes.OpAssign || op_code_item instanceof BayLang.OpCodes.OpBreak || op_code_item instanceof BayLang.OpCodes.OpCall || op_code_item instanceof BayLang.OpCodes.OpContinue || op_code_item instanceof BayLang.OpCodes.OpInc || op_code_item instanceof BayLang.OpCodes.OpReturn || op_code_item instanceof BayLang.OpCodes.OpThrow)
				{
					result.push(";");
				}
			}
		}
		/* End bracket */
		this.translator.levelDec();
		result.push(this.translator.newLine());
		result.push("}");
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.translator = null;
	},
});
Object.assign(BayLang.LangBay.TranslatorBayOperator, Runtime.BaseObject);
Object.assign(BayLang.LangBay.TranslatorBayOperator,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.TranslatorBayOperator";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.TranslatorBayOperator);
window["BayLang.LangBay.TranslatorBayOperator"] = BayLang.LangBay.TranslatorBayOperator;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.TranslatorBayOperator;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangBay == 'undefined') BayLang.LangBay = {};
BayLang.LangBay.TranslatorBayProgram = function(translator)
{
	Runtime.BaseObject.call(this);
	this.translator = translator;
};
BayLang.LangBay.TranslatorBayProgram.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.LangBay.TranslatorBayProgram.prototype.constructor = BayLang.LangBay.TranslatorBayProgram;
Object.assign(BayLang.LangBay.TranslatorBayProgram.prototype,
{
	/**
	 * OpNamespace
	 */
	OpNamespace: function(op_code, result)
	{
		result.push("namespace ");
		result.push(op_code.name);
		result.push(";");
		result.push(this.translator.newLine());
	},
	/**
	 * OpUse
	 */
	OpUse: function(op_code, result)
	{
		var items = Runtime.rs.split(".", op_code.name);
		var last_name = items.last();
		result.push("use ");
		result.push(op_code.name);
		if (op_code.alias != "" && op_code.alias != last_name)
		{
			result.push(" as ");
			result.push(op_code.alias);
		}
		result.push(";");
	},
	/**
	 * OpAnnotation
	 */
	OpAnnotation: function(op_code, result)
	{
		result.push("@");
		this.translator.expression.OpTypeIdentifier(op_code.name, result);
		this.translator.expression.OpDict(op_code.params, result);
	},
	/**
	 * OpAssign
	 */
	OpAssign: function(op_code, result)
	{
		this.translator.operator.OpAssign(op_code, result);
		result.push(";");
	},
	/**
	 * OpDeclareFunctionArg
	 */
	OpDeclareFunctionArg: function(op_code, result)
	{
		this.translator.expression.OpTypeIdentifier(op_code.pattern, result);
		result.push(" ");
		result.push(op_code.name);
		if (op_code.expression)
		{
			result.push(" = ");
			this.translator.expression.translate(op_code.expression, result);
		}
	},
	/**
	 * OpDeclareFunctionArgs
	 */
	OpDeclareFunctionArgs: function(op_code, result)
	{
		if (op_code.args && op_code.args.count() > 0)
		{
			var args_count = op_code.args.count();
			for (var i = 0; i < args_count; i++)
			{
				var op_code_item = op_code.args.get(i);
				this.OpDeclareFunctionArg(op_code_item, result);
				if (i < args_count - 1)
				{
					result.push(", ");
				}
			}
		}
	},
	/**
	 * OpDeclareFunction
	 */
	OpDeclareFunction: function(op_code, result)
	{
		if (!(op_code.result_type instanceof BayLang.OpCodes.OpTypeIdentifier))
		{
			return ;
		}
		/* Function flags */
		var flags = Runtime.Vector.from(["async","static","pure"]);
		flags = flags.filter((flag_name) =>
		{
			return op_code.flags.isFlag(flag_name);
		});
		result.push(Runtime.rs.join(" ", flags));
		if (flags.count() > 0)
		{
			result.push(" ");
		}
		/* Function result type */
		this.translator.expression.OpTypeIdentifier(op_code.result_type, result);
		/* Function name */
		result.push(" ");
		result.push(op_code.name);
		/* Arguments */
		result.push("(");
		this.OpDeclareFunctionArgs(op_code, result);
		result.push(")");
		/* Expression */
		if (op_code.expression)
		{
			var is_multiline = op_code.expression.isMultiLine();
			if (is_multiline)
			{
				result.push(" =>");
				result.push(this.translator.newLine());
			}
			else
			{
				result.push(" => ");
			}
			this.translator.expression.translate(op_code.expression, result);
			result.push(";");
		}
		else if (op_code.items)
		{
			if (op_code.items.items.count() > 0)
			{
				result.push(this.translator.newLine());
			}
			this.translator.operator.translateItems(op_code.items, result);
		}
	},
	/**
	 * Translate class item
	 */
	translateClassItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpAnnotation)
		{
			this.OpAnnotation(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			this.OpAssign(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			this.OpDeclareFunction(op_code, result);
		}
		else
		{
			return false;
		}
		return true;
	},
	/**
	 * Translate class body
	 */
	translateClassBody: function(op_code, result)
	{
		/* Begin bracket */
		result.push("{");
		this.translator.levelInc();
		/* Class body items */
		var next_new_line = true;
		for (var i = 0; i < op_code.items.count(); i++)
		{
			if (next_new_line)
			{
				result.push(this.translator.newLine());
			}
			var op_code_item = op_code.items.get(i);
			next_new_line = this.translateClassItem(op_code_item, result);
		}
		/* End bracket */
		this.translator.levelDec();
		result.push(this.translator.newLine());
		result.push("}");
	},
	/**
	 * Translate class
	 */
	translateClass: function(op_code, result)
	{
		if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_CLASS)
		{
			result.push("class ");
		}
		else if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			result.push("interface ");
		}
		else if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
		{
			result.push("struct ");
		}
		/* Class name */
		result.push(op_code.name);
		/* Template */
		if (op_code.template)
		{
			this.translator.expression.OpTypeTemplate(op_code.template, result);
		}
		/* Extends */
		if (op_code.class_extends)
		{
			result.push(" extends ");
			this.translator.expression.OpTypeIdentifier(op_code.class_extends, result);
		}
		/* Implements */
		if (op_code.class_implements)
		{
			result.push(" implements ");
			var items_count = op_code.class_implements.count();
			for (var i = 0; i < items_count; i++)
			{
				var op_code_item = op_code.class_implements.get(i);
				this.translator.expression.OpTypeIdentifier(op_code_item, result);
				if (i < items_count - 1)
				{
					result.push(", ");
				}
			}
		}
		result.push(this.translator.newLine());
		this.translateClassBody(op_code, result);
	},
	/**
	 * Translate item
	 */
	translateItem: function(op_code, result)
	{
		if (op_code instanceof BayLang.OpCodes.OpDeclareClass)
		{
			this.translateClass(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNamespace)
		{
			this.OpNamespace(op_code, result);
		}
		else if (op_code instanceof BayLang.OpCodes.OpUse)
		{
			this.OpUse(op_code, result);
		}
	},
	/**
	 * Translate items
	 */
	translateItems: function(items, result)
	{
		var op_code_use_count = 0;
		var prev_op_code_use = false;
		for (var i = 0; i < items.count(); i++)
		{
			var op_code_item = items.get(i);
			if (i > 0)
			{
				result.push(this.translator.newLine());
			}
			if (op_code_item instanceof BayLang.OpCodes.OpDeclareClass && op_code_use_count > 0)
			{
				result.push(this.translator.newLine());
				if (op_code_use_count > 1)
				{
					result.push(this.translator.newLine());
				}
			}
			if (op_code_item instanceof BayLang.OpCodes.OpUse)
			{
				op_code_use_count++;
			}
			else
			{
				op_code_use_count = 0;
			}
			this.translateItem(items.get(i), result);
		}
	},
	/**
	 * Translate
	 */
	translate: function(op_code, result)
	{
		this.translateItems(op_code.items, result);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.translator = null;
	},
});
Object.assign(BayLang.LangBay.TranslatorBayProgram, Runtime.BaseObject);
Object.assign(BayLang.LangBay.TranslatorBayProgram,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangBay";
	},
	getClassName: function()
	{
		return "BayLang.LangBay.TranslatorBayProgram";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangBay.TranslatorBayProgram);
window["BayLang.LangBay.TranslatorBayProgram"] = BayLang.LangBay.TranslatorBayProgram;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangBay.TranslatorBayProgram;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.AsyncAwait = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.LangES6.AsyncAwait.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.LangES6.AsyncAwait.prototype.constructor = BayLang.LangES6.AsyncAwait;
Object.assign(BayLang.LangES6.AsyncAwait.prototype,
{
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.start_pos = "";
		this.end_pos = "";
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "start_pos")return this.start_pos;
		else if (k == "end_pos")return this.end_pos;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.AsyncAwait, Runtime.BaseStruct);
Object.assign(BayLang.LangES6.AsyncAwait,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.AsyncAwait";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("start_pos");
		a.push("end_pos");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.AsyncAwait);
window["BayLang.LangES6.AsyncAwait"] = BayLang.LangES6.AsyncAwait;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.AsyncAwait;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6 = function()
{
	BayLang.CoreTranslator.apply(this, arguments);
};
BayLang.LangES6.TranslatorES6.prototype = Object.create(BayLang.CoreTranslator.prototype);
BayLang.LangES6.TranslatorES6.prototype.constructor = BayLang.LangES6.TranslatorES6;
Object.assign(BayLang.LangES6.TranslatorES6.prototype,
{
	/**
	 * Returns true if emulate async await
	 */
	isEmulateAsyncAwait: function()
	{
		return this.enable_async_await && this.emulate_async_await;
	},
	/**
	 * Returns true if async await
	 */
	isAsyncAwait: function()
	{
		return this.enable_async_await && !this.emulate_async_await;
	},
	_init: function()
	{
		BayLang.CoreTranslator.prototype._init.call(this);
		this.is_pipe = false;
		this.is_call = false;
		this.pipe_var_name = "";
		this.html_var_name = "";
		this.is_html = false;
		this.async_await = null;
		this.expression = null;
		this.html = null;
		this.operator = null;
		this.program = null;
		this.debug_component = null;
		this.frontend = true;
		this.backend = false;
		this.use_module_name = false;
		this.use_strict = true;
		this.enable_async_await = true;
		this.emulate_async_await = false;
		this.enable_context = false;
		this.enable_check_types = false;
		this.enable_introspection = true;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "is_pipe")return this.is_pipe;
		else if (k == "is_call")return this.is_call;
		else if (k == "pipe_var_name")return this.pipe_var_name;
		else if (k == "html_var_name")return this.html_var_name;
		else if (k == "is_html")return this.is_html;
		else if (k == "async_await")return this.async_await;
		else if (k == "expression")return this.expression;
		else if (k == "html")return this.html;
		else if (k == "operator")return this.operator;
		else if (k == "program")return this.program;
		else if (k == "debug_component")return this.debug_component;
		else if (k == "frontend")return this.frontend;
		else if (k == "backend")return this.backend;
		else if (k == "use_module_name")return this.use_module_name;
		else if (k == "use_strict")return this.use_strict;
		else if (k == "enable_async_await")return this.enable_async_await;
		else if (k == "emulate_async_await")return this.emulate_async_await;
		else if (k == "enable_context")return this.enable_context;
		else if (k == "enable_check_types")return this.enable_check_types;
		else if (k == "enable_introspection")return this.enable_introspection;
		return BayLang.CoreTranslator.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.TranslatorES6, BayLang.CoreTranslator);
Object.assign(BayLang.LangES6.TranslatorES6,
{
	/**
	 * Reset translator
	 */
	reset: function(t)
	{
		return t.copy(Runtime.Map.from({"value":"","current_namespace_name":"","debug_component":Runtime.Vector.from([]),"modules":new Runtime.Dict(),"async_await":new BayLang.LangES6.TranslatorES6AsyncAwait(),"expression":new BayLang.LangES6.TranslatorES6Expression(),"html":new BayLang.LangES6.TranslatorES6Html(),"operator":new BayLang.LangES6.TranslatorES6Operator(),"program":new BayLang.LangES6.TranslatorES6Program(),"save_vars":new Runtime.Collection(),"save_op_codes":new Runtime.Collection(),"save_op_code_inc":0,"preprocessor_flags":Runtime.Map.from({"ES6":true,"JAVASCRIPT":true,"FRONTEND":t.frontend,"BACKEND":t.backend,"USE_MODULE_NAME":t.use_module_name,"USE_STRICT":t.use_strict,"ENABLE_ASYNC_AWAIT":t.enable_async_await,"EMULATE_ASYNC_AWAIT":t.emulate_async_await,"ENABLE_CONTEXT":t.enable_context,"ENABLE_CHECK_TYPES":t.enable_check_types})}));
	},
	/**
	 * Translate BaseOpCode
	 */
	translate: function(t, op_code)
	{
		return t.program.constructor.translateProgram(t, op_code);
	},
	/**
	 * Output save op code content
	 */
	outputSaveOpCode: function(t, save_op_code_value)
	{
		if (save_op_code_value == undefined) save_op_code_value = 0;
		var content = "";
		for (var i = 0; i < t.save_op_codes.count(); i++)
		{
			if (i < save_op_code_value)
			{
				continue;
			}
			var save = t.save_op_codes.item(i);
			var s = "";
			if (t.is_html)
			{
				s = (save.content == "") ? (t.s("let " + Runtime.rtl.toStr(save.var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(save.var_content) + Runtime.rtl.toStr(";"))) : (save.content);
			}
			else
			{
				s = (save.content == "") ? (t.s("var " + Runtime.rtl.toStr(save.var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(save.var_content) + Runtime.rtl.toStr(";"))) : (save.content);
			}
			content += Runtime.rtl.toStr(s);
		}
		return content;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6";
	},
	getParentClassName: function()
	{
		return "BayLang.CoreTranslator";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("is_pipe");
		a.push("is_call");
		a.push("pipe_var_name");
		a.push("html_var_name");
		a.push("is_html");
		a.push("async_await");
		a.push("expression");
		a.push("html");
		a.push("operator");
		a.push("program");
		a.push("debug_component");
		a.push("frontend");
		a.push("backend");
		a.push("use_module_name");
		a.push("use_strict");
		a.push("enable_async_await");
		a.push("emulate_async_await");
		a.push("enable_context");
		a.push("enable_check_types");
		a.push("enable_introspection");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6);
window["BayLang.LangES6.TranslatorES6"] = BayLang.LangES6.TranslatorES6;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6AsyncAwait = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.LangES6.TranslatorES6AsyncAwait.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.LangES6.TranslatorES6AsyncAwait.prototype.constructor = BayLang.LangES6.TranslatorES6AsyncAwait;
Object.assign(BayLang.LangES6.TranslatorES6AsyncAwait.prototype,
{
	_init: function()
	{
		Runtime.BaseStruct.prototype._init.call(this);
		this.async_stack = new Runtime.Collection();
		this.pos = Runtime.Vector.from([0]);
		this.async_t = "__async_t";
		this.async_var = "__async_var";
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "async_stack")return this.async_stack;
		else if (k == "pos")return this.pos;
		else if (k == "async_t")return this.async_t;
		else if (k == "async_var")return this.async_var;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.TranslatorES6AsyncAwait, Runtime.BaseStruct);
Object.assign(BayLang.LangES6.TranslatorES6AsyncAwait,
{
	/**
	 * Returns current pos
	 */
	currentPos: function(t)
	{
		return t.expression.constructor.toString(Runtime.rs.join(".", t.async_await.pos));
	},
	/**
	 * Returns current pos
	 */
	nextPos: function(t)
	{
		var pos = t.async_await.pos;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), pos.setIm(pos.count() - 1, pos.last() + 1));
		var res = t.expression.constructor.toString(Runtime.rs.join(".", t.async_await.pos));
		return Runtime.Vector.from([t,res]);
	},
	/**
	 * Returns push pos
	 */
	pushPos: function(t)
	{
		var pos = t.async_await.pos;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), pos.setIm(pos.count() - 1, pos.last() + 1).pushIm(0));
		var res = t.expression.constructor.toString(Runtime.rs.join(".", t.async_await.pos));
		return Runtime.Vector.from([t,res]);
	},
	/**
	 * Returns inc pos
	 */
	levelIncPos: function(t)
	{
		var pos = t.async_await.pos;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), pos.setIm(pos.count() - 1, pos.last()).pushIm(0));
		var res = t.expression.constructor.toString(Runtime.rs.join(".", t.async_await.pos));
		return Runtime.Vector.from([t,res]);
	},
	/**
	 * Returns pop pos
	 */
	popPos: function(t)
	{
		var pos = t.async_await.pos.removeLastIm();
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), pos.setIm(pos.count() - 1, pos.last() + 1));
		var res = t.expression.constructor.toString(Runtime.rs.join(".", t.async_await.pos));
		return Runtime.Vector.from([t,res]);
	},
	/**
	 * OpCall
	 */
	OpCall: function(t, op_code, is_expression)
	{
		if (is_expression == undefined) is_expression = true;
		var s = "";
		var flag = false;
		if (s == "")
		{
			var res = t.expression.constructor.Dynamic(t, op_code.obj);
			t = Runtime.rtl.attr(res, 0);
			s = Runtime.rtl.attr(res, 1);
			if (s == "parent")
			{
				s = t.expression.constructor.useModuleName(t, t.current_class_extends_name);
				if (t.current_function.name != "constructor")
				{
					if (t.current_function.isStatic())
					{
						s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(t.current_function.name));
					}
					else
					{
						s += Runtime.rtl.toStr(".prototype." + Runtime.rtl.toStr(t.current_function.name));
					}
				}
				s += Runtime.rtl.toStr(".call(this");
				flag = true;
			}
			else
			{
				s += Runtime.rtl.toStr("(");
			}
		}
		var content = s;
		if (t.current_function.is_context && op_code.is_context)
		{
			content += Runtime.rtl.toStr("ctx");
			flag = true;
		}
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = t.expression.constructor.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		var res = t.constructor.incSaveOpCode(t);
		t = Runtime.rtl.attr(res, 0);
		var var_name = Runtime.rtl.attr(res, 1);
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var next_pos = Runtime.rtl.attr(res, 1);
		var async_t = t.async_await.async_t;
		content = t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(next_pos) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr(".call(") + Runtime.rtl.toStr(content) + Runtime.rtl.toStr(",") + Runtime.rtl.toStr(t.expression.constructor.toString(var_name)) + Runtime.rtl.toStr(");"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(next_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"op_code":op_code,"var_name":var_name,"content":content}));
		t = Runtime.rtl.attr(res, 0);
		if (is_expression)
		{
			return Runtime.Vector.from([t,async_t + Runtime.rtl.toStr(".getVar(") + Runtime.rtl.toStr(t.expression.constructor.toString(var_name)) + Runtime.rtl.toStr(")")]);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * OpPipe
	 */
	OpPipe: function(t, op_code, is_expression)
	{
		if (is_expression == undefined) is_expression = true;
		var content = "";
		var var_name = "";
		var flag = false;
		var res = t.expression.constructor.Expression(t, op_code.obj);
		t = Runtime.rtl.attr(res, 0);
		var_name = Runtime.rtl.attr(res, 1);
		if (op_code.kind == BayLang.OpCodes.OpPipe.KIND_METHOD)
		{
			content = var_name + Runtime.rtl.toStr(".constructor.") + Runtime.rtl.toStr(op_code.method_name.value);
		}
		else
		{
			var res = t.expression.constructor.OpTypeIdentifier(t, op_code.class_name);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(op_code.method_name.value);
		}
		var flag = false;
		content += Runtime.rtl.toStr("(");
		if (t.current_function.is_context && op_code.is_context)
		{
			content += Runtime.rtl.toStr("ctx");
			flag = true;
		}
		content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(var_name));
		flag = true;
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = t.expression.constructor.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s1 = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s1));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		var res = t.constructor.incSaveOpCode(t);
		t = Runtime.rtl.attr(res, 0);
		var var_name = Runtime.rtl.attr(res, 1);
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var next_pos = Runtime.rtl.attr(res, 1);
		var async_t = t.async_await.async_t;
		content = t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(next_pos) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr(".call(") + Runtime.rtl.toStr(content) + Runtime.rtl.toStr(",") + Runtime.rtl.toStr(t.expression.constructor.toString(var_name)) + Runtime.rtl.toStr(");"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(next_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"op_code":op_code,"var_name":var_name,"content":content}));
		t = Runtime.rtl.attr(res, 0);
		if (is_expression)
		{
			return Runtime.Vector.from([t,async_t + Runtime.rtl.toStr(".getVar(") + Runtime.rtl.toStr(t.expression.constructor.toString(var_name)) + Runtime.rtl.toStr(")")]);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * OpFor
	 */
	OpFor: function(t, op_code)
	{
		var save_t = null;
		var async_t = t.async_await.async_t;
		var async_var = t.async_await.async_var;
		var content = "";
		var res = this.pushPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_pos = Runtime.rtl.attr(res, 1);
		var res = this.popPos(t);
		save_t = Runtime.rtl.attr(res, 0);
		var end_pos = Runtime.rtl.attr(res, 1);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.pushIm(new BayLang.LangES6.AsyncAwait(Runtime.Map.from({"start_pos":start_pos,"end_pos":end_pos}))));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Start Loop */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Loop Assign */
		if (op_code.expr1 instanceof BayLang.OpCodes.OpAssign)
		{
			var res = t.constructor.saveOpCodeCall(t, Runtime.rtl.method(t.operator.getClassName(), "OpAssign"), Runtime.Vector.from([op_code.expr1]));
			t = Runtime.rtl.attr(res, 0);
			var save = Runtime.rtl.attr(res, 1);
			var value = Runtime.rtl.attr(res, 2);
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			content += Runtime.rtl.toStr(value);
		}
		else
		{
			var res = t.constructor.saveOpCodeCall(t, Runtime.rtl.method(t.expression.getClassName(), "Expression"), Runtime.Vector.from([op_code.expr1]));
			t = Runtime.rtl.attr(res, 0);
			var save = Runtime.rtl.attr(res, 1);
			var value = Runtime.rtl.attr(res, 2);
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			content += Runtime.rtl.toStr(value);
		}
		/* Loop Expression */
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var loop_expression = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(loop_expression) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Loop Expression */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(loop_expression) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Call condition expression */
		var res = t.constructor.saveOpCodeCall(t, Runtime.rtl.method(t.expression.getClassName(), "Expression"), Runtime.Vector.from([op_code.expr2]));
		t = Runtime.rtl.attr(res, 0);
		var save = Runtime.rtl.attr(res, 1);
		var value = Runtime.rtl.attr(res, 2);
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		/* Loop condition */
		content += Runtime.rtl.toStr(t.s("var " + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(";")));
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_loop = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_loop) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		/* Start Loop */
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Loop */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_loop) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = t.expression.constructor.Expression(t, op_code.expr3);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";")));
		var res = t.operator.constructor.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* End Loop */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(loop_expression) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* End Loop */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.removeLastIm());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), save_t.async_await.pos);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpIfBlock
	 */
	OpIfBlock: function(t, condition, op_code, end_pos)
	{
		var content = "";
		var async_t = t.async_await.async_t;
		var async_var = t.async_await.async_var;
		/* Call condition expression */
		var res = t.constructor.saveOpCodeCall(t, Runtime.rtl.method(t.expression.getClassName(), "Expression"), Runtime.Vector.from([condition]));
		t = Runtime.rtl.attr(res, 0);
		var save = Runtime.rtl.attr(res, 1);
		var value = Runtime.rtl.attr(res, 2);
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_if = Runtime.rtl.attr(res, 1);
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var next_if = Runtime.rtl.attr(res, 1);
		/* If condition */
		content += Runtime.rtl.toStr(t.s("var " + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(";")));
		content += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_if) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(next_if) + Runtime.rtl.toStr(");")));
		/* Start Loop */
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* If true */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_if) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = t.operator.constructor.Operators(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* End if */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Next If */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(next_if) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpIf
	 */
	OpIf: function(t, op_code)
	{
		var save_t = null;
		var async_t = t.async_await.async_t;
		var async_var = t.async_await.async_var;
		var content = "";
		var if_true_pos = "";
		var if_false_pos = "";
		var res = this.pushPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_pos = Runtime.rtl.attr(res, 1);
		var res = this.popPos(t);
		save_t = Runtime.rtl.attr(res, 0);
		var end_pos = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Start if */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* If true */
		var res = this.OpIfBlock(t, op_code.condition, op_code.if_true, end_pos);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* If else */
		for (var i = 0; i < op_code.if_else.count(); i++)
		{
			var if_else = op_code.if_else.item(i);
			var res = this.OpIfBlock(t, if_else.condition, if_else.if_true, end_pos);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Else */
		if (op_code.if_false)
		{
			content += Runtime.rtl.toStr(t.s("/* If false */"));
			var res = t.operator.constructor.Operators(t, op_code.if_false);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* End if */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* End if */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), save_t.async_await.pos);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpReturn
	 */
	OpReturn: function(t, op_code)
	{
		var content = "";
		var s1 = "";
		if (op_code.expression)
		{
			var res = t.expression.constructor.Expression(t, op_code.expression);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		else
		{
			s1 = "null";
		}
		var async_t = t.async_await.async_t;
		content = t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".ret(") + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(");"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpTryCatch
	 */
	OpTryCatch: function(t, op_code)
	{
		var save_t = null;
		var content = "";
		var async_t = t.async_await.async_t;
		var async_var = t.async_await.async_var;
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_pos = Runtime.rtl.attr(res, 1);
		var res = this.nextPos(t);
		save_t = Runtime.rtl.attr(res, 0);
		var end_pos = Runtime.rtl.attr(res, 1);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.pushIm(new BayLang.LangES6.AsyncAwait(Runtime.Map.from({"start_pos":start_pos,"end_pos":end_pos}))));
		/* Start Try Catch */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Start Try */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.levelIncPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_catch = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s(async_t + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".catch_push(") + Runtime.rtl.toStr(start_catch) + Runtime.rtl.toStr(");")));
		var res = t.operator.constructor.Operators(t, op_code.op_try);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Start Catch */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".catch_pop().jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Start Catch */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_catch) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("var _ex = " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".getErr();")));
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var s = "";
			var pattern = "";
			var item = op_code.items.item(i);
			var res = t.expression.constructor.OpTypeIdentifier(t, item.pattern);
			t = Runtime.rtl.attr(res, 0);
			pattern += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			if (pattern != "var")
			{
				s = "if (_ex instanceof " + Runtime.rtl.toStr(pattern) + Runtime.rtl.toStr(")");
			}
			else
			{
				s = "if (true)";
			}
			s += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			s += Runtime.rtl.toStr((s != "") ? (t.s("var " + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = _ex;"))) : ("var " + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = _ex;")));
			var res = t.operator.constructor.Operators(t, item.value);
			t = Runtime.rtl.attr(res, 0);
			s += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			s += Runtime.rtl.toStr(t.s("}"));
			if (i != 0)
			{
				s = "else " + Runtime.rtl.toStr(s);
			}
			content += Runtime.rtl.toStr(t.s(s));
		}
		content += Runtime.rtl.toStr(t.s("else"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("throw _ex;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		/* End Try Catch */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* End Catch */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.removeLastIm());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), save_t.async_await.pos);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpWhile
	 */
	OpWhile: function(t, op_code)
	{
		var save_t = null;
		var async_t = t.async_await.async_t;
		var async_var = t.async_await.async_var;
		var content = "";
		var res = this.pushPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_pos = Runtime.rtl.attr(res, 1);
		var res = this.popPos(t);
		save_t = Runtime.rtl.attr(res, 0);
		var end_pos = Runtime.rtl.attr(res, 1);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.pushIm(new BayLang.LangES6.AsyncAwait(Runtime.Map.from({"start_pos":start_pos,"end_pos":end_pos}))));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Start while */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Call condition expression */
		var res = t.constructor.saveOpCodeCall(t, Runtime.rtl.method(t.expression.getClassName(), "Expression"), Runtime.Vector.from([op_code.condition]));
		t = Runtime.rtl.attr(res, 0);
		var save = Runtime.rtl.attr(res, 1);
		var value = Runtime.rtl.attr(res, 2);
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		/* Loop condition */
		content += Runtime.rtl.toStr(t.s("var " + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(";")));
		var res = this.nextPos(t);
		t = Runtime.rtl.attr(res, 0);
		var start_loop = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(async_var) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_loop) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(");")));
		/* Start Loop */
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* Loop while */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(start_loop) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = t.operator.constructor.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* End Loop */
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".jump(") + Runtime.rtl.toStr(start_pos) + Runtime.rtl.toStr(");")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("/* End while */"));
		content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(end_pos) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "async_stack"]), t.async_await.async_stack.removeLastIm());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["async_await", "pos"]), save_t.async_await.pos);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction Body
	 */
	OpDeclareFunctionBody: function(t, f)
	{
		var save_t = t;
		/* Save op codes */
		var save_vars = t.save_vars;
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		t = t.constructor.clearSaveOpCode(t);
		var async_t = t.async_await.async_t;
		t = t.levelInc();
		var s1 = t.s("return (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(") =>"));
		s1 += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		s1 += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".pos() == ") + Runtime.rtl.toStr(this.currentPos(t)) + Runtime.rtl.toStr(")")));
		s1 += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		if (f.items)
		{
			var res = t.operator.constructor.Operators(t, f.items);
			t = Runtime.rtl.attr(res, 0);
			s1 += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		else if (f.expression)
		{
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			var save_op_code_inc = t.save_op_code_inc;
			var res = t.expression.constructor.Expression(t, f.expression);
			t = Runtime.rtl.attr(res, 0);
			var expr = Runtime.rtl.attr(res, 1);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				s1 += Runtime.rtl.toStr(save);
			}
			/* Restore save op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
			s1 += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".ret(") + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(");")));
		}
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("}"));
		s1 += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(async_t) + Runtime.rtl.toStr(".ret_void();")));
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("};"));
		t = t.levelDec();
		/* Content */
		var content = "";
		content = t.s("{");
		t = t.levelInc();
		if (t.save_vars.count() > 0)
		{
			content += Runtime.rtl.toStr(t.s("var " + Runtime.rtl.toStr(Runtime.rs.join(",", t.save_vars)) + Runtime.rtl.toStr(";")));
		}
		content += Runtime.rtl.toStr(s1);
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_vars"]), save_vars);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([save_t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6AsyncAwait";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("async_stack");
		a.push("pos");
		a.push("async_t");
		a.push("async_var");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6AsyncAwait);
window["BayLang.LangES6.TranslatorES6AsyncAwait"] = BayLang.LangES6.TranslatorES6AsyncAwait;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6AsyncAwait;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6Expression = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.LangES6.TranslatorES6Expression.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.LangES6.TranslatorES6Expression.prototype.constructor = BayLang.LangES6.TranslatorES6Expression;
Object.assign(BayLang.LangES6.TranslatorES6Expression.prototype,
{
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.TranslatorES6Expression, Runtime.BaseStruct);
Object.assign(BayLang.LangES6.TranslatorES6Expression,
{
	/**
	 * Returns string
	 */
	toString: function(s)
	{
		s = Runtime.re.replace("\\\\", "\\\\", s);
		s = Runtime.re.replace("\"", "\\\"", s);
		s = Runtime.re.replace("\n", "\\n", s);
		s = Runtime.re.replace("\r", "\\r", s);
		s = Runtime.re.replace("\t", "\\t", s);
		return "\"" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr("\"");
	},
	/**
	 * To pattern
	 */
	toPattern: function(t, pattern)
	{
		var names = this.findModuleNames(t, pattern.entity_name.names);
		var e = Runtime.rs.join(".", names);
		var a = (pattern.template != null) ? (pattern.template.map((pattern) =>
		{
			return this.toPattern(t, pattern);
		})) : (null);
		var b = (a != null) ? (",\"t\":[" + Runtime.rtl.toStr(Runtime.rs.join(",", a)) + Runtime.rtl.toStr("]")) : ("");
		return "{\"e\":" + Runtime.rtl.toStr(this.toString(e)) + Runtime.rtl.toStr(b) + Runtime.rtl.toStr("}");
	},
	/**
	 * Returns string
	 */
	rtlToStr: function(t, s)
	{
		if (t.use_module_name)
		{
			return "use(\"Runtime.rtl\").toStr(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(")");
		}
		var module_name = this.findModuleName(t, "rtl");
		return module_name + Runtime.rtl.toStr(".toStr(") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(")");
	},
	/**
	 * Find module name
	 */
	findModuleName: function(t, module_name)
	{
		if (module_name == "Collection")
		{
			return "Runtime.Collection";
		}
		else if (module_name == "Dict")
		{
			return "Runtime.Dict";
		}
		else if (module_name == "Map")
		{
			return "Runtime.Map";
		}
		else if (module_name == "Vector")
		{
			return "Runtime.Vector";
		}
		else if (module_name == "rs")
		{
			return "Runtime.rs";
		}
		else if (module_name == "rtl")
		{
			return "Runtime.rtl";
		}
		else if (module_name == "ArrayInterface")
		{
			return "";
		}
		else if (t.modules.has(module_name))
		{
			return t.modules.item(module_name);
		}
		return module_name;
	},
	/**
	 * Returns module name
	 */
	findModuleNames: function(t, names)
	{
		if (names.count() > 0)
		{
			var module_name = names.first();
			module_name = this.findModuleName(t, module_name);
			if (module_name != "")
			{
				names = names.setIm(0, module_name);
			}
		}
		return names;
	},
	/**
	 * Use module name
	 */
	useModuleName: function(t, module_name)
	{
		module_name = this.findModuleName(t, module_name);
		if (t.use_module_name)
		{
			return "use(" + Runtime.rtl.toStr(this.toString(module_name)) + Runtime.rtl.toStr(")");
		}
		return module_name;
	},
	/**
	 * OpTypeIdentifier
	 */
	OpTypeIdentifier: function(t, op_code)
	{
		var names = this.findModuleNames(t, op_code.entity_name.names);
		var s = Runtime.rs.join(".", names);
		return Runtime.Vector.from([t,s]);
	},
	/**
	 * OpIdentifier
	 */
	OpIdentifier: function(t, op_code)
	{
		if (op_code.value == "@")
		{
			if (t.enable_context == false)
			{
				return Runtime.Vector.from([t,this.useModuleName(t, "rtl") + Runtime.rtl.toStr(".getContext()")]);
			}
			else
			{
				return Runtime.Vector.from([t,"ctx"]);
			}
		}
		if (op_code.value == "_")
		{
			if (t.enable_context == false)
			{
				return Runtime.Vector.from([t,this.useModuleName(t, "rtl") + Runtime.rtl.toStr(".getContext().translate")]);
			}
			else
			{
				return Runtime.Vector.from([t,"ctx.translate"]);
			}
		}
		if (op_code.value == "log")
		{
			return Runtime.Vector.from([t,"console.log"]);
		}
		if (t.modules.has(op_code.value) || op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE)
		{
			var module_name = op_code.value;
			var new_module_name = this.useModuleName(t, module_name);
			return Runtime.Vector.from([t,new_module_name]);
		}
		var content = op_code.value;
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNumber
	 */
	OpNumber: function(t, op_code)
	{
		var content = op_code.value;
		/*if (op_code.negative)
		{
			content = "-" ~ content;
			t <= opcode_level <= 15;
		}*/
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNegative
	 */
	OpNegative: function(t, op_code)
	{
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var content = Runtime.rtl.attr(res, 1);
		content = "-" + Runtime.rtl.toStr(content);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 15);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpString
	 */
	OpString: function(t, op_code)
	{
		return Runtime.Vector.from([t,this.toString(op_code.value)]);
	},
	/**
	 * OpCollection
	 */
	OpCollection: function(t, op_code)
	{
		var content = "";
		var values = op_code.values.map((op_code) =>
		{
			var res = this.Expression(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			return s;
		});
		values = values.filter((s) =>
		{
			return s != "";
		});
		var module_name = this.useModuleName(t, "Vector");
		content = module_name + Runtime.rtl.toStr(".from([") + Runtime.rtl.toStr(Runtime.rs.join(",", values)) + Runtime.rtl.toStr("])");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDict
	 */
	OpDict: function(t, op_code)
	{
		var content = "";
		var values = op_code.values.map((pair, key) =>
		{
			if (pair.condition != null && Runtime.rtl.attr(t.preprocessor_flags, pair.condition.value) != true)
			{
				return "";
			}
			var res = this.Expression(t, pair.value);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			return this.toString(pair.key) + Runtime.rtl.toStr(":") + Runtime.rtl.toStr(s);
		});
		values = values.filter((s) =>
		{
			return s != "";
		});
		var module_name = this.useModuleName(t, "Map");
		content = module_name + Runtime.rtl.toStr(".from({") + Runtime.rtl.toStr(Runtime.rs.join(",", values)) + Runtime.rtl.toStr("})");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Dynamic
	 */
	Dynamic: function(t, op_code, is_call)
	{
		if (is_call == undefined) is_call = false;
		if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			return this.OpIdentifier(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			var attrs = new Runtime.Vector();
			var op_code_item = op_code;
			var op_code_first = op_code;
			var first_item = "";
			var prev_kind = "";
			var s = "";
			var first_item_complex = false;
			while (op_code_first instanceof BayLang.OpCodes.OpAttr)
			{
				attrs.push(op_code_first);
				op_code_item = op_code_first;
				op_code_first = op_code_first.obj;
			}
			attrs = attrs.reverse();
			if (op_code_first instanceof BayLang.OpCodes.OpCall)
			{
				prev_kind = "var";
				var res = this.OpCall(t, op_code_first);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
				first_item_complex = true;
			}
			else if (op_code_first instanceof BayLang.OpCodes.OpNew)
			{
				prev_kind = "var";
				var res = this.OpNew(t, op_code_first);
				t = Runtime.rtl.attr(res, 0);
				s = "(" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				first_item_complex = true;
			}
			else if (op_code_first instanceof BayLang.OpCodes.OpCollection)
			{
				prev_kind = "var";
				var res = this.OpCollection(t, op_code_first);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
				first_item_complex = true;
			}
			else if (op_code_first instanceof BayLang.OpCodes.OpDict)
			{
				prev_kind = "var";
				var res = this.OpDict(t, op_code_first);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
				first_item_complex = true;
			}
			else if (op_code_first instanceof BayLang.OpCodes.OpIdentifier)
			{
				if (op_code_first.kind == BayLang.OpCodes.OpIdentifier.KIND_CLASSREF)
				{
					if (op_code_first.value == "static")
					{
						if (!t.is_static_function)
						{
							if (!t.current_class.is_component)
							{
								s = "this.constructor";
							}
							else
							{
								s = "this.$options";
							}
						}
						else
						{
							s = "this";
						}
						prev_kind = "static";
					}
					else if (op_code_first.value == "parent")
					{
						s = this.useModuleName(t, t.current_class_extends_name);
						prev_kind = "parent";
					}
					else if (op_code_first.value == "self")
					{
						prev_kind = "static";
						s = t.current_class_full_name;
					}
					else if (op_code_first.value == "this")
					{
						prev_kind = "var";
						s = "this";
					}
				}
				else if (op_code_first.kind == BayLang.OpCodes.OpIdentifier.KIND_PIPE)
				{
					prev_kind = "var";
					s = t.pipe_var_name + Runtime.rtl.toStr(".val");
				}
				else
				{
					var res = this.OpIdentifier(t, op_code_first);
					t = Runtime.rtl.attr(res, 0);
					s = Runtime.rtl.attr(res, 1);
					prev_kind = "var";
					if (t.modules.has(op_code_first.value) || op_code_first.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE)
					{
						prev_kind = "static";
					}
				}
			}
			first_item = s;
			if (first_item_complex && t.is_pipe)
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":first_item}));
				t = Runtime.rtl.attr(res, 0);
				first_item = Runtime.rtl.attr(res, 1);
				s = first_item;
			}
			var attrs_sz = attrs.count();
			for (var i = 0; i < attrs_sz; i++)
			{
				var attr = attrs.item(i);
				if (attr.kind == BayLang.OpCodes.OpAttr.KIND_ATTR)
				{
					s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(attr.value.value));
					/* Pipe */
					if (t.is_pipe && !is_call)
					{
						if (i == attrs_sz - 1)
						{
							s += Runtime.rtl.toStr(".bind(" + Runtime.rtl.toStr(first_item) + Runtime.rtl.toStr(")"));
						}
						else
						{
							first_item = s;
						}
					}
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_STATIC)
				{
					if (prev_kind == "var")
					{
						s += Runtime.rtl.toStr(".constructor." + Runtime.rtl.toStr(attr.value.value));
						first_item += Runtime.rtl.toStr(".constructor");
					}
					else if (prev_kind == "parent")
					{
						if (t.current_function.isStatic())
						{
							s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(attr.value.value) + Runtime.rtl.toStr(".bind(this)"));
						}
						else
						{
							s += Runtime.rtl.toStr(".prototype." + Runtime.rtl.toStr(attr.value.value) + Runtime.rtl.toStr(".bind(this)"));
						}
					}
					else
					{
						s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(attr.value.value));
					}
					/* Pipe */
					if (t.is_pipe && prev_kind != "parent" && !is_call)
					{
						if (i == attrs_sz - 1)
						{
							s += Runtime.rtl.toStr(".bind(" + Runtime.rtl.toStr(first_item) + Runtime.rtl.toStr(")"));
						}
						else
						{
							first_item = s;
						}
					}
					prev_kind = "static";
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC)
				{
					var res = this.Expression(t, attr.value);
					t = Runtime.rtl.attr(res, 0);
					/* s ~= "[" ~ res[1] ~ "]"; */
					s = "Runtime.rtl.attr(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS)
				{
					var items = new Runtime.Vector();
					if (attr.attrs != null)
					{
						for (var j = 0; j < attr.attrs.count(); j++)
						{
							var res = this.Expression(t, Runtime.rtl.attr(attr.attrs, j));
							t = Runtime.rtl.attr(res, 0);
							items.push(Runtime.rtl.attr(res, 1));
						}
					}
					s = "Runtime.rtl.attr(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(", [") + Runtime.rtl.toStr(Runtime.rs.join(", ", items)) + Runtime.rtl.toStr("])");
				}
			}
			return Runtime.Vector.from([t,s]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCurry)
		{
			var res = this.OpCurry(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var content = Runtime.rtl.attr(res, 1);
			var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":content}));
			t = Runtime.rtl.attr(res, 0);
			var var_name = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([t,var_name]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			return this.OpCall(t, op_code);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * OpInc
	 */
	OpInc: function(t, op_code)
	{
		var content = "";
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var s = Runtime.rtl.attr(res, 1);
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_INC)
		{
			content = "++" + Runtime.rtl.toStr(s);
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_DEC)
		{
			content = "--" + Runtime.rtl.toStr(s);
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_INC)
		{
			content = s + Runtime.rtl.toStr("++");
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_DEC)
		{
			content = s + Runtime.rtl.toStr("--");
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpMath
	 */
	OpMath: function(t, op_code)
	{
		var res = this.Expression(t, op_code.value1);
		t = Runtime.rtl.attr(res, 0);
		var opcode_level1 = Runtime.rtl.attr(res, 0).opcode_level;
		var s1 = Runtime.rtl.attr(res, 1);
		var op = "";
		var op_math = op_code.math;
		var opcode_level = 0;
		if (op_code.math == "!")
		{
			opcode_level = 16;
			op = "!";
		}
		if (op_code.math == ">>")
		{
			opcode_level = 12;
			op = ">>";
		}
		if (op_code.math == "<<")
		{
			opcode_level = 12;
			op = "<<";
		}
		if (op_code.math == "&")
		{
			opcode_level = 9;
			op = "&";
		}
		if (op_code.math == "xor")
		{
			opcode_level = 8;
			op = "^";
		}
		if (op_code.math == "|")
		{
			opcode_level = 7;
			op = "|";
		}
		if (op_code.math == "*")
		{
			opcode_level = 14;
			op = "*";
		}
		if (op_code.math == "/")
		{
			opcode_level = 14;
			op = "/";
		}
		if (op_code.math == "%")
		{
			opcode_level = 14;
			op = "%";
		}
		if (op_code.math == "div")
		{
			opcode_level = 14;
			op = "div";
		}
		if (op_code.math == "mod")
		{
			opcode_level = 14;
			op = "mod";
		}
		if (op_code.math == "+")
		{
			opcode_level = 13;
			op = "+";
		}
		if (op_code.math == "-")
		{
			opcode_level = 13;
			op = "-";
		}
		if (op_code.math == "~")
		{
			opcode_level = 13;
			op = "+";
		}
		if (op_code.math == "!")
		{
			opcode_level = 13;
			op = "!";
		}
		if (op_code.math == "===")
		{
			opcode_level = 10;
			op = "===";
		}
		if (op_code.math == "!==")
		{
			opcode_level = 10;
			op = "!==";
		}
		if (op_code.math == "==")
		{
			opcode_level = 10;
			op = "==";
		}
		if (op_code.math == "!=")
		{
			opcode_level = 10;
			op = "!=";
		}
		if (op_code.math == ">=")
		{
			opcode_level = 10;
			op = ">=";
		}
		if (op_code.math == "<=")
		{
			opcode_level = 10;
			op = "<=";
		}
		if (op_code.math == ">")
		{
			opcode_level = 10;
			op = ">";
		}
		if (op_code.math == "<")
		{
			opcode_level = 10;
			op = "<";
		}
		if (op_code.math == "is")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "instanceof")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "implements")
		{
			opcode_level = 10;
			op = "implements";
		}
		if (op_code.math == "not")
		{
			opcode_level = 16;
			op = "!";
		}
		if (op_code.math == "and")
		{
			opcode_level = 6;
			op = "&&";
		}
		if (op_code.math == "&&")
		{
			opcode_level = 6;
			op = "&&";
		}
		if (op_code.math == "or")
		{
			opcode_level = 5;
			op = "||";
		}
		if (op_code.math == "||")
		{
			opcode_level = 5;
			op = "||";
		}
		var content = "";
		if (op_code.math == "!" || op_code.math == "not")
		{
			content = op + Runtime.rtl.toStr(t.o(s1, opcode_level1, opcode_level));
		}
		else
		{
			var res = this.Expression(t, op_code.value2);
			t = Runtime.rtl.attr(res, 0);
			var opcode_level2 = Runtime.rtl.attr(res, 0).opcode_level;
			var s2 = Runtime.rtl.attr(res, 1);
			var op1 = t.o(s1, opcode_level1, opcode_level);
			var op2 = t.o(s2, opcode_level2, opcode_level);
			if (op_math == "~")
			{
				content = op1 + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(this.rtlToStr(t, op2));
			}
			else if (op_math == "implements")
			{
				var rtl_name = this.findModuleName(t, "rtl");
				content = rtl_name + Runtime.rtl.toStr(".is_implements(") + Runtime.rtl.toStr(op1) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(op2) + Runtime.rtl.toStr(")");
			}
			else
			{
				content = op1 + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(op2);
			}
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), opcode_level);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpMethod
	 */
	OpMethod: function(t, op_code)
	{
		var content = "";
		var val1 = "";
		var val2 = op_code.value2;
		var prev_kind = "";
		if (op_code.value1.kind == BayLang.OpCodes.OpIdentifier.KIND_CLASSREF)
		{
			if (op_code.value1.value == "static")
			{
				val1 = "this" + Runtime.rtl.toStr(((!t.is_static_function) ? (".constructor") : ("")));
				prev_kind = "static";
			}
			else if (op_code.value1.value == "parent")
			{
				val1 = this.useModuleName(t, t.current_class_extends_name);
				prev_kind = "parent";
			}
			else if (op_code.value1.value == "self")
			{
				prev_kind = "static";
				val1 = t.current_class_full_name;
			}
			else if (op_code.value1.value == "this")
			{
				prev_kind = "var";
				val1 = "this";
			}
		}
		else
		{
			var res = this.OpIdentifier(t, op_code.value1);
			t = Runtime.rtl.attr(res, 0);
			val1 = Runtime.rtl.attr(res, 1);
			if (op_code.kind == BayLang.OpCodes.OpMethod.KIND_STATIC)
			{
				val1 += Runtime.rtl.toStr(".constructor");
			}
		}
		content = val1 + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(val2) + Runtime.rtl.toStr(".bind(") + Runtime.rtl.toStr(val1) + Runtime.rtl.toStr(")");
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 0);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNew
	 */
	OpNew: function(t, op_code)
	{
		var content = "new ";
		var res = this.OpTypeIdentifier(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		var flag = false;
		content += Runtime.rtl.toStr("(");
		if (t.current_function == null || t.current_function.is_context)
		{
			content += Runtime.rtl.toStr("ctx");
			flag = true;
		}
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = t.expression.constructor.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpCurry
	 */
	OpCurry: function(t, op_code)
	{
		var content = "";
		var s = "";
		var args = op_code.args.filter((arg) =>
		{
			return arg instanceof BayLang.OpCodes.OpCurryArg;
		}).sort((arg1, arg2) =>
		{
			return (arg1.pos > arg2.pos) ? (1) : ((arg1.pos < arg2.pos) ? (-1) : (0));
		});
		var args_sz = args.count();
		for (var i = 0; i < args_sz; i++)
		{
			var arg = args.item(i);
			if (args_sz - 1 == i)
			{
				content += Runtime.rtl.toStr("(__varg" + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(") => "));
			}
			else
			{
				content += Runtime.rtl.toStr("(__ctx" + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(", __varg") + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(") => "));
			}
		}
		var flag = false;
		var res = t.expression.constructor.Dynamic(t, op_code.obj, true);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		if (s == "parent")
		{
			content = this.useModuleName(t, t.current_class_extends_name);
			if (t.current_function.name != "constructor")
			{
				if (t.current_function.isStatic())
				{
					content += Runtime.rtl.toStr("." + Runtime.rtl.toStr(t.current_function.name));
				}
				else
				{
					content += Runtime.rtl.toStr(".prototype." + Runtime.rtl.toStr(t.current_function.name));
				}
			}
			content += Runtime.rtl.toStr(".call(this");
			flag = true;
		}
		else
		{
			content += Runtime.rtl.toStr("(ctx");
			flag = true;
		}
		for (var i = 0; i < op_code.args.count(); i++)
		{
			s = "";
			var item = op_code.args.item(i);
			if (item instanceof BayLang.OpCodes.OpCurryArg)
			{
				s += Runtime.rtl.toStr("__varg" + Runtime.rtl.toStr(item.pos));
			}
			else
			{
				var res = this.Expression(t, item);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
			}
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpCall
	 */
	OpCall: function(t, op_code)
	{
		var s = "";
		var flag = false;
		var res = t.expression.constructor.Dynamic(t, op_code.obj, true);
		t = Runtime.rtl.attr(res, 0);
		s = Runtime.rtl.attr(res, 1);
		if (s == "parent")
		{
			s = this.useModuleName(t, t.current_class_extends_name);
			if (t.current_function.name != "constructor")
			{
				if (!t.current_class.is_component)
				{
					if (t.current_function.isStatic())
					{
						s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(t.current_function.name));
					}
					else
					{
						s += Runtime.rtl.toStr(".prototype." + Runtime.rtl.toStr(t.current_function.name));
					}
				}
				else
				{
					if (t.current_function.isStatic())
					{
						s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(t.current_function.name));
					}
					else
					{
						s += Runtime.rtl.toStr(".methods." + Runtime.rtl.toStr(t.current_function.name));
					}
				}
			}
			s += Runtime.rtl.toStr(".call(this");
			flag = true;
		}
		else
		{
			s += Runtime.rtl.toStr("(");
		}
		var content = s;
		if (t.enable_context)
		{
			if (op_code.obj instanceof BayLang.OpCodes.OpIdentifier && op_code.obj.value == "_")
			{
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr("ctx"));
				flag = true;
			}
			else if ((t.current_function == null || t.current_function.is_context) && op_code.is_context)
			{
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr("ctx"));
				flag = true;
			}
		}
		/*
		if (op_code.is_html)
		{
			content ~= (flag ? ", " : "") ~
				"component, render_params, render_content";
			flag = true;
		}
		*/
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = t.expression.constructor.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		if (t.current_function != null && t.current_function.isFlag("async") && op_code.is_await && t.isAsyncAwait())
		{
			content = "await " + Runtime.rtl.toStr(content);
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassOf
	 */
	OpClassOf: function(t, op_code)
	{
		var names = this.findModuleNames(t, op_code.entity_name.names);
		var s = Runtime.rs.join(".", names);
		return Runtime.Vector.from([t,this.toString(s)]);
	},
	/**
	 * OpTernary
	 */
	OpTernary: function(t, op_code)
	{
		var content = "";
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 100);
		var res = t.expression.constructor.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var condition = Runtime.rtl.attr(res, 1);
		var res = t.expression.constructor.Expression(t, op_code.if_true);
		t = Runtime.rtl.attr(res, 0);
		var if_true = Runtime.rtl.attr(res, 1);
		var res = t.expression.constructor.Expression(t, op_code.if_false);
		t = Runtime.rtl.attr(res, 0);
		var if_false = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr("(" + Runtime.rtl.toStr(condition) + Runtime.rtl.toStr(") ? (") + Runtime.rtl.toStr(if_true) + Runtime.rtl.toStr(") : (") + Runtime.rtl.toStr(if_false) + Runtime.rtl.toStr(")"));
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 0);
		/* OpTernary */
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpPipe
	 */
	OpPipe: function(t, op_code, is_expression)
	{
		if (is_expression == undefined) is_expression = true;
		var content = "";
		var var_name = "";
		var value = "";
		/* use Runtime.Monad */
		var monad_name = "Runtime.Monad";
		if (t.use_module_name)
		{
			var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":this.useModuleName(t, "Runtime.Monad")}));
			t = Runtime.rtl.attr(res, 0);
			monad_name = Runtime.rtl.attr(res, 1);
		}
		var res = t.constructor.incSaveOpCode(t);
		t = Runtime.rtl.attr(res, 0);
		var_name = Runtime.rtl.attr(res, 1);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["pipe_var_name"]), var_name);
		var items = new Runtime.Vector();
		var op_code_item = op_code;
		while (op_code_item instanceof BayLang.OpCodes.OpPipe)
		{
			items.push(op_code_item);
			op_code_item = op_code_item.obj;
		}
		items = items.reverse();
		/* First item */
		var res = t.expression.constructor.Expression(t, op_code_item);
		t = Runtime.rtl.attr(res, 0);
		value = Runtime.rtl.attr(res, 1);
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s("var " + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(" = new ") + Runtime.rtl.toStr(monad_name) + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(");"))}));
		t = Runtime.rtl.attr(res, 0);
		/* Output items */
		for (var i = 0; i < items.count(); i++)
		{
			var s1 = "";
			var s2 = "";
			var op_item = items.item(i);
			if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_ATTR)
			{
				var res = this.Expression(t, op_item.value);
				t = Runtime.rtl.attr(res, 0);
				value = Runtime.rtl.attr(res, 1);
				s1 = var_name + Runtime.rtl.toStr(".attr(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
			}
			else if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_METHOD)
			{
				var value = op_item.value.obj.value.value;
				var args = "";
				var flag = false;
				for (var j = 0; j < op_item.value.args.count(); j++)
				{
					var item = op_item.value.args.item(j);
					var res = t.expression.constructor.Expression(t, item);
					t = Runtime.rtl.attr(res, 0);
					var s = Runtime.rtl.attr(res, 1);
					args += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
					flag = true;
				}
				if (!op_item.is_async || !t.enable_async_await || !t.current_function.isFlag("async"))
				{
					s1 = var_name + Runtime.rtl.toStr(".callMethod(\"") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr("\", [") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr("])");
				}
				else
				{
					s1 = "await " + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(".callMethodAsync(\"") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr("\", [") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr("])");
				}
			}
			else if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_CALL)
			{
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), true);
				var res = this.Dynamic(t, op_item.value);
				t = Runtime.rtl.attr(res, 0);
				value = Runtime.rtl.attr(res, 1);
				if (!op_item.is_async || !t.enable_async_await || !t.current_function.isFlag("async"))
				{
					if (op_item.is_monad)
					{
						s1 = var_name + Runtime.rtl.toStr(".monad(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
					}
					else
					{
						s1 = var_name + Runtime.rtl.toStr(".call(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
					}
				}
				else
				{
					if (op_item.is_monad)
					{
						s1 = "await " + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(".monadAsync(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
					}
					else
					{
						s1 = "await " + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(".callAsync(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
					}
				}
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
			}
			if (s1 != "")
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s(var_name + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";"))}));
				t = Runtime.rtl.attr(res, 0);
			}
			if (s2 != "")
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s(s2)}));
				t = Runtime.rtl.attr(res, 0);
			}
		}
		return Runtime.Vector.from([t,var_name + Runtime.rtl.toStr(".value()")]);
	},
	/**
	 * OpTypeConvert
	 */
	OpTypeConvert: function(t, op_code)
	{
		var content = "";
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var value = Runtime.rtl.attr(res, 1);
		content = this.useModuleName(t, "rtl") + Runtime.rtl.toStr(".to(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(this.toPattern(t, op_code.pattern)) + Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction
	 */
	OpDeclareFunction: function(t, op_code, is_arrow)
	{
		if (is_arrow == undefined) is_arrow = true;
		var content = "";
		var is_async = "";
		if (op_code.isFlag("async") && t.isAsyncAwait())
		{
			is_async = "async ";
		}
		/* Set function name */
		var save_f = t.current_function;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code);
		var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code);
		var args = Runtime.rtl.attr(res, 1);
		if (is_arrow)
		{
			content += Runtime.rtl.toStr(is_async + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(") =>"));
		}
		else
		{
			content += Runtime.rtl.toStr(is_async + Runtime.rtl.toStr("function (") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
		}
		var res = t.operator.constructor.OpDeclareFunctionBody(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Restore function */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), save_f);
		/* OpTernary */
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Expression
	 */
	Expression: function(t, op_code)
	{
		var content = "";
		var save_is_pipe = t.is_pipe;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 100);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
		if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			var res = this.OpIdentifier(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTypeIdentifier)
		{
			var res = this.OpTypeIdentifier(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNegative)
		{
			var res = this.OpNegative(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNumber)
		{
			var res = this.OpNumber(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpString)
		{
			var res = this.OpString(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCollection)
		{
			var res = this.OpCollection(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDict)
		{
			var res = this.OpDict(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpInc)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 16);
			var res = this.OpInc(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpMath)
		{
			var res = this.OpMath(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpMethod)
		{
			var res = this.OpMethod(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNew)
		{
			var res = this.OpNew(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			var res = this.Dynamic(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			var res = this.OpCall(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpClassOf)
		{
			var res = this.OpClassOf(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCurry)
		{
			var res = this.OpCurry(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPipe)
		{
			var res = this.OpPipe(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTernary)
		{
			var res = this.OpTernary(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTypeConvert)
		{
			var res = this.OpTypeConvert(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			var res = this.OpDeclareFunction(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlItems)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["debug_component"]), Runtime.Vector.from([]));
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), true);
			var res = t.html.constructor.OpHtmlExpression(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), false);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			var res = t.operator.constructor.OpPreprocessorIfDef(t, op_code, BayLang.OpCodes.OpPreprocessorIfDef.KIND_EXPRESSION);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), save_is_pipe);
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Expression";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6Expression);
window["BayLang.LangES6.TranslatorES6Expression"] = BayLang.LangES6.TranslatorES6Expression;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6Expression;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6Html = function()
{
};
Object.assign(BayLang.LangES6.TranslatorES6Html.prototype,
{
});
Object.assign(BayLang.LangES6.TranslatorES6Html,
{
	/**
	 * Is component
	 */
	isComponent: function(tag_name)
	{
		if (tag_name == "")
		{
			return false;
		}
		if (tag_name == "Teleport")
		{
			return false;
		}
		var ch1 = Runtime.rs.substr(tag_name, 0, 1);
		var ch2 = Runtime.rs.upper(ch1);
		return ch1 == "{" || ch1 == ch2;
	},
	/**
	 * Translator html value
	 */
	OpHtmlAttr: function(t, attr)
	{
		var op_code = attr.value;
		if (op_code instanceof BayLang.OpCodes.OpString)
		{
			return Runtime.Vector.from([t,t.expression.constructor.toString(op_code.value)]);
		}
		if (op_code instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_RAW)
			{
				var res = t.expression.constructor.Expression(t, op_code.value);
				t = Runtime.rtl.attr(res, 0);
				var value = Runtime.rtl.attr(res, 1);
				return Runtime.Vector.from([t,value]);
			}
			else if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_JSON)
			{
				var res = t.expression.constructor.Expression(t, op_code.value);
				t = Runtime.rtl.attr(res, 0);
				var value = Runtime.rtl.attr(res, 1);
				value = "Runtime.rtl.json_encode(" + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
				return Runtime.Vector.from([t,value]);
			}
		}
		var res = t.expression.constructor.Expression(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		var value = Runtime.rtl.attr(res, 1);
		value = t.o(value, Runtime.rtl.attr(res, 0).opcode_level, 13);
		return Runtime.Vector.from([t,value]);
	},
	/**
	 * Translator html template
	 */
	OpHtmlAttrs: function(t, attrs, is_component)
	{
		if (is_component == undefined) is_component = false;
		var attr_class = new Runtime.Vector();
		var attr_s = "null";
		var attr_key_value = "";
		var attr_elem_name = "";
		var has_attr_key = false;
		var res_attrs = new Runtime.Vector();
		for (var attrs_i = 0; attrs_i < attrs.count(); attrs_i++)
		{
			var attr = Runtime.rtl.attr(attrs, attrs_i);
			if (attr.is_spread)
			{
				continue;
			}
			var res = this.OpHtmlAttr(t, attr);
			t = Runtime.rtl.attr(res, 0);
			var attr_value = Runtime.rtl.attr(res, 1);
			var attr_key = attr.key;
			var ch = Runtime.rs.substr(attr_key, 0, 1);
			var is_event = Runtime.rs.substr(attr_key, 0, 7) == "@event:";
			if (attr_key == "class")
			{
				attr_class.push(attr_value);
				if (attr_elem_name == "" && attr.value instanceof BayLang.OpCodes.OpString)
				{
					var arr = Runtime.rs.split(" ", attr.value.value);
					attr_elem_name = t.expression.constructor.toString(Runtime.rtl.attr(arr, 0));
				}
				continue;
			}
			else if (attr_key == "@key")
			{
				var res = this.OpHtmlAttr(t, attr);
				t = Runtime.rtl.attr(res, 0);
				attr_value = Runtime.rtl.attr(res, 1);
				attr_key_value = attr_value;
				continue;
			}
			else if (is_event)
			{
				var event_name = Runtime.rs.substr(attr_key, 7);
				attr_key = Runtime.rs.substr(attr_key, 7);
				if (Runtime.rs.substr(attr_key, 0, 2) != "on")
				{
					var first = Runtime.rs.upper(Runtime.rs.substr(attr_key, 0, 1));
					var second = Runtime.rs.substr(attr_key, 1);
					attr_key = "on" + Runtime.rtl.toStr(first) + Runtime.rtl.toStr(second);
				}
			}
			else if (attr_key == "@global")
			{
				attr_key = "model";
				attr_value = "this._model(" + Runtime.rtl.toStr(attr_value) + Runtime.rtl.toStr(", true)");
			}
			else if (attr_key == "@model")
			{
				attr_key = "model";
				attr_value = "this._model(" + Runtime.rtl.toStr(attr_value) + Runtime.rtl.toStr(")");
			}
			else if (attr_key == "@ref")
			{
				attr_key = "ref";
			}
			/*
			else if (attr_key == "@ref" or attr_key == "@bind" or attr_key == "@model" or
				attr_key == "@name" or attr_key == "@watch")
			{
				attr_value = "[component," ~ attr_value ~ "]";
			}
			else if (attr_key == "@global")
			{
				attr_key = "@model";
				attr_value = "[null," ~ attr_value ~ "]";
			}
			*/
			res_attrs.push(t.expression.constructor.toString(attr_key) + Runtime.rtl.toStr(":") + Runtime.rtl.toStr(attr_value));
		}
		res_attrs = res_attrs.filter((s) =>
		{
			return s != "";
		});
		/* Add debug component */
		if (t.preprocessor_flags.get("DEBUG_COMPONENT") && !is_component)
		{
			attr_class.push("\"debug_component\"");
		}
		/* Attrs */
		if (attr_class.count() > 0)
		{
			res_attrs.push("\"class\":" + Runtime.rtl.toStr("this._class_name([") + Runtime.rtl.toStr(Runtime.rs.join(", ", attr_class)) + Runtime.rtl.toStr("])"));
		}
		if (attr_key_value != "")
		{
			res_attrs.push("\"key\":" + Runtime.rtl.toStr(attr_key_value));
		}
		/*
		else if (attr_elem_name != "")
		{
			res_attrs.push
			(
				"\"key\":" ~ attr_elem_name
			);
		}
		*/
		/* Add debug component */
		if (t.preprocessor_flags.get("DEBUG_COMPONENT"))
		{
			if (is_component)
			{
				res_attrs.push("\"data_widget_path\": \"" + Runtime.rtl.toStr(Runtime.rs.join(".", t.debug_component)) + Runtime.rtl.toStr("\""));
			}
			else
			{
				res_attrs.push("\"data-widget-path\": \"" + Runtime.rtl.toStr(Runtime.rs.join(".", t.debug_component)) + Runtime.rtl.toStr("\""));
			}
		}
		if (res_attrs.count() > 0)
		{
			attr_s = "{" + Runtime.rtl.toStr(Runtime.rs.join(",", res_attrs)) + Runtime.rtl.toStr("}");
		}
		else
		{
			attr_s = "{}";
		}
		/* Add spreads */
		for (var i = 0; i < attrs.count(); i++)
		{
			var attr = Runtime.rtl.attr(attrs, i);
			if (!attr.is_spread)
			{
				continue;
			}
			attr_s = "this._merge_attrs(" + Runtime.rtl.toStr(attr_s) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attr.value.value) + Runtime.rtl.toStr(")");
		}
		return Runtime.Vector.from([t,attr_s]);
	},
	/**
	 * Translator html template
	 */
	OpHtmlTag: function(t, op_code, var_name)
	{
		var content = "";
		var content2 = "";
		var str_var_name = t.expression.constructor.toString(var_name);
		if (op_code instanceof BayLang.OpCodes.OpHtmlContent)
		{
			var item_value = t.expression.constructor.toString(op_code.value);
			content += Runtime.rtl.toStr(t.s("/* Text */"));
			content += Runtime.rtl.toStr(t.s("this._t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlValue)
		{
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			/*int save_op_code_inc = t.save_op_code_inc;*/
			var res = t.expression.constructor.Expression(t, op_code.value);
			t = Runtime.rtl.attr(res, 0);
			var item_value = Runtime.rtl.attr(res, 1);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			/* Restore op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_RAW)
			{
				content += Runtime.rtl.toStr(t.s("/* Raw */"));
				content += Runtime.rtl.toStr(t.s("this._t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr("new Runtime.RawString(") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr("));")));
			}
			else if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_JSON)
			{
				content += Runtime.rtl.toStr(t.s("/* Text */"));
				item_value = "Runtime.rtl.json_encode(" + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(")");
				content += Runtime.rtl.toStr(t.s("this._t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlTag)
		{
			var new_var_name = "";
			var res = t.constructor.incSaveOpCode(t);
			t = Runtime.rtl.attr(res, 0);
			new_var_name = Runtime.rtl.attr(res, 1);
			var has_childs = op_code.items != null && op_code.items.items != null && op_code.items.items.count() > 0;
			var is_component = this.isComponent(op_code.tag_name);
			var op_code_attrs = op_code.attrs.filter((attr) =>
			{
				return attr.key != "@render";
			});
			var res = this.OpHtmlAttrs(t, op_code_attrs, is_component);
			t = Runtime.rtl.attr(res, 0);
			var attrs = Runtime.rtl.attr(res, 1);
			if (op_code.tag_name == "")
			{
			}
			else if (is_component)
			{
				var tag_name = "";
				if (op_code.op_code_name)
				{
					var res = t.expression.constructor.Expression(t, op_code.op_code_name);
					t = Runtime.rtl.attr(res, 0);
					tag_name = Runtime.rtl.attr(res, 1);
				}
				else
				{
					tag_name = t.expression.constructor.toString(t.expression.constructor.findModuleName(t, op_code.tag_name));
				}
				if (has_childs)
				{
					var res = this.OpHtmlItemsAsFunction(t, op_code.items);
					t = Runtime.rtl.attr(res, 0);
					var f = Runtime.rtl.attr(res, 1);
					content += Runtime.rtl.toStr(t.s("/* Component '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					content += Runtime.rtl.toStr(t.s("let " + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr("this._c(") + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(f) + Runtime.rtl.toStr(");")));
					has_childs = false;
				}
				else
				{
					content += Runtime.rtl.toStr(t.s("/* Component '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					content += Runtime.rtl.toStr(t.s("let " + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr("this._c(") + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
				}
			}
			else
			{
				if (op_code.tag_name == "Teleport")
				{
					content += Runtime.rtl.toStr(t.s("/* Teleport */"));
					content += Runtime.rtl.toStr(t.s("let " + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr("this._teleport(") + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
				}
				else
				{
					content += Runtime.rtl.toStr(t.s("/* Element '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					var tag_name = t.expression.constructor.toString(op_code.tag_name);
					content += Runtime.rtl.toStr(t.s("let " + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr("this._e(") + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
				}
			}
			if (has_childs)
			{
				var res = this.OpHtmlItems(t, op_code.items, new_var_name, true);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		else
		{
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			/*int save_op_code_inc = t.save_op_code_inc;*/
			var item_value = "";
			if (op_code instanceof BayLang.OpCodes.OpCall)
			{
				var res = t.expression.constructor.OpCall(t, op_code);
				t = Runtime.rtl.attr(res, 0);
				item_value += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else
			{
				var res = t.expression.constructor.Expression(t, op_code);
				t = Runtime.rtl.attr(res, 0);
				item_value = Runtime.rtl.attr(res, 1);
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			/* Restore op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			content += Runtime.rtl.toStr(t.s("/* Render */"));
			content += Runtime.rtl.toStr(t.s("this._t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items
	 */
	OpHtmlExpression: function(t, op_code)
	{
		var content = "";
		content += Runtime.rtl.toStr(t.s("let __v = [];"));
		var res = this.OpHtmlItems(t, op_code, "__v", true);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		content += Runtime.rtl.toStr(t.s2(""));
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":content}));
		t = Runtime.rtl.attr(res, 0);
		return Runtime.Vector.from([t,"this._flatten(__v)"]);
	},
	/**
	 * Translator html slot
	 */
	OpHtmlSlot: function(t, op_code)
	{
		var content = "{";
		t = t.levelInc();
		var debug_component = t.debug_component.slice();
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			if (!(item instanceof BayLang.OpCodes.OpHtmlSlot))
			{
				continue;
			}
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["debug_component"]), debug_component.pushIm(i));
			content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(item.name) + Runtime.rtl.toStr(": ")));
			var res = this.OpHtmlItemsAsFunction(t, item.items, item.args);
			t = res.get(0);
			content += Runtime.rtl.toStr(res.get(1) + Runtime.rtl.toStr(","));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items as function
	 */
	OpHtmlItemsAsFunction: function(t, op_code, args)
	{
		if (args == undefined) args = null;
		/* If slot */
		if (op_code.items.get(0) instanceof BayLang.OpCodes.OpHtmlSlot)
		{
			return this.OpHtmlSlot(t, op_code);
		}
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), 0);
		var content = "() => {";
		if (args != null)
		{
			var res = t.operator.constructor.OpDeclareFunctionArgs(t, new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"args":args,"is_context":false})));
			content = "(" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(") => {");
		}
		t = t.levelInc();
		var res = this.OpHtmlExpression(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		/* Output save op code */
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(";")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items
	 */
	OpHtmlItems: function(t, op_code, var_name, first_space)
	{
		if (var_name == undefined) var_name = "";
		if (first_space == undefined) first_space = false;
		if (op_code == null || op_code.items.count() == 0)
		{
			return Runtime.Vector.from([t,""]);
		}
		var debug_component = t.debug_component.slice();
		var save_var_name = t.html_var_name;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["html_var_name"]), var_name);
		var content = "";
		var next_space = true;
		var add_space = (i) =>
		{
			if (i > 0 && next_space)
			{
				content += Runtime.rtl.toStr(t.s2(""));
			}
			if (i == 0 && first_space)
			{
				content += Runtime.rtl.toStr(t.s2(""));
			}
			if (!next_space)
			{
				next_space = true;
			}
		};
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			/*int save_op_code_inc = t.save_op_code_inc;*/
			var op_content = "";
			if (item instanceof BayLang.OpCodes.OpAssign)
			{
				var res = t.operator.constructor.OpAssign(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpComment)
			{
				add_space(i);
				var res = t.operator.constructor.OpComment(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				next_space = false;
			}
			else if (item instanceof BayLang.OpCodes.OpFor)
			{
				add_space(i);
				var res = t.operator.constructor.OpFor(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpIf)
			{
				add_space(i);
				var res = t.operator.constructor.OpIf(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpWhile)
			{
				add_space(i);
				var res = t.operator.constructor.OpWhile(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpHtmlSlot)
			{
				continue;
			}
			else
			{
				add_space(i);
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["debug_component"]), debug_component.pushIm(i));
				var res = this.OpHtmlTag(t, item, var_name);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			if (op_content != "")
			{
				content += Runtime.rtl.toStr(op_content);
			}
			/* Restore save op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
		}
		/*
		if (var_name != "control" and patch_flag)
		{
			content ~= t.s("RenderDriver.p(" ~ var_name ~ ", " ~ var_name ~ "_childs);");
		}
		*/
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["html_var_name"]), save_var_name);
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Html";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6Html);
window["BayLang.LangES6.TranslatorES6Html"] = BayLang.LangES6.TranslatorES6Html;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6Html;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6Operator = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.LangES6.TranslatorES6Operator.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.LangES6.TranslatorES6Operator.prototype.constructor = BayLang.LangES6.TranslatorES6Operator;
Object.assign(BayLang.LangES6.TranslatorES6Operator.prototype,
{
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.TranslatorES6Operator, Runtime.BaseStruct);
Object.assign(BayLang.LangES6.TranslatorES6Operator,
{
	/**
	 * Returns true if op_code contains await
	 */
	isAwait: function(op_code)
	{
		var __memorize_value = Runtime.rtl._memorizeValue("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments);
		if (__memorize_value != Runtime.rtl._memorize_not_found) return __memorize_value;
		if (op_code == null)
		{
			var __memorize_value = false;
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_ASSIGN || op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				for (var i = 0; i < op_code.values.count(); i++)
				{
					var item = op_code.values.item(i);
					var flag = this.isAwait(item.expression);
					if (flag)
					{
						var __memorize_value = true;
						Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
						return __memorize_value;
					}
				}
			}
			else if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_STRUCT)
			{
				var flag = this.isAwait(op_code.expression);
				if (flag)
				{
					var __memorize_value = true;
					Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
					return __memorize_value;
				}
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpAssignStruct)
		{
			var flag = this.isAwait(op_code.expression);
			if (flag)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			var op_code_next = op_code;
			while (op_code_next instanceof BayLang.OpCodes.OpAttr)
			{
				op_code_next = op_code_next.obj;
			}
			var __memorize_value = this.isAwait(op_code_next);
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			var __memorize_value = op_code.is_await;
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		else if (op_code instanceof BayLang.OpCodes.OpPipe)
		{
			if (op_code.is_async)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
			var __memorize_value = this.isAwait(op_code.value);
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		else if (op_code instanceof BayLang.OpCodes.OpFor)
		{
			var __memorize_value = this.isAwait(op_code.expr2) || this.isAwait(op_code.value);
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		else if (op_code instanceof BayLang.OpCodes.OpIf)
		{
			var flag = false;
			flag = this.isAwait(op_code.condition);
			if (flag)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
			flag = this.isAwait(op_code.if_true);
			if (flag)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
			flag = this.isAwait(op_code.if_false);
			if (flag)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
			for (var i = 0; i < op_code.if_else.count(); i++)
			{
				var if_else = op_code.if_else.item(i);
				flag = this.isAwait(if_else.condition);
				if (flag)
				{
					var __memorize_value = true;
					Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
					return __memorize_value;
				}
				flag = this.isAwait(if_else.if_true);
				if (flag)
				{
					var __memorize_value = true;
					Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
					return __memorize_value;
				}
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpItems)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var flag = this.isAwait(item);
				if (flag)
				{
					var __memorize_value = true;
					Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
					return __memorize_value;
				}
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpMath)
		{
			if (op_code.math == "!" || op_code.math == "not")
			{
				var __memorize_value = this.isAwait(op_code.value1);
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
			else
			{
				var __memorize_value = this.isAwait(op_code.value1) || this.isAwait(op_code.value2);
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpReturn)
		{
			var flag = this.isAwait(op_code.expression);
			if (flag)
			{
				var __memorize_value = true;
				Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
				return __memorize_value;
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpTryCatch)
		{
			var __memorize_value = this.isAwait(op_code.op_try);
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		else if (op_code instanceof BayLang.OpCodes.OpWhile)
		{
			var __memorize_value = this.isAwait(op_code.condition) || this.isAwait(op_code.value);
			Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
			return __memorize_value;
		}
		var __memorize_value = false;
		Runtime.rtl._memorizeSave("BayLang.LangES6.TranslatorES6Operator.isAwait", arguments, __memorize_value);
		return __memorize_value;
	},
	/**
	 * OpAssign
	 */
	OpAssignStruct: function(t, op_code, pos)
	{
		if (pos == undefined) pos = 0;
		var content = "";
		var var_name = op_code.var_name;
		var res = t.expression.constructor.Expression(t, op_code.expression);
		t = Runtime.rtl.attr(res, 0);
		var expr = Runtime.rtl.attr(res, 1);
		var names = op_code.names.map((item) =>
		{
			if (item instanceof BayLang.OpCodes.BaseOpCode)
			{
				var res = t.expression.constructor.Expression(t, item);
				t = Runtime.rtl.attr(res, 0);
				return Runtime.rtl.attr(res, 1);
			}
			return t.expression.constructor.toString(item);
		});
		content = "Runtime.rtl.setAttr(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", Runtime.Collection.from([") + Runtime.rtl.toStr(Runtime.rs.join(", ", names)) + Runtime.rtl.toStr("]), ") + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpAssign
	 */
	OpAssign: function(t, op_code, flag_indent)
	{
		if (flag_indent == undefined) flag_indent = true;
		var content = "";
		if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_ASSIGN || op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
		{
			for (var i = 0; i < op_code.values.count(); i++)
			{
				var item = op_code.values.item(i);
				var s = "";
				var item_expression = "";
				var op = item.op;
				if (op == "")
				{
					op = "=";
				}
				if (item.expression != null)
				{
					var res = t.expression.constructor.Expression(t, item.expression);
					t = Runtime.rtl.attr(res, 0);
					if (op == "~=")
					{
						item_expression = t.expression.constructor.rtlToStr(t, Runtime.rtl.attr(res, 1));
					}
					else
					{
						item_expression = Runtime.rtl.attr(res, 1);
					}
				}
				if (item.op_code instanceof BayLang.OpCodes.OpAttr)
				{
					var items = new Runtime.Vector();
					var items2 = new Runtime.Vector();
					var op_code_next = item.op_code;
					while (op_code_next instanceof BayLang.OpCodes.OpAttr)
					{
						items.push(op_code_next);
						op_code_next = op_code_next.obj;
					}
					items = items.reverse();
					var res = t.expression.constructor.OpIdentifier(t, op_code_next);
					t = Runtime.rtl.attr(res, 0);
					var obj_s = Runtime.rtl.attr(res, 1);
					for (var j = 0; j < items.count(); j++)
					{
						var item_attr = Runtime.rtl.attr(items, j);
						if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_ATTR)
						{
							obj_s += Runtime.rtl.toStr("." + Runtime.rtl.toStr(item_attr.value.value));
							items2.push(t.expression.constructor.toString(item_attr.value.value));
						}
						else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC)
						{
							var res = t.expression.constructor.Expression(t, item_attr.value);
							t = Runtime.rtl.attr(res, 0);
							obj_s += Runtime.rtl.toStr("[" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr("]"));
							items2.push(Runtime.rtl.attr(res, 1));
						}
						else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS)
						{
							if (item_attr.attrs != null)
							{
								for (var j = item_attr.attrs.count() - 1; j >= 0; j--)
								{
									var res = t.expression.constructor.Expression(t, Runtime.rtl.attr(item_attr.attrs, j));
									t = Runtime.rtl.attr(res, 0);
									obj_s += Runtime.rtl.toStr("[" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr("]"));
									items2.push(Runtime.rtl.attr(res, 1));
								}
							}
						}
					}
					if (op == "~=" || op == "+=" || op == "-=")
					{
						var op2 = "+";
						if (op == "~=" || op == "+=")
						{
							op2 = "+";
						}
						else if (op == "-=")
						{
							op2 = "-";
						}
						item_expression = "Runtime.rtl.attr(" + Runtime.rtl.toStr(obj_s) + Runtime.rtl.toStr(", [") + Runtime.rtl.toStr(Runtime.rs.join(", ", items2)) + Runtime.rtl.toStr("]) ") + Runtime.rtl.toStr(op2) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(item_expression);
					}
					s = obj_s + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(item_expression);
				}
				else
				{
					if (item.op_code != null && item.op_code.value == "@" && t.enable_context == false)
					{
						s = t.expression.constructor.useModuleName(t, "rtl") + Runtime.rtl.toStr(".setContext(") + Runtime.rtl.toStr(item_expression) + Runtime.rtl.toStr(")");
					}
					else
					{
						if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
						{
							if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
							{
								s = item.var_name;
							}
							else if (t.is_html)
							{
								s = "let " + Runtime.rtl.toStr(item.var_name);
							}
							else
							{
								s = "var " + Runtime.rtl.toStr(item.var_name);
							}
						}
						else
						{
							var res = t.expression.constructor.OpIdentifier(t, item.op_code);
							t = Runtime.rtl.attr(res, 0);
							s = Runtime.rtl.attr(res, 1);
						}
						if (item_expression != "")
						{
							if (op == "~=")
							{
								s += Runtime.rtl.toStr(" += " + Runtime.rtl.toStr(item_expression));
							}
							else
							{
								s += Runtime.rtl.toStr(" " + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(item_expression));
							}
						}
					}
				}
				if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
				{
					if (item.expression == null)
					{
						s = "";
					}
					else if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
					{
						s = s + Runtime.rtl.toStr(";");
					}
				}
				else
				{
					s = s + Runtime.rtl.toStr(";");
				}
				if (s != "")
				{
					content += Runtime.rtl.toStr((flag_indent) ? (t.s(s)) : (s));
				}
				if (item.var_name != "" && t.save_vars.indexOf(item.var_name) == -1)
				{
					t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_vars"]), t.save_vars.pushIm(item.var_name));
				}
			}
		}
		else if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_STRUCT)
		{
			var s = op_code.var_name + Runtime.rtl.toStr(" = ");
			var res = this.OpAssignStruct(t, op_code, 0);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(s + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(";"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDelete
	 */
	OpDelete: function(t, op_code)
	{
		var content = "";
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpFor
	 */
	OpFor: function(t, op_code)
	{
		if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
		{
			if (this.isAwait(op_code))
			{
				return t.async_await.constructor.OpFor(t, op_code);
			}
		}
		var content = "";
		var s1 = "";
		var s2 = "";
		var s3 = "";
		if (op_code.expr1 instanceof BayLang.OpCodes.OpAssign)
		{
			var res = this.OpAssign(t, op_code.expr1, false);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		else
		{
			var res = t.expression.constructor.Expression(t, op_code.expr1);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		var res = t.expression.constructor.Expression(t, op_code.expr2);
		t = Runtime.rtl.attr(res, 0);
		s2 = Runtime.rtl.attr(res, 1);
		var res = t.expression.constructor.Expression(t, op_code.expr3);
		t = Runtime.rtl.attr(res, 0);
		s3 = Runtime.rtl.attr(res, 1);
		content = t.s("for (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(s2) + Runtime.rtl.toStr("; ") + Runtime.rtl.toStr(s3) + Runtime.rtl.toStr(")"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpIf
	 */
	OpIf: function(t, op_code)
	{
		if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
		{
			if (this.isAwait(op_code))
			{
				return t.async_await.constructor.OpIf(t, op_code);
			}
		}
		var content = "";
		var res = t.expression.constructor.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var s1 = Runtime.rtl.attr(res, 1);
		content = t.s("if (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(")"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.if_true);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		for (var i = 0; i < op_code.if_else.count(); i++)
		{
			var if_else = op_code.if_else.item(i);
			var res = t.expression.constructor.Expression(t, if_else.condition);
			t = Runtime.rtl.attr(res, 0);
			var s2 = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(s2) + Runtime.rtl.toStr(")")));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			var res = this.Operators(t, if_else.if_true);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		if (op_code.if_false != null)
		{
			content += Runtime.rtl.toStr(t.s("else"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			var res = this.Operators(t, op_code.if_false);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpReturn
	 */
	OpReturn: function(t, op_code)
	{
		if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
		{
			return t.async_await.constructor.OpReturn(t, op_code);
		}
		var content = "";
		var s1 = "";
		if (op_code.expression)
		{
			var res = t.expression.constructor.Expression(t, op_code.expression);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		if (t.current_function.flags != null && t.current_function.flags.isFlag("memorize"))
		{
			var content = t.s("var __memorize_value = " + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";"));
			content += Runtime.rtl.toStr(t.s(t.expression.constructor.useModuleName(t, "Runtime.rtl") + Runtime.rtl.toStr("._memorizeSave(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(t.current_function.name) + Runtime.rtl.toStr("\", arguments, __memorize_value);")));
			content += Runtime.rtl.toStr(t.s("return __memorize_value;"));
			return Runtime.Vector.from([t,content]);
		}
		if (t.current_function.isFlag("async") && t.isAsyncAwait())
		{
			content += Runtime.rtl.toStr(t.s("return Promise.resolve(" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(");")));
		}
		else
		{
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";")));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpThrow
	 */
	OpThrow: function(t, op_code)
	{
		var res = t.expression.constructor.Expression(t, op_code.expression);
		t = Runtime.rtl.attr(res, 0);
		var content = t.s("throw " + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpTryCatch
	 */
	OpTryCatch: function(t, op_code)
	{
		if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
		{
			if (this.isAwait(op_code))
			{
				return t.async_await.constructor.OpTryCatch(t, op_code);
			}
		}
		var content = "";
		content += Runtime.rtl.toStr(t.s("try"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.op_try);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("catch (_ex)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var s = "";
			var pattern = "";
			var item = op_code.items.item(i);
			var res = t.expression.constructor.OpTypeIdentifier(t, item.pattern);
			t = Runtime.rtl.attr(res, 0);
			pattern += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			if (pattern != "var")
			{
				s = "if (_ex instanceof " + Runtime.rtl.toStr(pattern) + Runtime.rtl.toStr(")");
			}
			else
			{
				s = "if (true)";
			}
			s += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			s += Runtime.rtl.toStr((s != "") ? (t.s("var " + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = _ex;"))) : ("var " + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = _ex;")));
			var res = t.operator.constructor.Operators(t, item.value);
			t = Runtime.rtl.attr(res, 0);
			s += Runtime.rtl.toStr(t.s(Runtime.rtl.attr(res, 1)));
			t = t.levelDec();
			s += Runtime.rtl.toStr(t.s("}"));
			if (i != 0)
			{
				s = "else " + Runtime.rtl.toStr(s);
			}
			content += Runtime.rtl.toStr(t.s(s));
		}
		content += Runtime.rtl.toStr(t.s("else"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("throw _ex;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpWhile
	 */
	OpWhile: function(t, op_code)
	{
		if (t.current_function.isFlag("async") && t.isEmulateAsyncAwait())
		{
			if (this.isAwait(op_code))
			{
				return t.async_await.constructor.OpWhile(t, op_code);
			}
		}
		var content = "";
		var res = t.expression.constructor.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var s1 = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("while (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpPreprocessorIfCode
	 */
	OpPreprocessorIfCode: function(t, op_code)
	{
		var content = "";
		if (Runtime.rtl.attr(t.preprocessor_flags, op_code.condition.value) == true)
		{
			content = Runtime.rs.trim(op_code.content);
		}
		return Runtime.Vector.from([t,t.s(content)]);
	},
	/**
	 * OpPreprocessorIfDef
	 */
	OpPreprocessorIfDef: function(t, op_code, kind)
	{
		if (!(Runtime.rtl.attr(t.preprocessor_flags, op_code.condition.value) == true))
		{
			return Runtime.Vector.from([t,""]);
		}
		if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR)
		{
			return this.Operators(t, op_code.items);
		}
		else if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_EXPRESSION)
		{
			return t.expression.constructor.Expression(t, op_code.items);
		}
		var content = "";
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			if (item instanceof BayLang.OpCodes.OpComment)
			{
				var res = t.operator.constructor.OpComment(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
			{
				var res = t.program.constructor.OpDeclareFunction(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComment
	 */
	OpComment: function(t, op_code)
	{
		var content = t.s("/*" + Runtime.rtl.toStr(op_code.value) + Runtime.rtl.toStr("*/"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComments
	 */
	OpComments: function(t, comments)
	{
		var content = "";
		for (var i = 0; i < comments.count(); i++)
		{
			var res = this.OpComment(t, comments.item(i));
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComments
	 */
	AddComments: function(t, comments, content)
	{
		if (comments && comments.count() > 0)
		{
			var res = this.OpComments(t, comments);
			var s = Runtime.rtl.attr(res, 1);
			if (s != "")
			{
				content = s + Runtime.rtl.toStr(content);
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Operator
	 */
	Operator: function(t, op_code)
	{
		var content = "";
		/* Save op codes */
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			var res = this.OpAssign(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content = save + Runtime.rtl.toStr(content);
			}
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			return Runtime.Vector.from([t,content]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAssignStruct)
		{
			var res = this.OpAssignStruct(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var s1 = Runtime.rtl.attr(res, 1);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content = save;
			}
			content += Runtime.rtl.toStr(t.s(op_code.var_name + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";")));
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			return Runtime.Vector.from([t,content]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpBreak)
		{
			content = t.s("break;");
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			var res = t.expression.constructor.OpCall(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			if (Runtime.rtl.attr(res, 1) != "")
			{
				content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpContinue)
		{
			content = t.s("continue;");
		}
		else if (op_code instanceof BayLang.OpCodes.OpDelete)
		{
			var res = this.OpDelete(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpFor)
		{
			var res = this.OpFor(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		}
		else if (op_code instanceof BayLang.OpCodes.OpIf)
		{
			var res = this.OpIf(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPipe)
		{
			var res = t.expression.constructor.OpPipe(t, op_code, false);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
		}
		else if (op_code instanceof BayLang.OpCodes.OpReturn)
		{
			var res = this.OpReturn(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpThrow)
		{
			var res = this.OpThrow(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTryCatch)
		{
			var res = this.OpTryCatch(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		}
		else if (op_code instanceof BayLang.OpCodes.OpWhile)
		{
			var res = this.OpWhile(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		}
		else if (op_code instanceof BayLang.OpCodes.OpInc)
		{
			var res = t.expression.constructor.OpInc(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfCode)
		{
			var res = this.OpPreprocessorIfCode(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			var res = this.OpPreprocessorIfDef(t, op_code, BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorSwitch)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var res = this.OpPreprocessorIfCode(t, op_code.items.item(i));
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpComment)
		{
			var res = this.OpComment(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpSafe)
		{
			var res = this.Operators(t, op_code.items);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		/* Output save op code */
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		if (save != "")
		{
			content = save + Runtime.rtl.toStr(content);
		}
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		/*t <= save_op_code_inc <= save_op_code_inc;*/
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Operators
	 */
	Operators: function(t, op_code)
	{
		var content = "";
		if (op_code instanceof BayLang.OpCodes.OpItems)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.Operator(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlItems)
		{
			var save_html_var_name = t.html_var_name;
			var save_is_html = t.is_html;
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["debug_component"]), Runtime.Vector.from([]));
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), true);
			var res = t.html.constructor.OpHtmlItems(t, op_code, save_html_var_name, false);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), save_is_html);
		}
		else
		{
			var res = this.Operator(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction Arguments
	 */
	OpDeclareFunctionArgs: function(t, f)
	{
		var content = "";
		if (f.args != null)
		{
			var flag = false;
			if (f.is_context)
			{
				content += Runtime.rtl.toStr("ctx");
				flag = true;
			}
			/*
			if (f.is_html)
			{
				flag = true;
				content ~= (flag ? ", " : "") ~
					"component, render_params, render_content";
			}
			*/
			for (var i = 0; i < f.args.count(i); i++)
			{
				var arg = f.args.item(i);
				var name = arg.name;
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(name));
				flag = true;
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction Body
	 */
	OpDeclareFunctionBody: function(t, f)
	{
		var save_t = t;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), false);
		if (f.isFlag("async") && t.isEmulateAsyncAwait())
		{
			return t.async_await.constructor.OpDeclareFunctionBody(t, f);
		}
		/* Save op codes */
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		var content = "";
		t = t.levelInc();
		if (f.args)
		{
			for (var i = 0; i < f.args.count(); i++)
			{
				var arg = f.args.item(i);
				if (arg.expression == null)
				{
					continue;
				}
				var res = t.expression.constructor.Expression(t, arg.expression);
				t = Runtime.rtl.attr(res, 0);
				var s = Runtime.rtl.attr(res, 1);
				s = "if (" + Runtime.rtl.toStr(arg.name) + Runtime.rtl.toStr(" == undefined) ") + Runtime.rtl.toStr(arg.name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";");
				content += Runtime.rtl.toStr(t.s(s));
			}
		}
		if (f.items)
		{
			var res = t.operator.constructor.Operators(t, f.items);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		else if (f.expression)
		{
			var res = t.expression.constructor.Expression(t, f.expression);
			t = Runtime.rtl.attr(res, 0);
			var expr = Runtime.rtl.attr(res, 1);
			var s = "";
			if (f.flags != null && f.flags.isFlag("memorize"))
			{
				s = t.s("var __memorize_value = " + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(";"));
				s += Runtime.rtl.toStr(t.s(t.expression.constructor.useModuleName(t, "Runtime.rtl") + Runtime.rtl.toStr("._memorizeSave(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(f.name) + Runtime.rtl.toStr("\", arguments, __memorize_value);")));
				s += Runtime.rtl.toStr(t.s("return __memorize_value;"));
			}
			else
			{
				s = t.s("return " + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(";"));
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			content += Runtime.rtl.toStr(s);
		}
		if (f.flags != null && f.flags.isFlag("memorize"))
		{
			var s = "";
			s += Runtime.rtl.toStr(t.s("var __memorize_value = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.rtl")) + Runtime.rtl.toStr("._memorizeValue(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(f.name) + Runtime.rtl.toStr("\", arguments);")));
			s += Runtime.rtl.toStr(t.s("if (__memorize_value != " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.rtl")) + Runtime.rtl.toStr("._memorize_not_found) return __memorize_value;")));
			content = s + Runtime.rtl.toStr(content);
		}
		t = t.levelDec();
		content = t.s("{") + Runtime.rtl.toStr(content);
		content += Runtime.rtl.toStr(t.s("}"));
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([save_t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Operator";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6Operator);
window["BayLang.LangES6.TranslatorES6Operator"] = BayLang.LangES6.TranslatorES6Operator;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6Operator;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangES6 == 'undefined') BayLang.LangES6 = {};
BayLang.LangES6.TranslatorES6Program = function()
{
	Runtime.BaseStruct.apply(this, arguments);
};
BayLang.LangES6.TranslatorES6Program.prototype = Object.create(Runtime.BaseStruct.prototype);
BayLang.LangES6.TranslatorES6Program.prototype.constructor = BayLang.LangES6.TranslatorES6Program;
Object.assign(BayLang.LangES6.TranslatorES6Program.prototype,
{
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		return Runtime.BaseStruct.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangES6.TranslatorES6Program, Runtime.BaseStruct);
Object.assign(BayLang.LangES6.TranslatorES6Program,
{
	/**
	 * To pattern
	 */
	toPattern: function(t, pattern)
	{
		var names = t.expression.constructor.findModuleNames(t, pattern.entity_name.names);
		var e = Runtime.rs.join(".", names);
		var a = (pattern.template != null) ? (pattern.template.map((pattern) =>
		{
			return this.toPattern(t, pattern);
		})) : (null);
		var b = (a != null) ? (",\"t\":[" + Runtime.rtl.toStr(Runtime.rs.join(",", a)) + Runtime.rtl.toStr("]")) : ("");
		return "{\"e\":" + Runtime.rtl.toStr(t.expression.constructor.toString(e)) + Runtime.rtl.toStr(b) + Runtime.rtl.toStr("}");
	},
	/**
	 * OpNamespace
	 */
	OpNamespace: function(t, op_code)
	{
		var content = "";
		var name = "";
		var s = "";
		var arr = Runtime.rs.split(".", op_code.name);
		for (var i = 0; i < arr.count(); i++)
		{
			name = name + Runtime.rtl.toStr(((i == 0) ? ("") : ("."))) + Runtime.rtl.toStr(arr.item(i));
			s = "if (typeof " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr(" == 'undefined') ") + Runtime.rtl.toStr(name) + Runtime.rtl.toStr(" = {};");
			content += Runtime.rtl.toStr(t.s(s));
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_namespace_name"]), op_code.name);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction
	 */
	OpDeclareFunction: function(t, op_code)
	{
		var is_static_function = t.is_static_function;
		var is_static = op_code.isStatic();
		var content = "";
		if (op_code.isFlag("declare"))
		{
			return Runtime.Vector.from([t,""]);
		}
		if (!is_static && is_static_function || is_static && !is_static_function)
		{
			return Runtime.Vector.from([t,""]);
		}
		/* Set current function */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code);
		var is_async = "";
		if (op_code.isFlag("async") && t.isAsyncAwait())
		{
			is_async = "async ";
		}
		var s = "";
		var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code);
		var args = Runtime.rtl.attr(res, 1);
		s += Runtime.rtl.toStr(op_code.name + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(is_async) + Runtime.rtl.toStr("function(") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
		var res = t.operator.constructor.OpDeclareFunctionBody(t, op_code);
		s += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		s += Runtime.rtl.toStr(",");
		/* Function comments */
		var res = t.operator.constructor.AddComments(t, op_code.comments, t.s(s));
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClassConstructor: function(t, op_code)
	{
		var open = "";
		var content = "";
		var save_t = t;
		/* Set function name */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code.fn_create);
		/* Clear save op codes */
		t = t.constructor.clearSaveOpCode(t);
		if (op_code.fn_create == null)
		{
			open += Runtime.rtl.toStr(t.current_class_full_name + Runtime.rtl.toStr(" = "));
			open += Runtime.rtl.toStr("function()");
			open = t.s(open) + Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			/* Call parent */
			if (t.current_class_extends_name != "")
			{
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.useModuleName(t, t.current_class_extends_name) + Runtime.rtl.toStr(".apply(this, arguments);")));
			}
		}
		else
		{
			open += Runtime.rtl.toStr(t.current_class_full_name + Runtime.rtl.toStr(" = function("));
			var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code.fn_create);
			t = Runtime.rtl.attr(res, 0);
			open += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			open += Runtime.rtl.toStr(")");
			open = t.s(open) + Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
		}
		/* Function body */
		if (op_code.fn_create != null)
		{
			if (op_code.fn_create.args)
			{
				for (var i = 0; i < op_code.fn_create.args.count(); i++)
				{
					var arg = op_code.fn_create.args.item(i);
					if (arg.expression == null)
					{
						continue;
					}
					var res = t.expression.constructor.Expression(t, arg.expression);
					t = Runtime.rtl.attr(res, 0);
					var s = Runtime.rtl.attr(res, 1);
					s = "if (" + Runtime.rtl.toStr(arg.name) + Runtime.rtl.toStr(" == undefined) ") + Runtime.rtl.toStr(arg.name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";");
					content += Runtime.rtl.toStr(t.s(s));
				}
			}
			var res = t.operator.constructor.Operators(t, (op_code.fn_create.expression) ? (op_code.fn_create.expression) : (op_code.fn_create.items));
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Constructor end */
		content = open + Runtime.rtl.toStr(content);
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("};"));
		return Runtime.Vector.from([save_t,content]);
	},
	/**
	 * OpDeclareClassBodyItem
	 */
	OpDeclareClassBodyItem: function(t, item)
	{
		var content = "";
		if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			var res = t.operator.constructor.OpPreprocessorIfDef(t, item, BayLang.OpCodes.OpPreprocessorIfDef.KIND_CLASS_BODY);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpFunctionAnnotations
	 */
	OpFunctionAnnotations: function(t, f)
	{
		var content = "";
		if (f.flags.isFlag("declare"))
		{
			return Runtime.Vector.from([t,content]);
		}
		if (!f.annotations)
		{
			return Runtime.Vector.from([t,content]);
		}
		if (f.annotations.count() == 0)
		{
			return Runtime.Vector.from([t,content]);
		}
		content += Runtime.rtl.toStr(t.s("if (field_name == " + Runtime.rtl.toStr(t.expression.constructor.toString(f.name)) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		var s1 = "";
		t = t.levelInc();
		s1 += Runtime.rtl.toStr(t.s("var Vector = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Vector")) + Runtime.rtl.toStr(";")));
		s1 += Runtime.rtl.toStr(t.s("var Map = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Map")) + Runtime.rtl.toStr(";")));
		s1 += Runtime.rtl.toStr(t.s("return Map.from({"));
		t = t.levelInc();
		if (f.flags.isFlag("async"))
		{
			s1 += Runtime.rtl.toStr(t.s("\"async\": true,"));
		}
		s1 += Runtime.rtl.toStr(t.s("\"annotations\": Vector.from(["));
		t = t.levelInc();
		for (var j = 0; j < f.annotations.count(); j++)
		{
			var annotation = f.annotations.item(j);
			var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
			t = Runtime.rtl.attr(res, 0);
			var name = Runtime.rtl.attr(res, 1);
			var params = "";
			if (annotation.params != null)
			{
				var res = t.expression.constructor.OpDict(t, annotation.params, true);
				t = Runtime.rtl.attr(res, 0);
				params = Runtime.rtl.attr(res, 1);
			}
			s1 += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
		}
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("]),"));
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("});"));
		var save = t.constructor.outputSaveOpCode(t);
		if (save != "")
		{
			content += Runtime.rtl.toStr(t.s(save));
		}
		content += Runtime.rtl.toStr(s1);
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassBodyItemMethodsList
	 */
	OpClassBodyItemMethodsList: function(t, item)
	{
		var content = "";
		if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			if (Runtime.rtl.attr(t.preprocessor_flags, item.condition.value) == true)
			{
				for (var i = 0; i < item.items.count(); i++)
				{
					var op_code = item.items.item(i);
					var res = this.OpClassBodyItemMethodsList(t, op_code);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
		}
		else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			if (!item.flags.isFlag("declare") && !item.flags.isFlag("protected") && !item.flags.isFlag("private") && !(item.annotations == null) && !(item.annotations.count() == 0))
			{
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(item.name) + Runtime.rtl.toStr(",")));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassBodyItemAnnotations
	 */
	OpClassBodyItemAnnotations: function(t, item)
	{
		var content = "";
		if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			if (Runtime.rtl.attr(t.preprocessor_flags, item.condition.value) == true)
			{
				for (var i = 0; i < item.items.count(); i++)
				{
					var op_code = item.items.item(i);
					var res = this.OpClassBodyItemAnnotations(t, op_code);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
		}
		else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			var res = this.OpFunctionAnnotations(t, item);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Static variables
	 */
	OpDeclareClassStaticVariables: function(t, op_code)
	{
		var content = "";
		if (op_code.vars != null)
		{
			for (var i = 0; i < op_code.vars.count(); i++)
			{
				var variable = op_code.vars.item(i);
				if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
				{
					continue;
				}
				if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
				{
					continue;
				}
				var is_static = variable.flags.isFlag("static");
				if (!is_static)
				{
					continue;
				}
				for (var j = 0; j < variable.values.count(); j++)
				{
					var value = variable.values.item(j);
					var res = t.expression.constructor.Expression(t, value.expression);
					var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
					content += Runtime.rtl.toStr(t.s(value.var_name + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(",")));
				}
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Static functions
	 */
	OpDeclareClassStaticFunctions: function(t, op_code)
	{
		var content = "";
		/* Static Functions */
		if (op_code.functions != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), true);
			for (var i = 0; i < op_code.functions.count(); i++)
			{
				var f = op_code.functions.item(i);
				if (f.flags.isFlag("declare"))
				{
					continue;
				}
				if (!f.isStatic())
				{
					continue;
				}
				/* Set function name */
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), f);
				var is_async = "";
				if (f.isFlag("async") && t.isAsyncAwait())
				{
					is_async = "async ";
				}
				var s = "";
				var res = t.operator.constructor.OpDeclareFunctionArgs(t, f);
				var args = Runtime.rtl.attr(res, 1);
				s += Runtime.rtl.toStr(f.name + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(is_async) + Runtime.rtl.toStr("function(") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
				var res = t.operator.constructor.OpDeclareFunctionBody(t, f);
				s += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				s += Runtime.rtl.toStr(",");
				/* Function comments */
				var res = t.operator.constructor.AddComments(t, f.comments, t.s(s));
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		/* Items */
		if (op_code.items != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), true);
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.OpDeclareClassBodyItem(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClassBodyStatic: function(t, op_code)
	{
		var content = "";
		var class_kind = op_code.kind;
		var current_class_extends_name = t.expression.constructor.findModuleName(t, t.current_class_extends_name);
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		t = t.constructor.clearSaveOpCode(t);
		/* Returns parent class name */
		var parent_class_name = "";
		if (op_code.class_extends != null)
		{
			var res = t.expression.constructor.OpTypeIdentifier(t, op_code.class_extends);
			parent_class_name = Runtime.rtl.attr(res, 1);
		}
		/* Extends */
		if (current_class_extends_name != "" && !op_code.is_component)
		{
			content += Runtime.rtl.toStr(t.s("Object.assign(" + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, current_class_extends_name)) + Runtime.rtl.toStr(");")));
		}
		content += Runtime.rtl.toStr(t.s("Object.assign(" + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(",")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Static variables */
		var res = this.OpDeclareClassStaticVariables(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Static Functions */
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			var res = this.OpDeclareClassStaticFunctions(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Declare component functions */
		if (op_code.is_model || op_code.is_component)
		{
			var res = this.OpDeclareComponentFunctions(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Static init Functions */
		var res = this.OpDeclareClassStaticInitFunctions(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("});"));
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Static init functions
	 */
	OpDeclareClassStaticInitFunctions: function(t, op_code)
	{
		var content = "";
		var class_kind = op_code.kind;
		var current_class_extends_name = t.expression.constructor.findModuleName(t, t.current_class_extends_name);
		if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			/* Get current namespace function */
			content += Runtime.rtl.toStr(t.s("getNamespace: function()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_namespace_name)) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("},"));
			/* Get current class name function */
			content += Runtime.rtl.toStr(t.s("getClassName: function()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_class_full_name)) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("},"));
			return Runtime.Vector.from([t,content]);
		}
		if (op_code.is_component == false)
		{
			content += Runtime.rtl.toStr(t.s("/* ======================= Class Init Functions ======================= */"));
		}
		/* Get current namespace function */
		content += Runtime.rtl.toStr(t.s("getNamespace: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_namespace_name)) + Runtime.rtl.toStr(";")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get current class name function */
		content += Runtime.rtl.toStr(t.s("getClassName: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_class_full_name)) + Runtime.rtl.toStr(";")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get parent class name function */
		content += Runtime.rtl.toStr(t.s("getParentClassName: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(current_class_extends_name)) + Runtime.rtl.toStr(";")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Class info */
		content += Runtime.rtl.toStr(t.s("getClassInfo: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		t = t.constructor.clearSaveOpCode(t);
		var s1 = "";
		s1 += Runtime.rtl.toStr(t.s("var Vector = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Vector")) + Runtime.rtl.toStr(";")));
		s1 += Runtime.rtl.toStr(t.s("var Map = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Map")) + Runtime.rtl.toStr(";")));
		s1 += Runtime.rtl.toStr(t.s("return Map.from({"));
		t = t.levelInc();
		s1 += Runtime.rtl.toStr(t.s("\"annotations\": Vector.from(["));
		t = t.levelInc();
		for (var j = 0; j < op_code.annotations.count(); j++)
		{
			var annotation = op_code.annotations.item(j);
			var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
			t = Runtime.rtl.attr(res, 0);
			var name = Runtime.rtl.attr(res, 1);
			if (annotation.params != null)
			{
				var res = t.expression.constructor.OpDict(t, annotation.params, true);
				t = Runtime.rtl.attr(res, 0);
				var params = Runtime.rtl.attr(res, 1);
				s1 += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
			}
			else
			{
				s1 += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("(),")));
			}
		}
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("]),"));
		t = t.levelDec();
		s1 += Runtime.rtl.toStr(t.s("});"));
		var save = t.constructor.outputSaveOpCode(t);
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		content += Runtime.rtl.toStr(s1);
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get fields list of the function */
		t = t.constructor.clearSaveOpCode(t);
		content += Runtime.rtl.toStr(t.s("getFieldsList: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("var a = [];"));
		if (op_code.vars != null)
		{
			var vars = new Runtime.Map();
			for (var i = 0; i < op_code.vars.count(); i++)
			{
				var variable = op_code.vars.item(i);
				var is_const = variable.flags.isFlag("const");
				var is_static = variable.flags.isFlag("static");
				var is_protected = variable.flags.isFlag("protected");
				var is_private = variable.flags.isFlag("private");
				var is_serializable = variable.flags.isFlag("serializable");
				var is_assignable = true;
				var has_annotation = variable.annotations != null && variable.annotations.count() > 0;
				if (is_const || is_static)
				{
					continue;
				}
				if (is_protected || is_private)
				{
					continue;
				}
				if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
				{
					continue;
				}
				if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
				{
					if (variable.annotations == null)
					{
						continue;
					}
					if (variable.annotations.count() == 0)
					{
						continue;
					}
				}
				if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
				{
					continue;
				}
				for (var j = 0; j < variable.values.count(); j++)
				{
					var value = variable.values.item(j);
					content += Runtime.rtl.toStr(t.s("a.push(" + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(");")));
				}
			}
		}
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Vector")) + Runtime.rtl.toStr(".from(a);")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get field info by name */
		content += Runtime.rtl.toStr(t.s("getFieldInfoByName: function(field_name)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		if (op_code.vars != null)
		{
			content += Runtime.rtl.toStr(t.s("var Vector = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Vector")) + Runtime.rtl.toStr(";")));
			content += Runtime.rtl.toStr(t.s("var Map = " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Map")) + Runtime.rtl.toStr(";")));
			for (var i = 0; i < op_code.vars.count(); i++)
			{
				var variable = op_code.vars.item(i);
				if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
				{
					continue;
				}
				if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
				{
					continue;
				}
				var is_const = variable.flags.isFlag("const");
				var is_static = variable.flags.isFlag("static");
				var is_protected = variable.flags.isFlag("protected");
				var is_private = variable.flags.isFlag("private");
				if (is_const || is_static)
				{
					continue;
				}
				if (is_protected || is_private)
				{
					continue;
				}
				if (variable.annotations == null)
				{
					continue;
				}
				if (variable.annotations.count() == 0)
				{
					continue;
				}
				var v = variable.values.map((value) =>
				{
					return value.var_name;
				});
				v = v.map((var_name) =>
				{
					return "field_name == " + Runtime.rtl.toStr(t.expression.constructor.toString(var_name));
				});
				var var_type = Runtime.rs.join(".", t.expression.constructor.findModuleNames(t, variable.pattern.entity_name.names));
				var var_sub_types = (variable.pattern.template != null) ? (variable.pattern.template.map((op_code) =>
				{
					return Runtime.rs.join(".", t.expression.constructor.findModuleNames(t, op_code.entity_name.names));
				})) : (Runtime.Vector.from([]));
				var_sub_types = var_sub_types.map(t.expression.constructor.toString);
				t = t.constructor.clearSaveOpCode(t);
				var s1 = "";
				s1 += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(Runtime.rs.join(" or ", v)) + Runtime.rtl.toStr(") return Map.from({")));
				t = t.levelInc();
				s1 += Runtime.rtl.toStr(t.s("\"t\": " + Runtime.rtl.toStr(t.expression.constructor.toString(var_type)) + Runtime.rtl.toStr(",")));
				if (var_sub_types.count() > 0)
				{
					s1 += Runtime.rtl.toStr(t.s("\"s\": [" + Runtime.rtl.toStr(Runtime.rs.join(", ", var_sub_types)) + Runtime.rtl.toStr("],")));
				}
				s1 += Runtime.rtl.toStr(t.s("\"annotations\": Vector.from(["));
				t = t.levelInc();
				for (var j = 0; j < variable.annotations.count(); j++)
				{
					var annotation = variable.annotations.item(j);
					var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
					t = Runtime.rtl.attr(res, 0);
					var name = Runtime.rtl.attr(res, 1);
					var res = t.expression.constructor.OpDict(t, annotation.params, true);
					t = Runtime.rtl.attr(res, 0);
					var params = Runtime.rtl.attr(res, 1);
					s1 += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
				}
				t = t.levelDec();
				s1 += Runtime.rtl.toStr(t.s("]),"));
				t = t.levelDec();
				s1 += Runtime.rtl.toStr(t.s("});"));
				var save = t.constructor.outputSaveOpCode(t);
				if (save != "")
				{
					content += Runtime.rtl.toStr(save);
				}
				content += Runtime.rtl.toStr(s1);
			}
		}
		content += Runtime.rtl.toStr(t.s("return null;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get methods list of the function */
		t = t.constructor.clearSaveOpCode(t);
		content += Runtime.rtl.toStr(t.s("getMethodsList: function()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("var a=["));
		t = t.levelInc();
		if (op_code.functions != null)
		{
			for (var i = 0; i < op_code.functions.count(); i++)
			{
				var f = op_code.functions.item(i);
				if (f.flags.isFlag("declare"))
				{
					continue;
				}
				if (f.flags.isFlag("protected"))
				{
					continue;
				}
				if (f.flags.isFlag("private"))
				{
					continue;
				}
				if (f.annotations.count() == 0)
				{
					continue;
				}
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(f.name) + Runtime.rtl.toStr(",")));
			}
		}
		if (op_code.items != null)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.OpClassBodyItemMethodsList(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("];"));
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, "Runtime.Vector")) + Runtime.rtl.toStr(".from(a);")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Get method info by name */
		t = t.constructor.clearSaveOpCode(t);
		content += Runtime.rtl.toStr(t.s("getMethodInfoByName: function(field_name)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		if (op_code.functions != null)
		{
			for (var i = 0; i < op_code.functions.count(); i++)
			{
				var f = op_code.functions.item(i);
				var res = this.OpFunctionAnnotations(t, f);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		if (op_code.items != null)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.OpClassBodyItemAnnotations(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		content += Runtime.rtl.toStr(t.s("return null;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Add implements */
		if (op_code.class_implements != null && op_code.class_implements.count() > 0)
		{
			content += Runtime.rtl.toStr(t.s("__implements__:"));
			content += Runtime.rtl.toStr(t.s("["));
			t = t.levelInc();
			for (var i = 0; i < op_code.class_implements.count(); i++)
			{
				var item = op_code.class_implements.item(i);
				var module_name = item.entity_name.names.first();
				var s = t.expression.constructor.useModuleName(t, module_name);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(t.s(s + Runtime.rtl.toStr(",")));
			}
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("],"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Class variables
	 */
	OpDeclareClassInitVariables: function(t, op_code)
	{
		var content = "";
		var class_kind = op_code.kind;
		var vars = op_code.vars.filter((variable) =>
		{
			return !variable.flags.isFlag("static");
		});
		if (t.current_class_full_name != "Runtime.BaseObject" && vars.count() > 0)
		{
			content += Runtime.rtl.toStr(t.s("_init: function()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			/* Clear save op codes */
			var save_op_codes = t.save_op_codes;
			var save_op_code_inc = t.save_op_code_inc;
			if (t.current_class_extends_name != "")
			{
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.useModuleName(t, t.current_class_extends_name) + Runtime.rtl.toStr(".prototype._init.call(this);")));
			}
			var s1 = "";
			for (var i = 0; i < op_code.vars.count(); i++)
			{
				var variable = op_code.vars.item(i);
				var is_static = variable.flags.isFlag("static");
				if (is_static)
				{
					continue;
				}
				if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
				{
					continue;
				}
				if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
				{
					continue;
				}
				var prefix = "";
				if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
				{
					/* prefix = "__"; */
					prefix = "";
				}
				else if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_CLASS)
				{
					prefix = "";
				}
				for (var j = 0; j < variable.values.count(); j++)
				{
					var value = variable.values.item(j);
					var res = t.expression.constructor.Expression(t, value.expression);
					t = Runtime.rtl.attr(res, 0);
					var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
					s1 += Runtime.rtl.toStr(t.s("this." + Runtime.rtl.toStr(prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";")));
				}
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			/* Restore save op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
			/* Add content */
			content += Runtime.rtl.toStr(s1);
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("},"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Component props
	 */
	OpDeclareComponentProps: function(t, op_code)
	{
		var vars = op_code.vars.filter((variable) =>
		{
			return variable.flags.isFlag("props");
		});
		if (vars.count() == 0)
		{
			return Runtime.Vector.from([t,""]);
		}
		var content = "";
		content += Runtime.rtl.toStr(t.s("props: {"));
		t = t.levelInc();
		for (var i = 0; i < vars.count(); i++)
		{
			var variable = vars.item(i);
			if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				continue;
			}
			if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
			{
				continue;
			}
			for (var j = 0; j < variable.values.count(); j++)
			{
				var value = variable.values.item(j);
				var res = t.expression.constructor.Expression(t, value.expression);
				t = Runtime.rtl.attr(res, 0);
				var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(value.var_name) + Runtime.rtl.toStr(": {")));
				t = t.levelInc();
				content += Runtime.rtl.toStr(t.s("default: " + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(",")));
				t = t.levelDec();
				content += Runtime.rtl.toStr(t.s("},"));
			}
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Component variables
	 */
	OpDeclareComponentVariables: function(t, op_code)
	{
		var vars = op_code.vars.filter((variable) =>
		{
			return !variable.flags.isFlag("static") && !variable.flags.isFlag("props");
		});
		if (vars.count() == 0)
		{
			return Runtime.Vector.from([t,""]);
		}
		var content = "";
		content += Runtime.rtl.toStr(t.s("data: function ()"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return {"));
		t = t.levelInc();
		for (var i = 0; i < vars.count(); i++)
		{
			var variable = vars.item(i);
			if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				continue;
			}
			if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
			{
				continue;
			}
			for (var j = 0; j < variable.values.count(); j++)
			{
				var value = variable.values.item(j);
				var res = t.expression.constructor.Expression(t, value.expression);
				t = Runtime.rtl.attr(res, 0);
				var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
				content += Runtime.rtl.toStr(t.s(value.var_name + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(",")));
			}
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("};"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Declare component functions
	 */
	OpDeclareComponentFunctions: function(t, op_code)
	{
		var content = "";
		/* CSS */
		content += Runtime.rtl.toStr(t.s("css: function(vars)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("var res = \"\";"));
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.get(i);
			if (!(item instanceof BayLang.OpCodes.OpHtmlStyle))
			{
				continue;
			}
			var res = t.expression.constructor.Expression(t, item.value);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(t.s("res += Runtime.rtl.toStr(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(");")));
		}
		content += Runtime.rtl.toStr(t.s("return res;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		/* Widget data */
		/*
		OpWidget op_code_widget = op_code.items.findItem(lib::isInstance(classof OpWidget));
		OpHtmlMeta op_code_meta = op_code.items.findItem(lib::isInstance(classof OpHtmlMeta));
		if (op_code_widget)
		{
			content ~= t.s("getWidgetData: function()");
			content ~= t.s("{");
			t = t.levelInc();
			content ~= t.s("return {");
			t = t.levelInc();
			content ~= t.s("\"data\": null,");
			content ~= t.s("\"info\": null,");
			t = t.levelDec();
			content ~= t.s("};");
			t = t.levelDec();
			content ~= t.s("}");
		}
		*/
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Class functions
	 */
	OpDeclareClassFunctions: function(t, op_code)
	{
		var content = "";
		/* Functions */
		if (op_code.functions != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), false);
			for (var i = 0; i < op_code.functions.count(); i++)
			{
				var f = op_code.functions.item(i);
				if (f.flags.isFlag("declare"))
				{
					continue;
				}
				if (f.isStatic())
				{
					continue;
				}
				/* Set function name */
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), f);
				var is_async = "";
				if (f.isFlag("async") && t.isAsyncAwait())
				{
					is_async = "async ";
				}
				var s = "";
				var res = t.operator.constructor.OpDeclareFunctionArgs(t, f);
				var args = Runtime.rtl.attr(res, 1);
				s += Runtime.rtl.toStr(f.name + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(is_async) + Runtime.rtl.toStr("function(") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
				var res = t.operator.constructor.OpDeclareFunctionBody(t, f);
				s += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				s += Runtime.rtl.toStr(",");
				/* Function comments */
				var res = t.operator.constructor.AddComments(t, f.comments, t.s(s));
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		/* Items */
		if (op_code.items != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), false);
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.OpDeclareClassBodyItem(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Class assignObject function
	 */
	OpDeclareClassAssignObject: function(t, op_code)
	{
		var content = "";
		var var_prefix = "";
		/* Assign Object */
		content += Runtime.rtl.toStr(t.s("assignObject: function(o)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("if (o instanceof " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, t.current_class_full_name)) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		for (var i = 0; i < op_code.vars.count(); i++)
		{
			var variable = op_code.vars.item(i);
			if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				continue;
			}
			if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
			{
				continue;
			}
			var is_const = variable.flags.isFlag("const");
			var is_static = variable.flags.isFlag("static");
			var is_protected = variable.flags.isFlag("protected");
			var is_private = variable.flags.isFlag("private");
			if (is_const || is_static)
			{
				continue;
			}
			if (is_protected || is_private)
			{
				continue;
			}
			for (var j = 0; j < variable.values.count(); j++)
			{
				var value = variable.values.item(j);
				content += Runtime.rtl.toStr(t.s("this." + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = o.") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
			}
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		if (t.current_class_extends_name != "")
		{
			content += Runtime.rtl.toStr(t.s(t.expression.constructor.useModuleName(t, t.current_class_extends_name) + Runtime.rtl.toStr(".prototype.assignObject.call(this,o);")));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Class assignValue function
	 */
	OpDeclareClassAssignValue: function(t, op_code)
	{
		var content = "";
		var var_prefix = "";
		/* Assign Value */
		content += Runtime.rtl.toStr(t.s("assignValue: function(k,v)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var flag = false;
		for (var i = 0; i < op_code.vars.count(); i++)
		{
			var variable = op_code.vars.item(i);
			if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				continue;
			}
			if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
			{
				continue;
			}
			var is_const = variable.flags.isFlag("const");
			var is_static = variable.flags.isFlag("static");
			var is_protected = variable.flags.isFlag("protected");
			var is_private = variable.flags.isFlag("private");
			if (is_const || is_static)
			{
				continue;
			}
			if (is_protected || is_private)
			{
				continue;
			}
			for (var j = 0; j < variable.values.count(); j++)
			{
				var value = variable.values.item(j);
				if (t.flag_struct_check_types)
				{
					content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if (k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr("this.") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = Runtime.rtl.to(v, null, ") + Runtime.rtl.toStr(this.toPattern(t, variable.pattern)) + Runtime.rtl.toStr(");")));
				}
				else
				{
					content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if (k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr("this.") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = v;")));
				}
				flag = true;
			}
		}
		if (t.current_class_extends_name != "")
		{
			content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, t.current_class_extends_name)) + Runtime.rtl.toStr(".prototype.assignValue.call(this,k,v);")));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Class takeValue function
	 */
	OpDeclareClassTakeValue: function(t, op_code)
	{
		var content = "";
		var var_prefix = "";
		/* Take Value */
		content += Runtime.rtl.toStr(t.s("takeValue: function(k,d)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("if (d == undefined) d = null;"));
		var flag = false;
		for (var i = 0; i < op_code.vars.count(); i++)
		{
			var variable = op_code.vars.item(i);
			if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
			{
				continue;
			}
			if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
			{
				continue;
			}
			var is_const = variable.flags.isFlag("const");
			var is_static = variable.flags.isFlag("static");
			var is_protected = variable.flags.isFlag("protected");
			var is_private = variable.flags.isFlag("private");
			if (is_const || is_static)
			{
				continue;
			}
			if (is_protected || is_private)
			{
				continue;
			}
			for (var j = 0; j < variable.values.count(); j++)
			{
				var value = variable.values.item(j);
				content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if (k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")return this.") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
				flag = true;
			}
		}
		if (t.current_class_extends_name != "")
		{
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, t.current_class_extends_name)) + Runtime.rtl.toStr(".prototype.takeValue.call(this,k,d);")));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClassBody: function(t, op_code)
	{
		var content = "";
		var class_kind = op_code.kind;
		content += Runtime.rtl.toStr(t.s("Object.assign(" + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".prototype,")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Functions */
		var res = this.OpDeclareClassFunctions(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Init variables */
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE && op_code.vars != null)
		{
			var res = this.OpDeclareClassInitVariables(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Init struct */
		if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT && op_code.vars != null)
		{
			/* Assign object */
			/*
			list res = static::OpDeclareClassAssignObject(t, op_code);
			t = res[0];
			content ~= res[1];
			*/
			/* Assign value */
			/*
			list res = static::OpDeclareClassAssignValue(t, op_code);
			t = res[0];
			content ~= res[1];
			*/
			/* Take Value */
			var res = this.OpDeclareClassTakeValue(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("});"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClassFooter
	 */
	OpDeclareClassFooter: function(t, op_code)
	{
		var content = "";
		var rtl_module_name = t.expression.constructor.useModuleName(t, "Runtime.rtl");
		if (!t.use_module_name)
		{
			content += Runtime.rtl.toStr(t.s(rtl_module_name + Runtime.rtl.toStr(".defClass(") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(");")));
			content += Runtime.rtl.toStr(t.s("window[\"" + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr("\"] = ") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(";")));
		}
		content += Runtime.rtl.toStr(t.s("if (typeof module != \"undefined\" && typeof module.exports != \"undefined\") " + Runtime.rtl.toStr("module.exports = ") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(";")));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareComponent
	 */
	OpDeclareComponent: function(t, op_code)
	{
		var content = "";
		content += Runtime.rtl.toStr(t.s(t.current_class_full_name + Runtime.rtl.toStr(" = {")));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("name: " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_class_full_name)) + Runtime.rtl.toStr(",")));
		if (t.current_class_extends_name && t.current_class_extends_name != "Runtime.BaseObject")
		{
			content += Runtime.rtl.toStr(t.s("extends: " + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, t.current_class_extends_name)) + Runtime.rtl.toStr(",")));
		}
		/* Props */
		var res = this.OpDeclareComponentProps(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Variables */
		var res = this.OpDeclareComponentVariables(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Methods */
		content += Runtime.rtl.toStr(t.s("methods:"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.OpDeclareClassFunctions(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("},"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("};"));
		/* Class static functions */
		var res = this.OpDeclareClassBodyStatic(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Class footer */
		var res = this.OpDeclareClassFooter(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClass: function(t, op_code)
	{
		if (op_code.is_abstract)
		{
			return Runtime.Vector.from([t,""]);
		}
		if (op_code.is_declare)
		{
			throw new BayLang.Exceptions.DeclaredClass()
			return Runtime.Vector.from([t,""]);
		}
		var content = "";
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class"]), op_code);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_name"]), op_code.name);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_full_name"]), t.current_namespace_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(t.current_class_name));
		if (op_code.class_extends != null)
		{
			var extends_name = Runtime.rs.join(".", op_code.class_extends.entity_name.names);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_extends_name"]), extends_name);
		}
		else if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_extends_name"]), "Runtime.BaseStruct");
		}
		if (op_code.is_component)
		{
			return this.OpDeclareComponent(t, op_code);
		}
		/* Constructor */
		var res = this.OpDeclareClassConstructor(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Extends */
		if (op_code.class_extends != null)
		{
			content += Runtime.rtl.toStr(t.s(t.current_class_full_name + Runtime.rtl.toStr(".prototype = Object.create(") + Runtime.rtl.toStr(t.expression.constructor.useModuleName(t, t.current_class_extends_name)) + Runtime.rtl.toStr(".prototype);")));
			content += Runtime.rtl.toStr(t.s(t.current_class_full_name + Runtime.rtl.toStr(".prototype.constructor = ") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(";")));
		}
		/* Class body */
		var res = this.OpDeclareClassBody(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Class static functions */
		var res = this.OpDeclareClassBodyStatic(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Class comments */
		var res = t.operator.constructor.AddComments(t, op_code.comments, content);
		content = Runtime.rtl.attr(res, 1);
		/* Class footer */
		var res = this.OpDeclareClassFooter(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translate item
	 */
	translateItem: function(t, op_code)
	{
		if (op_code instanceof BayLang.OpCodes.OpNamespace)
		{
			return this.OpNamespace(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDeclareClass)
		{
			return this.OpDeclareClass(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpComment)
		{
			return t.operator.constructor.OpComment(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfCode)
		{
			return t.operator.constructor.OpPreprocessorIfCode(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorSwitch)
		{
			var content = "";
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var res = t.operator.constructor.OpPreprocessorIfCode(t, op_code.items.item(i));
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
			return Runtime.Vector.from([t,content]);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * Translate program
	 */
	translateProgramHeader: function(t, op_code)
	{
		var content = "";
		if (t.use_strict)
		{
			content = t.s("\"use strict;\"");
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Remove ctx
	 */
	removeContext: function(content)
	{
		content = Runtime.rs.replace("(" + Runtime.rtl.toStr("ctx)"), "()", content);
		content = Runtime.rs.replace("(" + Runtime.rtl.toStr("ctx, "), "(", content);
		content = Runtime.rs.replace("(" + Runtime.rtl.toStr("ctx,"), "(", content);
		content = Runtime.rs.replace("," + Runtime.rtl.toStr("ctx,"), ",", content);
		content = Runtime.rs.replace("this," + Runtime.rtl.toStr("ctx"), "this", content);
		content = Runtime.rs.replace("this," + Runtime.rtl.toStr(" ctx"), "this", content);
		return content;
	},
	/**
	 * Translate program
	 */
	translateProgram: function(t, op_code)
	{
		var content = "";
		if (op_code == null)
		{
			return Runtime.Vector.from([t,content]);
		}
		if (op_code.uses != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["modules"]), op_code.uses);
		}
		if (op_code.items != null)
		{
			var res = this.translateProgramHeader(t, op_code);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.translateItem(t, item);
				t = Runtime.rtl.attr(res, 0);
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
		}
		content = Runtime.rs.trim(content);
		/* Disable context */
		if (t.enable_context == false)
		{
			content = this.removeContext(content);
		}
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangES6";
	},
	getClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Program";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseStruct";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangES6.TranslatorES6Program);
window["BayLang.LangES6.TranslatorES6Program"] = BayLang.LangES6.TranslatorES6Program;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangES6.TranslatorES6Program;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangPHP == 'undefined') BayLang.LangPHP = {};
BayLang.LangPHP.TranslatorPHP = function()
{
	BayLang.CoreTranslator.apply(this, arguments);
};
BayLang.LangPHP.TranslatorPHP.prototype = Object.create(BayLang.CoreTranslator.prototype);
BayLang.LangPHP.TranslatorPHP.prototype.constructor = BayLang.LangPHP.TranslatorPHP;
Object.assign(BayLang.LangPHP.TranslatorPHP.prototype,
{
	_init: function()
	{
		BayLang.CoreTranslator.prototype._init.call(this);
		this.is_pipe = false;
		this.pipe_var_name = "";
		this.html_var_name = "";
		this.is_html = false;
		this.expression = null;
		this.html = null;
		this.operator = null;
		this.program = null;
		this.frontend = false;
		this.backend = true;
		this.enable_context = false;
		this.enable_check_types = false;
		this.enable_introspection = true;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "is_pipe")return this.is_pipe;
		else if (k == "pipe_var_name")return this.pipe_var_name;
		else if (k == "html_var_name")return this.html_var_name;
		else if (k == "is_html")return this.is_html;
		else if (k == "expression")return this.expression;
		else if (k == "html")return this.html;
		else if (k == "operator")return this.operator;
		else if (k == "program")return this.program;
		else if (k == "frontend")return this.frontend;
		else if (k == "backend")return this.backend;
		else if (k == "enable_context")return this.enable_context;
		else if (k == "enable_check_types")return this.enable_check_types;
		else if (k == "enable_introspection")return this.enable_introspection;
		return BayLang.CoreTranslator.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangPHP.TranslatorPHP, BayLang.CoreTranslator);
Object.assign(BayLang.LangPHP.TranslatorPHP,
{
	/**
	 * Reset translator
	 */
	reset: function(t)
	{
		return t.copy(Runtime.Map.from({"value":"","current_namespace_name":"","modules":new Runtime.Dict(),"expression":new BayLang.LangPHP.TranslatorPHPExpression(),"html":new BayLang.LangPHP.TranslatorPHPHtml(),"operator":new BayLang.LangPHP.TranslatorPHPOperator(),"program":new BayLang.LangPHP.TranslatorPHPProgram(),"save_vars":new Runtime.Collection(),"save_op_codes":new Runtime.Collection(),"save_op_code_inc":0,"preprocessor_flags":Runtime.Map.from({"PHP":true,"FRONTEND":t.frontend,"BACKEND":t.backend,"ENABLE_CONTEXT":t.enable_context,"ENABLE_CHECK_TYPES":t.enable_check_types})}));
	},
	/**
	 * Translate BaseOpCode
	 */
	translate: function(t, op_code)
	{
		t = this.reset(t);
		return t.program.constructor.translateProgram(t, op_code);
	},
	/**
	 * Inc save op code
	 */
	nextSaveOpCode: function(t)
	{
		return "$__v" + Runtime.rtl.toStr(t.save_op_code_inc);
	},
	/**
	 * Output save op code content
	 */
	outputSaveOpCode: function(t, save_op_code_value)
	{
		if (save_op_code_value == undefined) save_op_code_value = 0;
		var content = "";
		for (var i = 0; i < t.save_op_codes.count(); i++)
		{
			if (i < save_op_code_value)
			{
				continue;
			}
			var save = t.save_op_codes.item(i);
			var s = (save.content == "") ? (t.s(save.var_name + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(save.var_content) + Runtime.rtl.toStr(";"))) : (save.content);
			content += Runtime.rtl.toStr(s);
		}
		return content;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangPHP";
	},
	getClassName: function()
	{
		return "BayLang.LangPHP.TranslatorPHP";
	},
	getParentClassName: function()
	{
		return "BayLang.CoreTranslator";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("is_pipe");
		a.push("pipe_var_name");
		a.push("html_var_name");
		a.push("is_html");
		a.push("expression");
		a.push("html");
		a.push("operator");
		a.push("program");
		a.push("frontend");
		a.push("backend");
		a.push("enable_context");
		a.push("enable_check_types");
		a.push("enable_introspection");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangPHP.TranslatorPHP);
window["BayLang.LangPHP.TranslatorPHP"] = BayLang.LangPHP.TranslatorPHP;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangPHP.TranslatorPHP;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangPHP == 'undefined') BayLang.LangPHP = {};
BayLang.LangPHP.TranslatorPHPExpression = function()
{
};
Object.assign(BayLang.LangPHP.TranslatorPHPExpression.prototype,
{
});
Object.assign(BayLang.LangPHP.TranslatorPHPExpression,
{
	/**
	 * Returns string
	 */
	toString: function(s)
	{
		s = Runtime.re.replace("\\\\", "\\\\", s);
		s = Runtime.re.replace("\"", "\\\"", s);
		s = Runtime.re.replace("\n", "\\n", s);
		s = Runtime.re.replace("\r", "\\r", s);
		s = Runtime.re.replace("\t", "\\t", s);
		s = Runtime.re.replace("\\$", "\\$", s);
		return "\"" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr("\"");
	},
	/**
	 * To pattern
	 */
	toPattern: function(t, pattern)
	{
		var names = this.findModuleNames(t, pattern.entity_name.names);
		var e = Runtime.rs.join(".", names);
		var a = (pattern.template != null) ? (pattern.template.map((pattern) =>
		{
			return this.toPattern(t, pattern);
		})) : (null);
		var b = (a != null) ? (",\"t\":[" + Runtime.rtl.toStr(Runtime.rs.join(",", a)) + Runtime.rtl.toStr("]")) : ("");
		return "[\"e\"=>" + Runtime.rtl.toStr(this.toString(e)) + Runtime.rtl.toStr(b) + Runtime.rtl.toStr("]");
	},
	/**
	 * Returns string
	 */
	rtlToStr: function(t, s)
	{
		var module_name = this.getModuleName(t, "rtl");
		return module_name + Runtime.rtl.toStr("::toStr(") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(")");
	},
	/**
	 * Find module name
	 */
	findModuleName: function(t, module_name)
	{
		if (module_name == "Collection")
		{
			return "Runtime.Collection";
		}
		else if (module_name == "Dict")
		{
			return "Runtime.Dict";
		}
		else if (module_name == "Map")
		{
			return "Runtime.Map";
		}
		else if (module_name == "Vector")
		{
			return "Runtime.Vector";
		}
		else if (module_name == "rs")
		{
			return "Runtime.rs";
		}
		else if (module_name == "rtl")
		{
			return "Runtime.rtl";
		}
		else if (module_name == "ArrayInterface")
		{
			return "ArrayAccess";
		}
		else if (t.modules.has(module_name))
		{
			return t.modules.item(module_name);
		}
		return module_name;
	},
	/**
	 * Returns module name
	 */
	findModuleNames: function(t, names)
	{
		if (names.count() > 0)
		{
			var module_name = names.first();
			module_name = this.findModuleName(t, module_name);
			if (module_name != "")
			{
				names = Runtime.rs.split(".", module_name).concat(names.slice(1));
			}
		}
		return names;
	},
	/**
	 * Return module name
	 */
	getModuleName: function(t, module_name)
	{
		module_name = this.findModuleName(t, module_name);
		module_name = Runtime.re.replace("\\.", "\\", module_name);
		return "\\" + Runtime.rtl.toStr(module_name);
	},
	/**
	 * Return module name
	 */
	getModuleNames: function(t, names)
	{
		return "\\" + Runtime.rtl.toStr(Runtime.rs.join("\\", this.findModuleNames(t, names)));
	},
	/**
	 * OpTypeIdentifier
	 */
	OpTypeIdentifier: function(t, op_code)
	{
		var names = this.findModuleNames(t, op_code.entity_name.names);
		var s = "\\" + Runtime.rtl.toStr(Runtime.rs.join("\\", names));
		return Runtime.Vector.from([t,s]);
	},
	/**
	 * OpIdentifier
	 */
	OpIdentifier: function(t, op_code)
	{
		if (op_code.value == "@")
		{
			if (t.enable_context == false)
			{
				return Runtime.Vector.from([t,"\\Runtime\\rtl::getContext()"]);
			}
			else
			{
				return Runtime.Vector.from([t,"$ctx"]);
			}
		}
		if (op_code.value == "_")
		{
			if (t.enable_context == false)
			{
				return Runtime.Vector.from([t,"\\Runtime\\rtl::getContext()->translate"]);
			}
			else
			{
				return Runtime.Vector.from([t,"$ctx->translate"]);
			}
		}
		if (op_code.value == "@")
		{
			return Runtime.Vector.from([t,"$ctx"]);
		}
		if (op_code.value == "_")
		{
			return Runtime.Vector.from([t,"$ctx->translate"]);
		}
		if (op_code.value == "log")
		{
			return Runtime.Vector.from([t,"var_dump"]);
		}
		if (t.modules.has(op_code.value) || op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE)
		{
			var module_name = op_code.value;
			var new_module_name = this.getModuleName(t, module_name);
			return Runtime.Vector.from([t,new_module_name]);
		}
		else if (op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_VARIABLE)
		{
			var content = op_code.value;
			return Runtime.Vector.from([t,"$" + Runtime.rtl.toStr(content)]);
		}
		else if (op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_CLASSREF)
		{
			var content = op_code.value;
			if (content == "this")
			{
				content = "$this";
			}
			return Runtime.Vector.from([t,content]);
		}
		var content = op_code.value;
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNumber
	 */
	OpNumber: function(t, op_code)
	{
		var content = op_code.value;
		/*if (op_code.negative)
		{
			content = "-" ~ content;
			t <= opcode_level <= 15;
		}*/
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNegative
	 */
	OpNegative: function(t, op_code)
	{
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var content = Runtime.rtl.attr(res, 1);
		content = "-" + Runtime.rtl.toStr(content);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 15);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpString
	 */
	OpString: function(t, op_code)
	{
		return Runtime.Vector.from([t,this.toString(op_code.value)]);
	},
	/**
	 * OpCollection
	 */
	OpCollection: function(t, op_code)
	{
		var content = "";
		var values = op_code.values.map((op_code) =>
		{
			var res = this.Expression(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			return s;
		});
		values = values.filter((s) =>
		{
			return s != "";
		});
		var module_name = this.getModuleName(t, "Vector");
		content = module_name + Runtime.rtl.toStr("::from([") + Runtime.rtl.toStr(Runtime.rs.join(",", values)) + Runtime.rtl.toStr("])");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDict
	 */
	OpDict: function(t, op_code, flag_array)
	{
		if (flag_array == undefined) flag_array = false;
		var content = "";
		var values = op_code.values.map((pair, key) =>
		{
			if (pair.condition != null && Runtime.rtl.attr(t.preprocessor_flags, pair.condition.value) != true)
			{
				return "";
			}
			var res = this.Expression(t, pair.value);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			return this.toString(pair.key) + Runtime.rtl.toStr("=>") + Runtime.rtl.toStr(s);
		});
		values = values.filter((s) =>
		{
			return s != "";
		});
		var module_name = this.getModuleName(t, "Map");
		if (!flag_array)
		{
			content = module_name + Runtime.rtl.toStr("::from([") + Runtime.rtl.toStr(Runtime.rs.join(",", values)) + Runtime.rtl.toStr("])");
		}
		else
		{
			content = "[" + Runtime.rtl.toStr(Runtime.rs.join(",", values)) + Runtime.rtl.toStr("]");
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Dynamic
	 */
	Dynamic: function(t, op_code, next_op_code)
	{
		if (next_op_code == undefined) next_op_code = null;
		if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			return this.OpIdentifier(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			var attrs = new Runtime.Vector();
			var op_code_item = op_code;
			var op_code_next = op_code;
			var prev_kind = "";
			var s = "";
			var first_item_complex = false;
			while (op_code_next instanceof BayLang.OpCodes.OpAttr)
			{
				attrs.push(op_code_next);
				op_code_item = op_code_next;
				op_code_next = op_code_next.obj;
			}
			attrs = attrs.reverse();
			if (op_code_next instanceof BayLang.OpCodes.OpCall)
			{
				prev_kind = "var";
				var res = this.OpCall(t, op_code_next);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
				first_item_complex = true;
			}
			else if (op_code_next instanceof BayLang.OpCodes.OpNew)
			{
				prev_kind = "var";
				var res = this.OpNew(t, op_code_next);
				t = Runtime.rtl.attr(res, 0);
				s = "(" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				first_item_complex = true;
			}
			else if (op_code_next instanceof BayLang.OpCodes.OpCollection)
			{
				prev_kind = "var";
				var res = this.OpCollection(t, op_code_next);
				t = Runtime.rtl.attr(res, 0);
				s = "(" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				first_item_complex = true;
			}
			else if (op_code_next instanceof BayLang.OpCodes.OpDict)
			{
				prev_kind = "var";
				var res = this.OpDict(t, op_code_next);
				t = Runtime.rtl.attr(res, 0);
				s = "(" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				first_item_complex = true;
			}
			else if (op_code_next instanceof BayLang.OpCodes.OpIdentifier)
			{
				if (op_code_next.kind == BayLang.OpCodes.OpIdentifier.KIND_CLASSREF)
				{
					if (op_code_next.value == "static")
					{
						s = "static";
						prev_kind = "static";
					}
					else if (op_code_next.value == "parent")
					{
						s = "parent";
						prev_kind = "static";
					}
					else if (op_code_next.value == "self")
					{
						prev_kind = "static";
						s = this.getModuleName(t, t.current_class_full_name);
					}
					else if (op_code_next.value == "this")
					{
						prev_kind = "var";
						s = "$this";
					}
				}
				else if (op_code_next.kind == BayLang.OpCodes.OpIdentifier.KIND_PIPE)
				{
					prev_kind = "var";
					var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":t.pipe_var_name + Runtime.rtl.toStr("->val")}));
					t = Runtime.rtl.attr(res, 0);
					s = Runtime.rtl.attr(res, 1);
					prev_kind = "static";
				}
				else
				{
					var res = this.OpIdentifier(t, op_code_next);
					t = Runtime.rtl.attr(res, 0);
					s = Runtime.rtl.attr(res, 1);
					prev_kind = "var";
					if (t.modules.has(op_code_next.value) || op_code_next.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE)
					{
						prev_kind = "static";
					}
				}
			}
			if (first_item_complex && t.is_pipe)
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":s}));
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
			}
			var attrs_sz = attrs.count();
			for (var i = 0; i < attrs.count(); i++)
			{
				var attr = attrs.item(i);
				var next_attr = attrs.get(i + 1, null);
				if (attr.kind == BayLang.OpCodes.OpAttr.KIND_ATTR)
				{
					/* Pipe */
					if (t.is_pipe && !(next_op_code instanceof BayLang.OpCodes.OpCall))
					{
						if (i == attrs_sz - 1)
						{
							var val2 = this.toString(attr.value.value);
							s = "new \\Runtime\\Callback(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(val2) + Runtime.rtl.toStr(")");
						}
						else
						{
							s += Runtime.rtl.toStr("->" + Runtime.rtl.toStr(attr.value.value));
						}
					}
					else
					{
						s += Runtime.rtl.toStr("->" + Runtime.rtl.toStr(attr.value.value));
					}
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_STATIC)
				{
					if (prev_kind == "static")
					{
						var attr_val = attr.value.value;
						if (i == attrs_sz - 1 && next_op_code instanceof BayLang.OpCodes.OpCall)
						{
							s += Runtime.rtl.toStr("::" + Runtime.rtl.toStr(attr_val));
						}
						else if (Runtime.rs.upper(attr_val) == attr_val)
						{
							s += Runtime.rtl.toStr("::" + Runtime.rtl.toStr(attr_val));
						}
						else
						{
							var val1;
							if (s == "static")
							{
								val1 = "static::class";
							}
							else
							{
								val1 = s + Runtime.rtl.toStr("::class");
							}
							var val2 = this.toString(attr_val);
							s = "new \\Runtime\\Callback(" + Runtime.rtl.toStr(val1) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(val2) + Runtime.rtl.toStr(")");
						}
					}
					else
					{
						s = s + Runtime.rtl.toStr("::") + Runtime.rtl.toStr(attr.value.value);
					}
					prev_kind = "static";
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC)
				{
					var res = this.Expression(t, attr.value);
					t = Runtime.rtl.attr(res, 0);
					/* s ~= "[" ~ res[1] ~ "]"; */
					s = "\\Runtime\\rtl::attr($ctx, " + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(")");
				}
				else if (attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS)
				{
					var items = new Runtime.Vector();
					if (attr.attrs != null)
					{
						for (var j = 0; j < attr.attrs.count(); j++)
						{
							var res = this.Expression(t, Runtime.rtl.attr(attr.attrs, j));
							t = Runtime.rtl.attr(res, 0);
							items.push(Runtime.rtl.attr(res, 1));
						}
					}
					s = "\\Runtime\\rtl::attr($ctx, " + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(", [") + Runtime.rtl.toStr(Runtime.rs.join(", ", items)) + Runtime.rtl.toStr("])");
				}
			}
			return Runtime.Vector.from([t,s]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCurry)
		{
			var res = this.OpCurry(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var content = Runtime.rtl.attr(res, 1);
			var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":content}));
			t = Runtime.rtl.attr(res, 0);
			var var_name = Runtime.rtl.attr(res, 1);
			return Runtime.Vector.from([t,var_name]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			return this.OpCall(t, op_code);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * OpInc
	 */
	OpInc: function(t, op_code)
	{
		var content = "";
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var s = Runtime.rtl.attr(res, 1);
		if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_INC)
		{
			content = "++$" + Runtime.rtl.toStr(s);
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_PRE_DEC)
		{
			content = "--$" + Runtime.rtl.toStr(s);
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_INC)
		{
			content = "$" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr("++");
		}
		else if (op_code.kind == BayLang.OpCodes.OpInc.KIND_POST_DEC)
		{
			content = "$" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr("--");
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpMath
	 */
	OpMath: function(t, op_code)
	{
		var res = this.Expression(t, op_code.value1);
		t = Runtime.rtl.attr(res, 0);
		var opcode_level1 = Runtime.rtl.attr(res, 0).opcode_level;
		var s1 = Runtime.rtl.attr(res, 1);
		var op = "";
		var op_math = op_code.math;
		var opcode_level = 0;
		if (op_code.math == "!")
		{
			opcode_level = 16;
			op = "!";
		}
		if (op_code.math == ">>")
		{
			opcode_level = 12;
			op = ">>";
		}
		if (op_code.math == "<<")
		{
			opcode_level = 12;
			op = "<<";
		}
		if (op_code.math == "&")
		{
			opcode_level = 9;
			op = "&";
		}
		if (op_code.math == "xor")
		{
			opcode_level = 8;
			op = "^";
		}
		if (op_code.math == "|")
		{
			opcode_level = 7;
			op = "|";
		}
		if (op_code.math == "*")
		{
			opcode_level = 14;
			op = "*";
		}
		if (op_code.math == "/")
		{
			opcode_level = 14;
			op = "/";
		}
		if (op_code.math == "%")
		{
			opcode_level = 14;
			op = "%";
		}
		if (op_code.math == "div")
		{
			opcode_level = 14;
			op = "div";
		}
		if (op_code.math == "mod")
		{
			opcode_level = 14;
			op = "mod";
		}
		if (op_code.math == "+")
		{
			opcode_level = 13;
			op = "+";
		}
		if (op_code.math == "-")
		{
			opcode_level = 13;
			op = "-";
		}
		if (op_code.math == "~")
		{
			opcode_level = 13;
			op = "+";
		}
		if (op_code.math == "!")
		{
			opcode_level = 13;
			op = "!";
		}
		if (op_code.math == "===")
		{
			opcode_level = 10;
			op = "===";
		}
		if (op_code.math == "!==")
		{
			opcode_level = 10;
			op = "!==";
		}
		if (op_code.math == "==")
		{
			opcode_level = 10;
			op = "==";
		}
		if (op_code.math == "!=")
		{
			opcode_level = 10;
			op = "!=";
		}
		if (op_code.math == ">=")
		{
			opcode_level = 10;
			op = ">=";
		}
		if (op_code.math == "<=")
		{
			opcode_level = 10;
			op = "<=";
		}
		if (op_code.math == ">")
		{
			opcode_level = 10;
			op = ">";
		}
		if (op_code.math == "<")
		{
			opcode_level = 10;
			op = "<";
		}
		if (op_code.math == "is")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "instanceof")
		{
			opcode_level = 10;
			op = "instanceof";
		}
		if (op_code.math == "implements")
		{
			opcode_level = 10;
			op = "implements";
		}
		if (op_code.math == "not")
		{
			opcode_level = 16;
			op = "!";
		}
		if (op_code.math == "and")
		{
			opcode_level = 6;
			op = "&&";
		}
		if (op_code.math == "&&")
		{
			opcode_level = 6;
			op = "&&";
		}
		if (op_code.math == "or")
		{
			opcode_level = 5;
			op = "||";
		}
		if (op_code.math == "||")
		{
			opcode_level = 5;
			op = "||";
		}
		var content = "";
		if (op_code.math == "!" || op_code.math == "not")
		{
			content = op + Runtime.rtl.toStr(t.o(s1, opcode_level1, opcode_level));
		}
		else
		{
			var res = this.Expression(t, op_code.value2);
			t = Runtime.rtl.attr(res, 0);
			var opcode_level2 = Runtime.rtl.attr(res, 0).opcode_level;
			var s2 = Runtime.rtl.attr(res, 1);
			var op1 = t.o(s1, opcode_level1, opcode_level);
			var op2 = t.o(s2, opcode_level2, opcode_level);
			if (op_math == "~")
			{
				content = op1 + Runtime.rtl.toStr(" . ") + Runtime.rtl.toStr(this.rtlToStr(t, op2));
			}
			else if (op_math == "implements")
			{
				content = op1 + Runtime.rtl.toStr(" instanceof ") + Runtime.rtl.toStr(op2);
			}
			else
			{
				content = op1 + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(op2);
			}
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), opcode_level);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpMethod
	 */
	OpMethod: function(t, op_code)
	{
		var content = "";
		var res = this.OpIdentifier(t, op_code.value1);
		t = Runtime.rtl.attr(res, 0);
		var val1 = Runtime.rtl.attr(res, 1);
		var val2 = op_code.value2;
		if (op_code.kind == BayLang.OpCodes.OpMethod.KIND_STATIC)
		{
			val1 = val1 + Runtime.rtl.toStr("->getClassName()");
		}
		else if (op_code.kind == BayLang.OpCodes.OpMethod.KIND_CLASS)
		{
			val1 = val1 + Runtime.rtl.toStr("::class");
		}
		var content = "new \\Runtime\\Callback(" + Runtime.rtl.toStr(val1) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(this.toString(val2)) + Runtime.rtl.toStr(")");
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 0);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpNew
	 */
	OpNew: function(t, op_code)
	{
		var content = "new ";
		var res = this.OpTypeIdentifier(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		var flag = false;
		content += Runtime.rtl.toStr("(");
		if (t.current_function == null || t.current_function.is_context)
		{
			content += Runtime.rtl.toStr("$ctx");
			flag = true;
		}
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = t.expression.constructor.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpCurry
	 */
	OpCurry: function(t, op_code)
	{
		var content = "";
		var s = "";
		var args_use = new Runtime.Vector();
		var args = op_code.args.filter((arg) =>
		{
			return arg instanceof BayLang.OpCodes.OpCurryArg;
		}).sort((arg1, arg2) =>
		{
			return (arg1.pos > arg2.pos) ? (1) : ((arg1.pos < arg2.pos) ? (-1) : (0));
		});
		var use_obj_item = "";
		if (op_code.obj instanceof BayLang.OpCodes.OpIdentifier)
		{
			if (op_code.obj.kind == BayLang.OpCodes.OpIdentifier.KIND_VARIABLE)
			{
				use_obj_item = "$" + Runtime.rtl.toStr(op_code.obj.value);
			}
		}
		var args_sz = op_code.args.count();
		for (var i = 0; i < args_sz; i++)
		{
			var arg = op_code.args.item(i);
			if (arg instanceof BayLang.OpCodes.OpCurryArg)
			{
				continue;
			}
			if (arg instanceof BayLang.OpCodes.OpIdentifier)
			{
				args_use.push("$" + Runtime.rtl.toStr(arg.value));
			}
		}
		var args_sz = args.count();
		for (var i = 0; i < args_sz; i++)
		{
			var arg = args.item(i);
			var s_use = "";
			var arr_use = new Runtime.Vector();
			arr_use.appendItems(args_use);
			for (var j = 0; j < i; j++)
			{
				var arg_use = args.item(j);
				arr_use.push("$__varg" + Runtime.rtl.toStr(arg_use.pos));
			}
			if (use_obj_item != "")
			{
				arr_use.push(use_obj_item);
			}
			if (arr_use.count() > 0)
			{
				s_use = " use (" + Runtime.rtl.toStr(Runtime.rs.join(", ", arr_use)) + Runtime.rtl.toStr(")");
			}
			if (args_sz - 1 == i)
			{
				content += Runtime.rtl.toStr("function ($ctx, $__varg" + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr(s_use) + Runtime.rtl.toStr("{return "));
			}
			else
			{
				content += Runtime.rtl.toStr("function ($__ctx" + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(", $__varg") + Runtime.rtl.toStr(arg.pos) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr(s_use) + Runtime.rtl.toStr("{return "));
			}
		}
		var flag = false;
		var res = this.Dynamic(t, op_code.obj, op_code);
		t = Runtime.rtl.attr(res, 0);
		s = Runtime.rtl.attr(res, 1);
		if (s == "parent")
		{
			var f_name = t.current_function.name;
			if (f_name == "constructor")
			{
				f_name = "__construct";
			}
			s = "parent::" + Runtime.rtl.toStr(f_name);
			content += Runtime.rtl.toStr(s);
		}
		else
		{
			content += Runtime.rtl.toStr("(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(")"));
		}
		content += Runtime.rtl.toStr("($ctx");
		flag = true;
		for (var i = 0; i < op_code.args.count(); i++)
		{
			s = "";
			var item = op_code.args.item(i);
			if (item instanceof BayLang.OpCodes.OpCurryArg)
			{
				s += Runtime.rtl.toStr("$__varg" + Runtime.rtl.toStr(item.pos));
			}
			else
			{
				var res = this.Expression(t, item);
				t = Runtime.rtl.attr(res, 0);
				s = Runtime.rtl.attr(res, 1);
			}
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		for (var i = 0; i < args_sz; i++)
		{
			content += Runtime.rtl.toStr(";}");
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpCall
	 */
	OpCall: function(t, op_code)
	{
		var s = "";
		var flag = false;
		var res = this.Dynamic(t, op_code.obj, op_code);
		t = Runtime.rtl.attr(res, 0);
		s = Runtime.rtl.attr(res, 1);
		if (s == "parent")
		{
			var f_name = t.current_function.name;
			if (f_name == "constructor")
			{
				f_name = "__construct";
			}
			s = "parent::" + Runtime.rtl.toStr(f_name) + Runtime.rtl.toStr("(");
		}
		else
		{
			s += Runtime.rtl.toStr("(");
		}
		var content = s;
		if (t.enable_context)
		{
			if (op_code.obj instanceof BayLang.OpCodes.OpIdentifier && op_code.obj.value == "_")
			{
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr("$ctx"));
				flag = true;
			}
			else if ((t.current_function == null || t.current_function.is_context) && op_code.is_context)
			{
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr("$ctx"));
				flag = true;
			}
		}
		/*
		if (op_code.is_html)
		{
			content ~= (flag ? ", " : "") ~
				"$layout, $model_path, $render_params, $render_content";
			flag = true;
		}
		*/
		for (var i = 0; i < op_code.args.count(); i++)
		{
			var item = op_code.args.item(i);
			var res = this.Expression(t, item);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
			flag = true;
		}
		content += Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassOf
	 */
	OpClassOf: function(t, op_code)
	{
		var names = this.findModuleNames(t, op_code.entity_name.names);
		var s = Runtime.rs.join(".", names);
		return Runtime.Vector.from([t,this.toString(s)]);
	},
	/**
	 * OpTernary
	 */
	OpTernary: function(t, op_code)
	{
		var content = "";
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 100);
		var res = this.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var condition = Runtime.rtl.attr(res, 1);
		var res = this.Expression(t, op_code.if_true);
		t = Runtime.rtl.attr(res, 0);
		var if_true = Runtime.rtl.attr(res, 1);
		var res = this.Expression(t, op_code.if_false);
		t = Runtime.rtl.attr(res, 0);
		var if_false = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr("(" + Runtime.rtl.toStr(condition) + Runtime.rtl.toStr(") ? (") + Runtime.rtl.toStr(if_true) + Runtime.rtl.toStr(") : (") + Runtime.rtl.toStr(if_false) + Runtime.rtl.toStr(")"));
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 0);
		/* OpTernary */
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpPipe
	 */
	OpPipe: function(t, op_code, is_expression)
	{
		if (is_expression == undefined) is_expression = true;
		var content = "";
		var var_name = "";
		var value = "";
		var res = t.constructor.incSaveOpCode(t);
		t = Runtime.rtl.attr(res, 0);
		var_name = Runtime.rtl.attr(res, 1);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["pipe_var_name"]), var_name);
		var items = new Runtime.Vector();
		var op_code_item = op_code;
		while (op_code_item instanceof BayLang.OpCodes.OpPipe)
		{
			items.push(op_code_item);
			op_code_item = op_code_item.obj;
		}
		items = items.reverse();
		/* First item */
		var res = t.expression.constructor.Expression(t, op_code_item);
		t = Runtime.rtl.attr(res, 0);
		value = Runtime.rtl.attr(res, 1);
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s(var_name + Runtime.rtl.toStr(" = new \\Runtime\\Monad(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(");"))}));
		t = Runtime.rtl.attr(res, 0);
		/* Output items */
		for (var i = 0; i < items.count(); i++)
		{
			var s1 = "";
			var s2 = "";
			var op_item = items.item(i);
			if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_ATTR)
			{
				var res = this.Expression(t, op_item.value);
				t = Runtime.rtl.attr(res, 0);
				value = Runtime.rtl.attr(res, 1);
				s1 = var_name + Runtime.rtl.toStr("->attr(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
			}
			else if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_METHOD)
			{
				var value = op_item.value.obj.value.value;
				var args = "";
				var flag = false;
				for (var j = 0; j < op_item.value.args.count(); j++)
				{
					var item = op_item.value.args.item(j);
					var res = t.expression.constructor.Expression(t, item);
					t = Runtime.rtl.attr(res, 0);
					var s = Runtime.rtl.attr(res, 1);
					args += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr(s));
					flag = true;
				}
				s1 = var_name + Runtime.rtl.toStr("->callMethod(\"") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr("\", [") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr("])");
			}
			else if (op_item.kind == BayLang.OpCodes.OpPipe.KIND_CALL)
			{
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), true);
				var res = this.Dynamic(t, op_item.value);
				t = Runtime.rtl.attr(res, 0);
				value = Runtime.rtl.attr(res, 1);
				if (op_item.is_monad)
				{
					s1 = var_name + Runtime.rtl.toStr("->monad(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
				}
				else
				{
					s1 = var_name + Runtime.rtl.toStr("->call(") + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
				}
				t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
			}
			if (s1 != "")
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s(var_name + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";"))}));
				t = Runtime.rtl.attr(res, 0);
			}
			if (s2 != "")
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":t.s(s2)}));
				t = Runtime.rtl.attr(res, 0);
			}
		}
		return Runtime.Vector.from([t,var_name + Runtime.rtl.toStr("->value()")]);
	},
	/**
	 * OpTypeConvert
	 */
	OpTypeConvert: function(t, op_code)
	{
		var content = "";
		var res = this.Expression(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		var value = Runtime.rtl.attr(res, 1);
		content = "\\Runtime\\rtl::to(" + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(this.toPattern(t, op_code.pattern)) + Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction
	 */
	OpDeclareFunction: function(t, op_code)
	{
		var content = "";
		/* Set function name */
		var save_f = t.current_function;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code);
		var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code);
		var args = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr("function (" + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
		if (op_code.vars != null && op_code.vars.count() > 0)
		{
			var vars = op_code.vars.map((s) =>
			{
				return "&$" + Runtime.rtl.toStr(s);
			});
			content += Runtime.rtl.toStr(" use (" + Runtime.rtl.toStr(Runtime.rs.join(",", vars)) + Runtime.rtl.toStr(")"));
		}
		var res = t.operator.constructor.OpDeclareFunctionBody(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Restore function */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), save_f);
		/* OpTernary */
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Expression
	 */
	Expression: function(t, op_code)
	{
		var content = "";
		var save_is_pipe = t.is_pipe;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 100);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
		if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			var res = this.OpIdentifier(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTypeIdentifier)
		{
			var res = this.OpTypeIdentifier(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNegative)
		{
			var res = this.OpNegative(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNumber)
		{
			var res = this.OpNumber(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpString)
		{
			var res = this.OpString(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCollection)
		{
			var res = this.OpCollection(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDict)
		{
			var res = this.OpDict(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpInc)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["opcode_level"]), 16);
			var res = this.OpInc(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpMath)
		{
			var res = this.OpMath(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpMethod)
		{
			var res = this.OpMethod(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpNew)
		{
			var res = this.OpNew(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			var res = this.Dynamic(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			var res = this.OpCall(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpClassOf)
		{
			var res = this.OpClassOf(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpCurry)
		{
			var res = this.OpCurry(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPipe)
		{
			return this.OpPipe(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTernary)
		{
			var res = this.OpTernary(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTypeConvert)
		{
			var res = this.OpTypeConvert(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			var res = this.OpDeclareFunction(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlItems)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), true);
			var res = t.html.constructor.OpHtmlExpression(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), false);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			var res = t.operator.constructor.OpPreprocessorIfDef(t, op_code, BayLang.OpCodes.OpPreprocessorIfDef.KIND_EXPRESSION);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), save_is_pipe);
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangPHP";
	},
	getClassName: function()
	{
		return "BayLang.LangPHP.TranslatorPHPExpression";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangPHP.TranslatorPHPExpression);
window["BayLang.LangPHP.TranslatorPHPExpression"] = BayLang.LangPHP.TranslatorPHPExpression;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangPHP.TranslatorPHPExpression;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangPHP == 'undefined') BayLang.LangPHP = {};
BayLang.LangPHP.TranslatorPHPHtml = function()
{
};
Object.assign(BayLang.LangPHP.TranslatorPHPHtml.prototype,
{
});
Object.assign(BayLang.LangPHP.TranslatorPHPHtml,
{
	/**
	 * Is component
	 */
	isComponent: function(tag_name)
	{
		var ch1 = Runtime.rs.substr(tag_name, 0, 1);
		var ch2 = Runtime.rs.upper(ch1);
		return tag_name != "" && (ch1 == "{" || ch1 == ch2) && tag_name != "Teleport";
	},
	/**
	 * Is single tag
	 */
	isSingleTag: function(tag_name)
	{
		var tokens = Runtime.Vector.from(["img","meta","input","link","br"]);
		if (tokens.indexOf(tag_name) == -1)
		{
			return false;
		}
		return true;
	},
	/**
	 * Translator html attr
	 */
	OpHtmlAttr: function(t, attr)
	{
		var op_code = attr.value;
		if (op_code instanceof BayLang.OpCodes.OpString)
		{
			return Runtime.Vector.from([t,t.expression.constructor.toString(op_code.value)]);
		}
		if (op_code instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_RAW)
			{
				var res = t.expression.constructor.Expression(t, op_code.value);
				t = Runtime.rtl.attr(res, 0);
				var value = Runtime.rtl.attr(res, 1);
				return Runtime.Vector.from([t,value]);
			}
			else if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_JSON)
			{
				var res = t.expression.constructor.Expression(t, op_code.value);
				t = Runtime.rtl.attr(res, 0);
				var value = Runtime.rtl.attr(res, 1);
				value = "\\Runtime\\rtl::json_encode(" + Runtime.rtl.toStr(value) + Runtime.rtl.toStr(")");
				return Runtime.Vector.from([t,value]);
			}
		}
		var res = t.expression.constructor.Expression(t, op_code);
		t = Runtime.rtl.attr(res, 0);
		var value = Runtime.rtl.attr(res, 1);
		value = t.o(value, Runtime.rtl.attr(res, 0).opcode_level, 13);
		return Runtime.Vector.from([t,value]);
	},
	/**
	 * Translator html template
	 */
	OpHtmlAttrs: function(t, attrs)
	{
		var attr_class = new Runtime.Vector();
		var attr_s = "null";
		var attr_key_value = "";
		var attr_elem_name = "";
		var has_attr_key = false;
		var res_attrs = new Runtime.Vector();
		for (var attrs_i = 0; attrs_i < attrs.count(); attrs_i++)
		{
			var attr = Runtime.rtl.attr(attrs, attrs_i);
			if (attr.is_spread)
			{
				continue;
			}
			var attr_key = attr.key;
			var ch = Runtime.rs.substr(attr_key, 0, 1);
			if (ch == "@" && attr_key != "@model" && attr_key != "@global")
			{
				continue;
			}
			var res = this.OpHtmlAttr(t, attr);
			t = Runtime.rtl.attr(res, 0);
			var attr_value = Runtime.rtl.attr(res, 1);
			if (attr_key == "class")
			{
				attr_class.push(attr_value);
				if (attr_elem_name == "" && attr.value instanceof BayLang.OpCodes.OpString)
				{
					var arr = Runtime.rs.split(" ", attr.value.value);
					attr_elem_name = t.expression.constructor.toString(Runtime.rtl.attr(arr, 0));
				}
				continue;
			}
			else if (attr_key == "@global")
			{
				attr_key = "model";
				attr_value = "$this->_model(" + Runtime.rtl.toStr(attr_value) + Runtime.rtl.toStr(", true)");
			}
			else if (attr_key == "@model")
			{
				attr_key = "model";
				attr_value = "$this->_model(" + Runtime.rtl.toStr(attr_value) + Runtime.rtl.toStr(")");
			}
			res_attrs.push(t.expression.constructor.toString(attr_key) + Runtime.rtl.toStr(" => ") + Runtime.rtl.toStr(attr_value));
		}
		res_attrs = res_attrs.filter((s) =>
		{
			return s != "";
		});
		if (attr_class.count() > 0)
		{
			res_attrs.push("\"class\" => " + Runtime.rtl.toStr("$this->_class_name([") + Runtime.rtl.toStr(Runtime.rs.join(", ", attr_class)) + Runtime.rtl.toStr("])"));
		}
		if (res_attrs.count() > 0)
		{
			attr_s = "[" + Runtime.rtl.toStr(Runtime.rs.join(",", res_attrs)) + Runtime.rtl.toStr("]");
		}
		else
		{
			attr_s = "[]";
		}
		/* Add spreads */
		for (var i = 0; i < attrs.count(); i++)
		{
			var attr = Runtime.rtl.attr(attrs, i);
			if (!attr.is_spread)
			{
				continue;
			}
			attr_s = "$this->_merge_attrs(" + Runtime.rtl.toStr(attr_s) + Runtime.rtl.toStr(", $") + Runtime.rtl.toStr(attr.value.value) + Runtime.rtl.toStr(")");
		}
		return Runtime.Vector.from([t,attr_s]);
	},
	/**
	 * Translator html template
	 */
	OpHtmlTag: function(t, op_code, var_name)
	{
		var content = "";
		if (op_code instanceof BayLang.OpCodes.OpHtmlContent)
		{
			var item_value = t.expression.constructor.toString(op_code.value);
			content += Runtime.rtl.toStr(t.s("/* Text */"));
			content += Runtime.rtl.toStr(t.s("$this->_t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlValue)
		{
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			/*int save_op_code_inc = t.save_op_code_inc;*/
			var res = t.expression.constructor.Expression(t, op_code.value);
			t = Runtime.rtl.attr(res, 0);
			var item_value = Runtime.rtl.attr(res, 1);
			/* Restore op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_RAW)
			{
				content += Runtime.rtl.toStr(t.s("/* Raw */"));
				content += Runtime.rtl.toStr(t.s("$this->_t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr("new \\Runtime\\RawString(") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr("));")));
			}
			else if (op_code.kind == BayLang.OpCodes.OpHtmlValue.KIND_JSON)
			{
				content += Runtime.rtl.toStr(t.s("/* Text */"));
				item_value = "\\Runtime\\rtl::json_encode(" + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(")");
				content += Runtime.rtl.toStr(t.s("$this->_t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlTag)
		{
			var new_var_name = "";
			var res = t.constructor.incSaveOpCode(t);
			t = Runtime.rtl.attr(res, 0);
			new_var_name = Runtime.rtl.attr(res, 1);
			var has_childs = op_code.items != null && op_code.items.items != null && op_code.items.items.count() > 0;
			var is_component = this.isComponent(op_code.tag_name);
			var op_code_attrs = op_code.attrs.filter((attr) =>
			{
				return attr.key != "@render";
			});
			var res = this.OpHtmlAttrs(t, op_code_attrs);
			t = Runtime.rtl.attr(res, 0);
			var attrs = Runtime.rtl.attr(res, 1);
			if (op_code.tag_name == "")
			{
			}
			else if (is_component)
			{
				var tag_name = "";
				if (op_code.op_code_name)
				{
					var res = t.expression.constructor.Expression(t, op_code.op_code_name);
					t = Runtime.rtl.attr(res, 0);
					tag_name = Runtime.rtl.attr(res, 1);
				}
				else
				{
					tag_name = t.expression.constructor.toString(t.expression.constructor.findModuleName(t, op_code.tag_name));
				}
				if (has_childs)
				{
					var res = this.OpHtmlItemsAsFunction(t, op_code.items);
					t = Runtime.rtl.attr(res, 0);
					var f = Runtime.rtl.attr(res, 1);
					content += Runtime.rtl.toStr(t.s("/* Component '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					content += Runtime.rtl.toStr(t.s("$this->_c(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(f) + Runtime.rtl.toStr(");")));
					has_childs = false;
				}
				else
				{
					content += Runtime.rtl.toStr(t.s("/* Component '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					content += Runtime.rtl.toStr(t.s("$this->_c(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
				}
			}
			else
			{
				var tag_name = t.expression.constructor.toString(op_code.tag_name);
				if (has_childs)
				{
					content += Runtime.rtl.toStr(t.s("/* Element '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
					content += Runtime.rtl.toStr(t.s(new_var_name + Runtime.rtl.toStr(" = new \\Runtime\\Vector();")));
					var res = this.OpHtmlItems(t, op_code.items, new_var_name, true);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
					content += Runtime.rtl.toStr(t.s2(""));
					if (op_code.tag_name == "Teleport")
					{
						content += Runtime.rtl.toStr(t.s("/* Teleport */"));
						content += Runtime.rtl.toStr(t.s("$this->_teleport(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(");")));
					}
					else
					{
						content += Runtime.rtl.toStr(t.s("/* Element '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
						content += Runtime.rtl.toStr(t.s("$this->_e(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(new_var_name) + Runtime.rtl.toStr(");")));
					}
				}
				else
				{
					if (op_code.tag_name == "Teleport")
					{
						content += Runtime.rtl.toStr(t.s("/* Teleport */"));
						content += Runtime.rtl.toStr(t.s("$this->_teleport(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
					}
					else
					{
						content += Runtime.rtl.toStr(t.s("/* Element '" + Runtime.rtl.toStr(op_code.tag_name) + Runtime.rtl.toStr("' */")));
						content += Runtime.rtl.toStr(t.s("$this->_e(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(tag_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(attrs) + Runtime.rtl.toStr(");")));
					}
				}
			}
		}
		else
		{
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			/*int save_op_code_inc = t.save_op_code_inc;*/
			var item_value = "";
			if (op_code instanceof BayLang.OpCodes.OpCall)
			{
				var res = t.expression.constructor.OpCall(t, op_code);
				t = Runtime.rtl.attr(res, 0);
				item_value += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				if (!op_code.is_html)
				{
					item_value = "$this->_escape(" + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(")");
				}
			}
			else
			{
				var res = t.expression.constructor.Expression(t, op_code);
				t = Runtime.rtl.attr(res, 0);
				item_value = Runtime.rtl.attr(res, 1);
				item_value = "$this->_escape(" + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(")");
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			/* Restore op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			/*t <= save_op_code_inc <= save_op_code_inc;*/
			content += Runtime.rtl.toStr(t.s("/* Text */"));
			content += Runtime.rtl.toStr(t.s("$this->_t(" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", ") + Runtime.rtl.toStr(item_value) + Runtime.rtl.toStr(");")));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items
	 */
	OpHtmlExpression: function(t, op_code, detect_multiblock)
	{
		if (detect_multiblock == undefined) detect_multiblock = true;
		var content = "";
		content += Runtime.rtl.toStr(t.s("$__v = new \\Runtime\\Vector();"));
		var res = this.OpHtmlItems(t, op_code, "$__v", true);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		content += Runtime.rtl.toStr(t.s2(""));
		var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"content":content}));
		t = Runtime.rtl.attr(res, 0);
		if (detect_multiblock && (t.current_function.flags.isFlag("multiblock") || t.current_function.name == "render"))
		{
			return Runtime.Vector.from([t,"$this->_flatten($__v)"]);
		}
		return Runtime.Vector.from([t,"$__v"]);
	},
	/**
	 * Translator html slot
	 */
	OpHtmlSlot: function(t, op_code)
	{
		var content = "\\Runtime\\Dict::from([";
		t = t.levelInc();
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			if (!(item instanceof BayLang.OpCodes.OpHtmlSlot))
			{
				continue;
			}
			content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(item.name) + Runtime.rtl.toStr(" => ")));
			var res = this.OpHtmlItemsAsFunction(t, item.items, item.args, item.vars);
			t = res.get(0);
			content += Runtime.rtl.toStr(res.get(1) + Runtime.rtl.toStr(","));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("])"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items as function
	 */
	OpHtmlItemsAsFunction: function(t, op_code, args, vars)
	{
		if (args == undefined) args = null;
		if (vars == undefined) vars = null;
		/* If slot */
		if (op_code.items.get(0) instanceof BayLang.OpCodes.OpHtmlSlot)
		{
			return this.OpHtmlSlot(t, op_code);
		}
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), 0);
		/* Use vars */
		var use_vars = "";
		var used_vars = Runtime.Vector.from([]);
		/* Html slot */
		var f_args = "";
		if (args != null)
		{
			var res = t.operator.constructor.OpDeclareFunctionArgs(t, new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"args":args,"is_context":false})));
			f_args = Runtime.rtl.attr(res, 1);
		}
		/* Slot vars */
		if (vars != null)
		{
			for (var i = 0; i < vars.count(); i++)
			{
				used_vars.push(vars.get(i).value);
			}
		}
		/* Get used vars */
		this.exportUsedVars(used_vars, op_code);
		if (used_vars.count() > 0)
		{
			used_vars = used_vars.map((s) =>
			{
				return "&$" + Runtime.rtl.toStr(s);
			});
			use_vars = " use (" + Runtime.rtl.toStr(used_vars.join(", ")) + Runtime.rtl.toStr(") ");
		}
		var content = "function (" + Runtime.rtl.toStr(f_args) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr(use_vars) + Runtime.rtl.toStr("{");
		t = t.levelInc();
		var res = this.OpHtmlExpression(t, op_code, false);
		t = Runtime.rtl.attr(res, 0);
		/* Output save op code */
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(";")));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translator html items
	 */
	OpHtmlItems: function(t, op_code, var_name, first_space)
	{
		if (var_name == undefined) var_name = "";
		if (first_space == undefined) first_space = false;
		if (op_code == null || op_code.items.count() == 0)
		{
			return Runtime.Vector.from([t,""]);
		}
		var save_html_var_name = t.html_var_name;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["html_var_name"]), var_name);
		var content = "";
		var next_space = true;
		var add_space = (i) =>
		{
			if (i > 0 && next_space)
			{
				content += Runtime.rtl.toStr(t.s2(""));
			}
			if (i == 0 && first_space)
			{
				content += Runtime.rtl.toStr(t.s2(""));
			}
			if (!next_space)
			{
				next_space = true;
			}
		};
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			var item_value = "";
			var op_content = "";
			/* Save op codes */
			var save_op_codes = t.save_op_codes;
			var save_op_code_inc = t.save_op_code_inc;
			if (item instanceof BayLang.OpCodes.OpAssign)
			{
				var res = t.operator.constructor.OpAssign(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpComment)
			{
				add_space(i);
				var res = t.operator.constructor.OpComment(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				next_space = false;
			}
			else if (item instanceof BayLang.OpCodes.OpFor)
			{
				add_space(i);
				var res = t.operator.constructor.OpFor(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpIf)
			{
				add_space(i);
				var res = t.operator.constructor.OpIf(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpWhile)
			{
				add_space(i);
				var res = t.operator.constructor.OpWhile(t, item);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpHtmlSlot)
			{
				continue;
			}
			else
			{
				add_space(i);
				var res = this.OpHtmlTag(t, item, var_name);
				t = Runtime.rtl.attr(res, 0);
				op_content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			if (op_content != "")
			{
				content += Runtime.rtl.toStr(op_content);
			}
			/* Restore save op codes */
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		}
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["html_var_name"]), save_html_var_name);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Export used vars
	 */
	exportUsedVars: function(used_vars, op_code)
	{
		if (op_code instanceof BayLang.OpCodes.OpHtmlItems)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				this.exportUsedVars(used_vars, op_code.items.get(i));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			this.exportUsedVars(used_vars, op_code.obj);
			if (op_code.args != null)
			{
				for (var i = 0; i < op_code.args.count(); i++)
				{
					this.exportUsedVars(used_vars, op_code.args.get(i));
				}
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpAttr)
		{
			this.exportUsedVars(used_vars, op_code.obj);
		}
		else if (op_code instanceof BayLang.OpCodes.OpIdentifier)
		{
			if (op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_VARIABLE)
			{
				used_vars.push(op_code.value);
			}
		}
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangPHP";
	},
	getClassName: function()
	{
		return "BayLang.LangPHP.TranslatorPHPHtml";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangPHP.TranslatorPHPHtml);
window["BayLang.LangPHP.TranslatorPHPHtml"] = BayLang.LangPHP.TranslatorPHPHtml;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangPHP.TranslatorPHPHtml;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangPHP == 'undefined') BayLang.LangPHP = {};
BayLang.LangPHP.TranslatorPHPOperator = function()
{
};
Object.assign(BayLang.LangPHP.TranslatorPHPOperator.prototype,
{
});
Object.assign(BayLang.LangPHP.TranslatorPHPOperator,
{
	/**
	 * OpAssign
	 */
	OpAssignStruct: function(t, op_code, pos)
	{
		if (pos == undefined) pos = 0;
		var content = "";
		var var_name = op_code.var_name;
		var res = t.expression.constructor.Expression(t, op_code.expression);
		t = Runtime.rtl.attr(res, 0);
		var expr = Runtime.rtl.attr(res, 1);
		var names = op_code.names.map((item) =>
		{
			if (item instanceof BayLang.OpCodes.BaseOpCode)
			{
				var res = t.expression.constructor.Expression(t, item);
				t = Runtime.rtl.attr(res, 0);
				return Runtime.rtl.attr(res, 1);
			}
			return t.expression.constructor.toString(item);
		});
		content = "\\Runtime\\rtl::setAttr($ctx, $" + Runtime.rtl.toStr(var_name) + Runtime.rtl.toStr(", [") + Runtime.rtl.toStr(Runtime.rs.join(", ", names)) + Runtime.rtl.toStr("], ") + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(")");
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpAssign
	 */
	OpAssign: function(t, op_code, flag_indent)
	{
		if (flag_indent == undefined) flag_indent = true;
		var content = "";
		if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_ASSIGN || op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
		{
			for (var i = 0; i < op_code.values.count(); i++)
			{
				var item = op_code.values.item(i);
				var index_s = "";
				var s = "";
				var op = item.op;
				if (op == "")
				{
					op = "=";
				}
				if (item.expression == null)
				{
					continue;
				}
				/* Expression */
				var item_expression = "";
				var res = t.expression.constructor.Expression(t, item.expression);
				t = Runtime.rtl.attr(res, 0);
				if (op == "~=")
				{
					item_expression = t.expression.constructor.rtlToStr(t, Runtime.rtl.attr(res, 1));
				}
				else
				{
					item_expression = Runtime.rtl.attr(res, 1);
				}
				if (item.op_code instanceof BayLang.OpCodes.OpAttr)
				{
					var items = new Runtime.Vector();
					var items2 = new Runtime.Vector();
					var op_code_next = item.op_code;
					while (op_code_next instanceof BayLang.OpCodes.OpAttr)
					{
						items.push(op_code_next);
						op_code_next = op_code_next.obj;
					}
					items = items.reverse();
					var res = t.expression.constructor.OpIdentifier(t, op_code_next);
					t = Runtime.rtl.attr(res, 0);
					var obj_s = Runtime.rtl.attr(res, 1);
					for (var j = 0; j < items.count(); j++)
					{
						var item_attr = Runtime.rtl.attr(items, j);
						if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_ATTR)
						{
							obj_s += Runtime.rtl.toStr("->" + Runtime.rtl.toStr(item_attr.value.value));
							items2.push(t.expression.constructor.toString(item_attr.value.value));
						}
						else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC)
						{
							var res = t.expression.constructor.Expression(t, item_attr.value);
							t = Runtime.rtl.attr(res, 0);
							obj_s += Runtime.rtl.toStr("[" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr("]"));
							items2.push(Runtime.rtl.attr(res, 1));
						}
						else if (item_attr.kind == BayLang.OpCodes.OpAttr.KIND_DYNAMIC_ATTRS)
						{
							if (item_attr.attrs != null)
							{
								for (var j = item_attr.attrs.count() - 1; j >= 0; j--)
								{
									var res = t.expression.constructor.Expression(t, Runtime.rtl.attr(item_attr.attrs, j));
									t = Runtime.rtl.attr(res, 0);
									obj_s += Runtime.rtl.toStr("[" + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr("]"));
									items2.push(Runtime.rtl.attr(res, 1));
								}
							}
						}
					}
					if (op == "~=" || op == "+=" || op == "-=")
					{
						var op2 = "+";
						if (op == "~=" || op == "+=")
						{
							op2 = "+";
						}
						else if (op == "-=")
						{
							op2 = "-";
						}
						item_expression = "\\Runtime\\rtl\\attr($ctx, " + Runtime.rtl.toStr(obj_s) + Runtime.rtl.toStr(", [") + Runtime.rtl.toStr(Runtime.rs.join(", ", items2)) + Runtime.rtl.toStr("]) ") + Runtime.rtl.toStr(op2) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(item_expression);
					}
					index_s = obj_s + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(item_expression) + Runtime.rtl.toStr(";");
				}
				else
				{
					if (item.op_code != null && item.op_code.value == "@" && t.enable_context == false)
					{
						index_s = "\\Runtime\\rtl::setContext(" + Runtime.rtl.toStr(item_expression) + Runtime.rtl.toStr(");");
					}
					else
					{
						if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_DECLARE)
						{
							s = "$" + Runtime.rtl.toStr(item.var_name);
						}
						else
						{
							var res = t.expression.constructor.OpIdentifier(t, item.op_code);
							t = Runtime.rtl.attr(res, 0);
							s = Runtime.rtl.attr(res, 1);
						}
						if (item_expression != "")
						{
							if (op == "~=")
							{
								s += Runtime.rtl.toStr(" .= " + Runtime.rtl.toStr(item_expression));
							}
							else
							{
								s += Runtime.rtl.toStr(" " + Runtime.rtl.toStr(op) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(item_expression));
							}
							index_s = s + Runtime.rtl.toStr(";");
						}
					}
				}
				if (item.var_name != "" && t.save_vars.indexOf(item.var_name) == -1)
				{
					t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_vars"]), t.save_vars.pushIm(item.var_name));
				}
				if (index_s != "")
				{
					content += Runtime.rtl.toStr((flag_indent) ? (t.s(index_s)) : (index_s));
				}
			}
		}
		else if (op_code.kind == BayLang.OpCodes.OpAssign.KIND_STRUCT)
		{
			var s = "$" + Runtime.rtl.toStr(op_code.var_name) + Runtime.rtl.toStr(" = ");
			var res = this.OpAssignStruct(t, op_code, 0);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(s + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(";"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDelete
	 */
	OpDelete: function(t, op_code)
	{
		var content = "";
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpFor
	 */
	OpFor: function(t, op_code)
	{
		var content = "";
		var s1 = "";
		var s2 = "";
		var s3 = "";
		if (op_code.expr1 instanceof BayLang.OpCodes.OpAssign)
		{
			var res = this.OpAssign(t, op_code.expr1, false);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		else
		{
			var res = t.expression.constructor.Expression(t, op_code.expr1);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		var res = t.expression.constructor.Expression(t, op_code.expr2);
		t = Runtime.rtl.attr(res, 0);
		s2 = Runtime.rtl.attr(res, 1);
		var res = t.expression.constructor.Expression(t, op_code.expr3);
		t = Runtime.rtl.attr(res, 0);
		s3 = Runtime.rtl.attr(res, 1);
		content = t.s("for (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(" ") + Runtime.rtl.toStr(s2) + Runtime.rtl.toStr("; ") + Runtime.rtl.toStr(s3) + Runtime.rtl.toStr(")"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpIf
	 */
	OpIf: function(t, op_code)
	{
		var content = "";
		var res = t.expression.constructor.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var s1 = Runtime.rtl.attr(res, 1);
		content = t.s("if (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(")"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.if_true);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		for (var i = 0; i < op_code.if_else.count(); i++)
		{
			var if_else = op_code.if_else.item(i);
			var res = t.expression.constructor.Expression(t, if_else.condition);
			t = Runtime.rtl.attr(res, 0);
			var s2 = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(t.s("else if (" + Runtime.rtl.toStr(s2) + Runtime.rtl.toStr(")")));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			var res = this.Operators(t, if_else.if_true);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		if (op_code.if_false != null)
		{
			content += Runtime.rtl.toStr(t.s("else"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			var res = this.Operators(t, op_code.if_false);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpReturn
	 */
	OpReturn: function(t, op_code)
	{
		var content = "";
		var s1 = "";
		if (op_code.expression)
		{
			var res = t.expression.constructor.Expression(t, op_code.expression);
			t = Runtime.rtl.attr(res, 0);
			s1 = Runtime.rtl.attr(res, 1);
		}
		if (t.current_function.flags != null && t.current_function.flags.isFlag("memorize"))
		{
			var content = t.s("$__memorize_value = " + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";"));
			content += Runtime.rtl.toStr(t.s(t.expression.constructor.getModuleName(t, "Runtime.rtl") + Runtime.rtl.toStr("::_memorizeSave(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(t.current_function.name) + Runtime.rtl.toStr("\", func_get_args(), $__memorize_value);")));
			content += Runtime.rtl.toStr(t.s("return $__memorize_value;"));
			return Runtime.Vector.from([t,content]);
		}
		content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";")));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpThrow
	 */
	OpThrow: function(t, op_code)
	{
		var res = t.expression.constructor.Expression(t, op_code.expression);
		t = Runtime.rtl.attr(res, 0);
		var content = t.s("throw " + Runtime.rtl.toStr(Runtime.rtl.attr(res, 1)) + Runtime.rtl.toStr(";"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpTryCatch
	 */
	OpTryCatch: function(t, op_code)
	{
		var content = "";
		content += Runtime.rtl.toStr(t.s("try"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.op_try);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(t.s(Runtime.rtl.attr(res, 1)));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		content += Runtime.rtl.toStr(t.s("catch (\\Exception $_ex)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var s = "";
			var pattern = "";
			var item = op_code.items.item(i);
			var res = t.expression.constructor.OpTypeIdentifier(t, item.pattern);
			t = Runtime.rtl.attr(res, 0);
			pattern += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			if (pattern != "\\var")
			{
				s = "if ($_ex instanceof " + Runtime.rtl.toStr(pattern) + Runtime.rtl.toStr(")");
			}
			else
			{
				s = "if (true)";
			}
			s += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			s += Runtime.rtl.toStr((s != "") ? (t.s("$" + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = $_ex;"))) : ("$" + Runtime.rtl.toStr(item.name) + Runtime.rtl.toStr(" = $_ex;")));
			var res = this.Operators(t, item.value);
			t = Runtime.rtl.attr(res, 0);
			s += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			t = t.levelDec();
			s += Runtime.rtl.toStr(t.s("}"));
			if (i != 0)
			{
				s = "else " + Runtime.rtl.toStr(s);
			}
			content += Runtime.rtl.toStr(t.s(s));
		}
		content += Runtime.rtl.toStr(t.s("else"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("throw $_ex;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpWhile
	 */
	OpWhile: function(t, op_code)
	{
		var content = "";
		var res = t.expression.constructor.Expression(t, op_code.condition);
		t = Runtime.rtl.attr(res, 0);
		var s1 = Runtime.rtl.attr(res, 1);
		content += Runtime.rtl.toStr(t.s("while (" + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(")")));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		var res = this.Operators(t, op_code.value);
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpPreprocessorIfCode
	 */
	OpPreprocessorIfCode: function(t, op_code)
	{
		var content = "";
		if (Runtime.rtl.attr(t.preprocessor_flags, op_code.condition.value) == true)
		{
			content = Runtime.rs.trim(op_code.content);
		}
		return Runtime.Vector.from([t,t.s(content)]);
	},
	/**
	 * OpPreprocessorIfDef
	 */
	OpPreprocessorIfDef: function(t, op_code, kind)
	{
		if (!(Runtime.rtl.attr(t.preprocessor_flags, op_code.condition.value) == true))
		{
			return Runtime.Vector.from([t,""]);
		}
		if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR)
		{
			return this.Operators(t, op_code.items);
		}
		else if (kind == BayLang.OpCodes.OpPreprocessorIfDef.KIND_EXPRESSION)
		{
			return t.expression.constructor.Expression(t, op_code.items);
		}
		var content = "";
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			if (item instanceof BayLang.OpCodes.OpComment)
			{
				var res = t.operator.constructor.OpComment(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
			{
				var res = t.program.constructor.OpDeclareFunction(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComment
	 */
	OpComment: function(t, op_code)
	{
		var content = t.s("/*" + Runtime.rtl.toStr(op_code.value) + Runtime.rtl.toStr("*/"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComments
	 */
	OpComments: function(t, comments)
	{
		var content = "";
		for (var i = 0; i < comments.count(); i++)
		{
			var res = this.OpComment(t, comments.item(i));
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpComments
	 */
	AddComments: function(t, comments, content)
	{
		if (comments && comments.count() > 0)
		{
			var res = this.OpComments(t, comments);
			var s = Runtime.rtl.attr(res, 1);
			if (s != "")
			{
				content = s + Runtime.rtl.toStr(content);
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Operator
	 */
	Operator: function(t, op_code)
	{
		var content = "";
		/* Save op codes */
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		if (op_code instanceof BayLang.OpCodes.OpAssign)
		{
			var res = this.OpAssign(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var content = Runtime.rtl.attr(res, 1);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content = save + Runtime.rtl.toStr(content);
			}
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
			return Runtime.Vector.from([t,content]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpAssignStruct)
		{
			var res = this.OpAssignStruct(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			var s1 = Runtime.rtl.attr(res, 1);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content = save;
			}
			content += Runtime.rtl.toStr(t.s("$" + Runtime.rtl.toStr(op_code.var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s1) + Runtime.rtl.toStr(";")));
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
			return Runtime.Vector.from([t,content]);
		}
		else if (op_code instanceof BayLang.OpCodes.OpBreak)
		{
			content = t.s("break;");
		}
		else if (op_code instanceof BayLang.OpCodes.OpCall)
		{
			var res = t.expression.constructor.OpCall(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
		}
		else if (op_code instanceof BayLang.OpCodes.OpContinue)
		{
			content = t.s("continue;");
		}
		else if (op_code instanceof BayLang.OpCodes.OpDelete)
		{
			var res = this.OpDelete(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpFor)
		{
			var res = this.OpFor(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpIf)
		{
			var res = this.OpIf(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPipe)
		{
			var res = t.expression.constructor.OpPipe(t, op_code, false);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
		}
		else if (op_code instanceof BayLang.OpCodes.OpReturn)
		{
			var res = this.OpReturn(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpThrow)
		{
			var res = this.OpThrow(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpTryCatch)
		{
			var res = this.OpTryCatch(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpWhile)
		{
			var res = this.OpWhile(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpInc)
		{
			var res = t.expression.constructor.OpInc(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = t.s(Runtime.rtl.attr(res, 1) + Runtime.rtl.toStr(";"));
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfCode)
		{
			var res = this.OpPreprocessorIfCode(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			var res = this.OpPreprocessorIfDef(t, op_code, BayLang.OpCodes.OpPreprocessorIfDef.KIND_OPERATOR);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorSwitch)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var res = this.OpPreprocessorIfCode(t, op_code.items.item(i));
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpComment)
		{
			var res = this.OpComment(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		else if (op_code instanceof BayLang.OpCodes.OpSafe)
		{
			var res = this.Operators(t, op_code.items);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
		}
		/* Output save op code */
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		if (save != "")
		{
			content = save + Runtime.rtl.toStr(content);
		}
		/* Restore save op codes */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_codes"]), save_op_codes);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["save_op_code_inc"]), save_op_code_inc);
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Operators
	 */
	Operators: function(t, op_code)
	{
		var content = "";
		var f1 = (op_code) =>
		{
			return op_code instanceof BayLang.OpCodes.OpBreak || op_code instanceof BayLang.OpCodes.OpCall || op_code instanceof BayLang.OpCodes.OpContinue || op_code instanceof BayLang.OpCodes.OpReturn || op_code instanceof BayLang.OpCodes.OpThrow;
		};
		if (op_code instanceof BayLang.OpCodes.OpItems)
		{
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.Operator(t, item);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		else if (op_code instanceof BayLang.OpCodes.OpHtmlItems)
		{
			var save_html_var_name = t.html_var_name;
			var save_is_html = t.is_html;
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), true);
			var res = t.html.constructor.OpHtmlItems(t, op_code, save_html_var_name, false);
			t = Runtime.rtl.attr(res, 0);
			content = Runtime.rtl.attr(res, 1);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), save_is_html);
		}
		else
		{
			var res = this.Operator(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction Arguments
	 */
	OpDeclareFunctionArgs: function(t, f)
	{
		var content = "";
		if (f.args != null)
		{
			var flag = false;
			if (f.is_context)
			{
				content += Runtime.rtl.toStr("$ctx");
				flag = true;
			}
			/*
			if (f.is_html)
			{
				flag = true;
				content ~= (flag ? ", " : "") ~
					"$layout, $model_path, $render_params, $render_content";
			}
			*/
			for (var i = 0; i < f.args.count(i); i++)
			{
				var arg = f.args.item(i);
				var name = arg.name;
				var expr = "";
				if (arg.expression != null)
				{
					var res = t.expression.constructor.Expression(t, arg.expression);
					t = Runtime.rtl.attr(res, 0);
					expr = Runtime.rtl.attr(res, 1);
				}
				content += Runtime.rtl.toStr(((flag) ? (", ") : ("")) + Runtime.rtl.toStr("$") + Runtime.rtl.toStr(name) + Runtime.rtl.toStr(((expr != "") ? ("=" + Runtime.rtl.toStr(expr)) : (""))));
				flag = true;
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareFunction Body
	 */
	OpDeclareFunctionBody: function(t, f)
	{
		var save_t = t;
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_pipe"]), false);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_html"]), false);
		var content = "";
		t = t.levelInc();
		/*
		if (f.is_html)
		{
			content ~= t.s("$model = \\Runtime\\rtl::attr($layout, $model_path);");
		}
		*/
		if (f.items)
		{
			var res = t.operator.constructor.Operators(t, f.items);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		else if (f.expression)
		{
			/* Clear save op codes */
			t = t.constructor.clearSaveOpCode(t);
			var res = t.expression.constructor.Expression(t, f.expression);
			t = Runtime.rtl.attr(res, 0);
			var expr = Runtime.rtl.attr(res, 1);
			var s = "";
			if (f.flags != null && f.flags.isFlag("memorize"))
			{
				s = "$__memorize_value = " + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(";");
				s += Runtime.rtl.toStr(t.s(t.expression.constructor.getModuleName(t, "Runtime.rtl") + Runtime.rtl.toStr("::_memorizeSave(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(f.name) + Runtime.rtl.toStr("\", func_get_args(), $__memorize_value);")));
				s += Runtime.rtl.toStr(t.s("return $__memorize_value;"));
			}
			else
			{
				s = t.s("return " + Runtime.rtl.toStr(expr) + Runtime.rtl.toStr(";"));
			}
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t);
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			content += Runtime.rtl.toStr(s);
		}
		if (f.flags != null && f.flags.isFlag("memorize"))
		{
			var s = "";
			s += Runtime.rtl.toStr(t.s("$__memorize_value = " + Runtime.rtl.toStr(t.expression.constructor.getModuleName(t, "Runtime.rtl")) + Runtime.rtl.toStr("::_memorizeValue(\"") + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(f.name) + Runtime.rtl.toStr("\", func_get_args());")));
			s += Runtime.rtl.toStr(t.s("if ($__memorize_value != " + Runtime.rtl.toStr(t.expression.constructor.getModuleName(t, "Runtime.rtl")) + Runtime.rtl.toStr("::$_memorize_not_found) return $__memorize_value;")));
			content = s + Runtime.rtl.toStr(content);
		}
		t = t.levelDec();
		content = t.s("{") + Runtime.rtl.toStr(content);
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([save_t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangPHP";
	},
	getClassName: function()
	{
		return "BayLang.LangPHP.TranslatorPHPOperator";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangPHP.TranslatorPHPOperator);
window["BayLang.LangPHP.TranslatorPHPOperator"] = BayLang.LangPHP.TranslatorPHPOperator;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangPHP.TranslatorPHPOperator;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangPHP == 'undefined') BayLang.LangPHP = {};
BayLang.LangPHP.TranslatorPHPProgram = function()
{
};
Object.assign(BayLang.LangPHP.TranslatorPHPProgram.prototype,
{
});
Object.assign(BayLang.LangPHP.TranslatorPHPProgram,
{
	/**
	 * OpNamespace
	 */
	OpNamespace: function(t, op_code)
	{
		var arr = Runtime.rs.split(".", op_code.name);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_namespace_name"]), op_code.name);
		return Runtime.Vector.from([t,t.s("namespace " + Runtime.rtl.toStr(Runtime.rs.join("\\", arr)) + Runtime.rtl.toStr(";"))]);
	},
	/**
	 * OpDeclareFunction
	 */
	OpDeclareFunction: function(t, op_code)
	{
		if (op_code.isFlag("declare"))
		{
			return Runtime.Vector.from([t,""]);
		}
		var content = "";
		/* Set current function */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code);
		var s1 = "";
		var s2 = "";
		if (op_code.isStatic())
		{
			s1 += Runtime.rtl.toStr("static ");
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), true);
		}
		else
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["is_static_function"]), false);
		}
		var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code);
		var args = Runtime.rtl.attr(res, 1);
		s1 += Runtime.rtl.toStr("function " + Runtime.rtl.toStr(op_code.name) + Runtime.rtl.toStr("(") + Runtime.rtl.toStr(args) + Runtime.rtl.toStr(")"));
		if (t.current_class.kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			var res = t.operator.constructor.OpDeclareFunctionBody(t, op_code);
			s2 += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		else
		{
			s2 += Runtime.rtl.toStr(";");
		}
		s1 = t.s(s1);
		/* Function comments */
		var res = t.operator.constructor.AddComments(t, op_code.comments, s1 + Runtime.rtl.toStr(s2));
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpFunctionAnnotations
	 */
	OpFunctionAnnotations: function(t, f)
	{
		var content = "";
		if (f.flags.isFlag("declare"))
		{
			return Runtime.Vector.from([t,content]);
		}
		if (!f.annotations)
		{
			return Runtime.Vector.from([t,content]);
		}
		if (f.annotations.count() == 0)
		{
			return Runtime.Vector.from([t,content]);
		}
		content += Runtime.rtl.toStr(t.s("if ($field_name == " + Runtime.rtl.toStr(t.expression.constructor.toString(f.name)) + Runtime.rtl.toStr(")")));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("return \\Runtime\\Dict::from(["));
		t = t.levelInc();
		if (f.flags.isFlag("async"))
		{
			content += Runtime.rtl.toStr(t.s("\"async\"=>true,"));
		}
		content += Runtime.rtl.toStr(t.s("\"annotations\"=>\\Runtime\\Collection::from(["));
		t = t.levelInc();
		for (var j = 0; j < f.annotations.count(); j++)
		{
			var annotation = f.annotations.item(j);
			var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
			t = Runtime.rtl.attr(res, 0);
			var name = Runtime.rtl.attr(res, 1);
			var params = "";
			if (annotation.params != null)
			{
				var res = t.expression.constructor.OpDict(t, annotation.params, true);
				t = Runtime.rtl.attr(res, 0);
				params = Runtime.rtl.attr(res, 1);
			}
			content += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("($ctx, ") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("]),"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("]);"));
		t = t.levelDec();
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassBodyItemMethodsList
	 */
	OpClassBodyItemMethodsList: function(t, item)
	{
		var content = "";
		if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			if (Runtime.rtl.attr(t.preprocessor_flags, item.condition.value) == true)
			{
				for (var i = 0; i < item.items.count(); i++)
				{
					var op_code = item.items.item(i);
					var res = this.OpClassBodyItemMethodsList(t, op_code);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
		}
		else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			if (!item.flags.isFlag("declare") && !item.flags.isFlag("protected") && !item.flags.isFlag("private") && !(item.annotations == null) && !(item.annotations.count() == 0))
			{
				content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(item.name) + Runtime.rtl.toStr(",")));
			}
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpClassBodyItemAnnotations
	 */
	OpClassBodyItemAnnotations: function(t, item)
	{
		var content = "";
		if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
		{
			if (Runtime.rtl.attr(t.preprocessor_flags, item.condition.value) == true)
			{
				for (var i = 0; i < item.items.count(); i++)
				{
					var op_code = item.items.item(i);
					var res = this.OpClassBodyItemAnnotations(t, op_code);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
		}
		else if (item instanceof BayLang.OpCodes.OpDeclareFunction)
		{
			var res = this.OpFunctionAnnotations(t, item);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClassConstructor: function(t, op_code)
	{
		if (op_code.fn_create == null)
		{
			return Runtime.Vector.from([t,""]);
		}
		var open = "";
		var content = "";
		var save_t = t;
		/* Set function name */
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_function"]), op_code.fn_create);
		/* Clear save op codes */
		t = t.constructor.clearSaveOpCode(t);
		open += Runtime.rtl.toStr(t.s("function __construct("));
		var res = t.operator.constructor.OpDeclareFunctionArgs(t, op_code.fn_create);
		t = Runtime.rtl.attr(res, 0);
		open += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		open += Runtime.rtl.toStr(")");
		open += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Function body */
		var res = t.operator.constructor.Operators(t, (op_code.fn_create.expression) ? (op_code.fn_create.expression) : (op_code.fn_create.items));
		t = Runtime.rtl.attr(res, 0);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Constructor end */
		var save = t.constructor.outputSaveOpCode(t);
		if (save != "")
		{
			content = open + Runtime.rtl.toStr(t.s(save + Runtime.rtl.toStr(content)));
		}
		else
		{
			content = open + Runtime.rtl.toStr(content);
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([save_t,content]);
	},
	/**
	 * Declare component functions
	 */
	OpDeclareComponentFunctions: function(t, op_code)
	{
		var content = "";
		/* CSS */
		content += Runtime.rtl.toStr(t.s("static function css($vars)"));
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		content += Runtime.rtl.toStr(t.s("$res = \"\";"));
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.get(i);
			if (!(item instanceof BayLang.OpCodes.OpHtmlStyle))
			{
				continue;
			}
			var res = t.expression.constructor.Expression(t, item.value);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(t.s("$res .= \\Runtime\\rtl::toStr(" + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(");")));
		}
		content += Runtime.rtl.toStr(t.s("return $res;"));
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		/* Meta data */
		var op_code_meta = op_code.items.findItem(Runtime.lib.isInstance("BayLang.OpCodes.OpHtmlMeta"));
		if (op_code_meta)
		{
			content += Runtime.rtl.toStr(t.s("static function getMetaData()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			var res = t.expression.constructor.Expression(t, op_code_meta.value);
			t = Runtime.rtl.attr(res, 0);
			var s = Runtime.rtl.attr(res, 1);
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClassBody: function(t, op_code)
	{
		var content = "";
		var class_kind = op_code.kind;
		var save_op_codes = t.save_op_codes;
		var save_op_code_inc = t.save_op_code_inc;
		t = t.constructor.clearSaveOpCode(t);
		content += Runtime.rtl.toStr(t.s("{"));
		t = t.levelInc();
		/* Static variables */
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE && op_code.vars != null)
		{
			for (var i = 0; i < op_code.vars.count(); i++)
			{
				var variable = op_code.vars.item(i);
				if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
				{
					continue;
				}
				if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
				{
					continue;
				}
				var is_static = variable.flags.isFlag("static");
				var is_const = variable.flags.isFlag("const");
				for (var j = 0; j < variable.values.count(); j++)
				{
					var value = variable.values.item(j);
					var res = t.expression.constructor.Expression(t, value.expression);
					var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
					if (is_static && is_const)
					{
						content += Runtime.rtl.toStr(t.s("const " + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr("=") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";")));
					}
					else if (is_static)
					{
						content += Runtime.rtl.toStr(t.s("static $" + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr("=") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";")));
					}
					else if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
					{
						content += Runtime.rtl.toStr(t.s("public $__" + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
					}
					else
					{
						content += Runtime.rtl.toStr(t.s("public $" + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
					}
				}
			}
		}
		/* Constructor */
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			var res = this.OpDeclareClassConstructor(t, op_code);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		/* Functions */
		if (op_code.functions != null)
		{
			for (var i = 0; i < op_code.functions.count(); i++)
			{
				var f = op_code.functions.item(i);
				var res = this.OpDeclareFunction(t, f);
				t = Runtime.rtl.attr(res, 0);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
		}
		/* Class items */
		for (var i = 0; i < op_code.items.count(); i++)
		{
			var item = op_code.items.item(i);
			if (item instanceof BayLang.OpCodes.OpPreprocessorIfCode)
			{
				var res = t.operator.constructor.OpPreprocessorIfCode(t, item);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpPreprocessorIfDef)
			{
				var res = t.operator.constructor.OpPreprocessorIfDef(t, item, BayLang.OpCodes.OpPreprocessorIfDef.KIND_CLASS_BODY);
				content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			}
			else if (item instanceof BayLang.OpCodes.OpPreprocessorSwitch)
			{
				for (var j = 0; j < item.items.count(); j++)
				{
					var res = t.operator.constructor.OpPreprocessorIfCode(t, item.items.item(j));
					var s = Runtime.rtl.attr(res, 1);
					if (s == "")
					{
						continue;
					}
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
		}
		/* Declare component functions */
		if (op_code.is_model || op_code.is_component)
		{
			var res = this.OpDeclareComponentFunctions(t, op_code);
			t = Runtime.rtl.attr(res, 0);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		}
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			content += Runtime.rtl.toStr(t.s("/* ======================= Class Init Functions ======================= */"));
		}
		/* Init variables */
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE && op_code.vars != null)
		{
			var vars = op_code.vars.filter((variable) =>
			{
				return !variable.flags.isFlag("static");
			});
			if (t.current_class_full_name != "Runtime.BaseObject" && vars.count() > 0)
			{
				content += Runtime.rtl.toStr(t.s("function _init($ctx)"));
				content += Runtime.rtl.toStr(t.s("{"));
				t = t.levelInc();
				if (t.current_class_extends_name != "")
				{
					content += Runtime.rtl.toStr(t.s("parent::_init($ctx);"));
				}
				for (var i = 0; i < op_code.vars.count(); i++)
				{
					var variable = op_code.vars.item(i);
					var is_static = variable.flags.isFlag("static");
					if (is_static)
					{
						continue;
					}
					if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
					{
						continue;
					}
					if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
					{
						continue;
					}
					var prefix = "";
					if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
					{
						prefix = "__";
					}
					else if (class_kind == BayLang.OpCodes.OpDeclareClass.KIND_CLASS)
					{
						prefix = "";
					}
					for (var j = 0; j < variable.values.count(); j++)
					{
						var value = variable.values.item(j);
						var res = t.expression.constructor.Expression(t, value.expression);
						var s = (value.expression != null) ? (Runtime.rtl.attr(res, 1)) : ("null");
						content += Runtime.rtl.toStr(t.s("$this->" + Runtime.rtl.toStr(prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = ") + Runtime.rtl.toStr(s) + Runtime.rtl.toStr(";")));
					}
				}
				t = t.levelDec();
				content += Runtime.rtl.toStr(t.s("}"));
			}
			/* Struct */
			if (op_code.is_component == false && class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
			{
				var is_struct = class_kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT;
				var var_prefix = (is_struct) ? ("__") : ("");
				if (!is_struct && false)
				{
					/* Assign Object */
					content += Runtime.rtl.toStr(t.s("function assignObject($ctx,$o)"));
					content += Runtime.rtl.toStr(t.s("{"));
					t = t.levelInc();
					content += Runtime.rtl.toStr(t.s("if ($o instanceof \\" + Runtime.rtl.toStr(Runtime.rs.replace("\\.", "\\", t.current_class_full_name)) + Runtime.rtl.toStr(")")));
					content += Runtime.rtl.toStr(t.s("{"));
					t = t.levelInc();
					for (var i = 0; i < op_code.vars.count(); i++)
					{
						var variable = op_code.vars.item(i);
						if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
						{
							continue;
						}
						if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
						{
							continue;
						}
						var is_const = variable.flags.isFlag("const");
						var is_static = variable.flags.isFlag("static");
						var is_protected = variable.flags.isFlag("protected");
						var is_private = variable.flags.isFlag("private");
						if (is_const || is_static)
						{
							continue;
						}
						if (is_protected || is_private)
						{
							continue;
						}
						for (var j = 0; j < variable.values.count(); j++)
						{
							var value = variable.values.item(j);
							content += Runtime.rtl.toStr(t.s("$this->" + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = $o->") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
						}
					}
					t = t.levelDec();
					content += Runtime.rtl.toStr(t.s("}"));
					if (t.current_class.extend_name)
					{
						content += Runtime.rtl.toStr(t.s("parent::assignObject($ctx,$o);"));
					}
					t = t.levelDec();
					content += Runtime.rtl.toStr(t.s("}"));
					/* Assign Value */
					content += Runtime.rtl.toStr(t.s("function assignValue($ctx,$k,$v)"));
					content += Runtime.rtl.toStr(t.s("{"));
					t = t.levelInc();
					var flag = false;
					for (var i = 0; i < op_code.vars.count(); i++)
					{
						var variable = op_code.vars.item(i);
						if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
						{
							continue;
						}
						if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
						{
							continue;
						}
						var is_const = variable.flags.isFlag("const");
						var is_static = variable.flags.isFlag("static");
						var is_protected = variable.flags.isFlag("protected");
						var is_private = variable.flags.isFlag("private");
						if (is_const || is_static)
						{
							continue;
						}
						if (is_protected || is_private)
						{
							continue;
						}
						for (var j = 0; j < variable.values.count(); j++)
						{
							var value = variable.values.item(j);
							if (t.flag_struct_check_types)
							{
								content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if ($k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr("$this->") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = Runtime.rtl.to($v, null, ") + Runtime.rtl.toStr(this.toPattern(t, variable.pattern)) + Runtime.rtl.toStr(");")));
							}
							else
							{
								content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if ($k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")") + Runtime.rtl.toStr("$this->") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(" = $v;")));
							}
							flag = true;
						}
					}
					if (t.current_class.extend_name)
					{
						content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("parent::assignValue($ctx,$k,$v);")));
					}
					t = t.levelDec();
					content += Runtime.rtl.toStr(t.s("}"));
				}
				/* Take Value */
				content += Runtime.rtl.toStr(t.s("function takeValue($ctx,$k,$d=null)"));
				content += Runtime.rtl.toStr(t.s("{"));
				t = t.levelInc();
				var flag = false;
				for (var i = 0; i < op_code.vars.count(); i++)
				{
					var variable = op_code.vars.item(i);
					if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
					{
						continue;
					}
					if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
					{
						continue;
					}
					var is_const = variable.flags.isFlag("const");
					var is_static = variable.flags.isFlag("static");
					var is_protected = variable.flags.isFlag("protected");
					var is_private = variable.flags.isFlag("private");
					if (is_const || is_static)
					{
						continue;
					}
					if (is_protected || is_private)
					{
						continue;
					}
					for (var j = 0; j < variable.values.count(); j++)
					{
						var value = variable.values.item(j);
						content += Runtime.rtl.toStr(t.s(((flag) ? ("else ") : ("")) + Runtime.rtl.toStr("if ($k == ") + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(")return $this->") + Runtime.rtl.toStr(var_prefix) + Runtime.rtl.toStr(value.var_name) + Runtime.rtl.toStr(";")));
						flag = true;
					}
				}
				if (t.current_class.extend_name)
				{
					content += Runtime.rtl.toStr(t.s("return parent::takeValue($ctx,$k,$d);"));
				}
				t = t.levelDec();
				content += Runtime.rtl.toStr(t.s("}"));
			}
		}
		if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			/* Get current namespace function */
			content += Runtime.rtl.toStr(t.s("static function getNamespace()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_namespace_name)) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get current class name function */
			content += Runtime.rtl.toStr(t.s("static function getClassName()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.current_class_full_name)) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get parent class name function */
			content += Runtime.rtl.toStr(t.s("static function getParentClassName()"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.toString(t.expression.constructor.findModuleName(t, t.current_class_extends_name))) + Runtime.rtl.toStr(";")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Class info */
			content += Runtime.rtl.toStr(t.s("static function getClassInfo($ctx)"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			t = t.constructor.clearSaveOpCode(t);
			content += Runtime.rtl.toStr(t.s("return \\Runtime\\Dict::from(["));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("\"annotations\"=>\\Runtime\\Collection::from(["));
			t = t.levelInc();
			for (var j = 0; j < op_code.annotations.count(); j++)
			{
				var annotation = op_code.annotations.item(j);
				var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
				t = Runtime.rtl.attr(res, 0);
				var name = Runtime.rtl.attr(res, 1);
				if (annotation.params != null)
				{
					var res = t.expression.constructor.OpDict(t, annotation.params, true);
					t = Runtime.rtl.attr(res, 0);
					var params = Runtime.rtl.attr(res, 1);
					content += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("($ctx, ") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
				}
				else
				{
					content += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("($ctx),")));
				}
			}
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("]),"));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("]);"));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get fields list of the function */
			content += Runtime.rtl.toStr(t.s("static function getFieldsList($ctx)"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("$a = [];"));
			if (op_code.vars != null)
			{
				var vars = new Runtime.Map();
				for (var i = 0; i < op_code.vars.count(); i++)
				{
					var variable = op_code.vars.item(i);
					var is_const = variable.flags.isFlag("const");
					var is_static = variable.flags.isFlag("static");
					var is_protected = variable.flags.isFlag("protected");
					var is_private = variable.flags.isFlag("private");
					var has_annotation = variable.annotations != null && variable.annotations.count() > 0;
					if (is_const || is_static)
					{
						continue;
					}
					if (is_protected || is_private)
					{
						continue;
					}
					if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
					{
						continue;
					}
					if (class_kind != BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
					{
						if (variable.annotations == null)
						{
							continue;
						}
						if (variable.annotations.count() == 0)
						{
							continue;
						}
					}
					if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
					{
						continue;
					}
					for (var j = 0; j < variable.values.count(); j++)
					{
						var value = variable.values.item(j);
						content += Runtime.rtl.toStr(t.s("$a[]=" + Runtime.rtl.toStr(t.expression.constructor.toString(value.var_name)) + Runtime.rtl.toStr(";")));
					}
				}
			}
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.getModuleName(t, "Runtime.Collection")) + Runtime.rtl.toStr("::from($a);")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get field info by name */
			content += Runtime.rtl.toStr(t.s("static function getFieldInfoByName($ctx,$field_name)"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			if (op_code.vars != null)
			{
				for (var i = 0; i < op_code.vars.count(); i++)
				{
					var variable = op_code.vars.item(i);
					if (variable.kind != BayLang.OpCodes.OpAssign.KIND_DECLARE)
					{
						continue;
					}
					if (variable.condition && Runtime.rtl.attr(t.preprocessor_flags, variable.condition.value) != true)
					{
						continue;
					}
					var is_const = variable.flags.isFlag("const");
					var is_static = variable.flags.isFlag("static");
					var is_protected = variable.flags.isFlag("protected");
					var is_private = variable.flags.isFlag("private");
					if (is_const || is_static)
					{
						continue;
					}
					if (is_protected || is_private)
					{
						continue;
					}
					if (variable.annotations == null)
					{
						continue;
					}
					if (variable.annotations.count() == 0)
					{
						continue;
					}
					var v = variable.values.map((value) =>
					{
						return value.var_name;
					});
					v = v.map((var_name) =>
					{
						return "$field_name == " + Runtime.rtl.toStr(t.expression.constructor.toString(var_name));
					});
					var var_type = Runtime.rs.join(".", t.expression.constructor.findModuleNames(t, variable.pattern.entity_name.names));
					var var_sub_types = (variable.pattern.template != null) ? (variable.pattern.template.map((op_code) =>
					{
						return Runtime.rs.join(".", t.expression.constructor.findModuleNames(t, op_code.entity_name.names));
					})) : (Runtime.Vector.from([]));
					var_sub_types = var_sub_types.map(t.expression.constructor.toString);
					t = t.constructor.clearSaveOpCode(t);
					content += Runtime.rtl.toStr(t.s("if (" + Runtime.rtl.toStr(Runtime.rs.join(" or ", v)) + Runtime.rtl.toStr(") ") + Runtime.rtl.toStr("return \\Runtime\\Dict::from([")));
					t = t.levelInc();
					content += Runtime.rtl.toStr(t.s("\"t\"=>" + Runtime.rtl.toStr(t.expression.constructor.toString(var_type)) + Runtime.rtl.toStr(",")));
					if (var_sub_types.count() > 0)
					{
						content += Runtime.rtl.toStr(t.s("\"s\"=> [" + Runtime.rtl.toStr(Runtime.rs.join(", ", var_sub_types)) + Runtime.rtl.toStr("],")));
					}
					content += Runtime.rtl.toStr(t.s("\"annotations\"=>\\Runtime\\Collection::from(["));
					t = t.levelInc();
					for (var j = 0; j < variable.annotations.count(); j++)
					{
						var annotation = variable.annotations.item(j);
						var res = t.expression.constructor.OpTypeIdentifier(t, annotation.name);
						t = Runtime.rtl.attr(res, 0);
						var name = Runtime.rtl.attr(res, 1);
						var res = t.expression.constructor.OpDict(t, annotation.params, true);
						t = Runtime.rtl.attr(res, 0);
						var params = Runtime.rtl.attr(res, 1);
						content += Runtime.rtl.toStr(t.s("new " + Runtime.rtl.toStr(name) + Runtime.rtl.toStr("($ctx, ") + Runtime.rtl.toStr(params) + Runtime.rtl.toStr("),")));
					}
					t = t.levelDec();
					content += Runtime.rtl.toStr(t.s("]),"));
					t = t.levelDec();
					content += Runtime.rtl.toStr(t.s("]);"));
				}
			}
			content += Runtime.rtl.toStr(t.s("return null;"));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get methods list of the function */
			content += Runtime.rtl.toStr(t.s("static function getMethodsList($ctx)"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			content += Runtime.rtl.toStr(t.s("$a=["));
			t = t.levelInc();
			if (op_code.functions != null)
			{
				for (var i = 0; i < op_code.functions.count(); i++)
				{
					var f = op_code.functions.item(i);
					if (f.flags.isFlag("declare"))
					{
						continue;
					}
					if (f.flags.isFlag("protected"))
					{
						continue;
					}
					if (f.flags.isFlag("private"))
					{
						continue;
					}
					if (f.annotations.count() == 0)
					{
						continue;
					}
					content += Runtime.rtl.toStr(t.s(t.expression.constructor.toString(f.name) + Runtime.rtl.toStr(",")));
				}
			}
			if (op_code.items != null)
			{
				for (var i = 0; i < op_code.items.count(); i++)
				{
					var item = op_code.items.item(i);
					var res = this.OpClassBodyItemMethodsList(t, item);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("];"));
			content += Runtime.rtl.toStr(t.s("return " + Runtime.rtl.toStr(t.expression.constructor.getModuleName(t, "Runtime.Collection")) + Runtime.rtl.toStr("::from($a);")));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
			/* Get method info by name */
			content += Runtime.rtl.toStr(t.s("static function getMethodInfoByName($ctx,$field_name)"));
			content += Runtime.rtl.toStr(t.s("{"));
			t = t.levelInc();
			if (op_code.functions != null)
			{
				for (var i = 0; i < op_code.functions.count(); i++)
				{
					var f = op_code.functions.item(i);
					var res = this.OpFunctionAnnotations(t, f);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
			if (op_code.items != null)
			{
				for (var i = 0; i < op_code.items.count(); i++)
				{
					var item = op_code.items.item(i);
					var res = this.OpClassBodyItemAnnotations(t, item);
					t = Runtime.rtl.attr(res, 0);
					content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
				}
			}
			content += Runtime.rtl.toStr(t.s("return null;"));
			t = t.levelDec();
			content += Runtime.rtl.toStr(t.s("}"));
		}
		t = t.levelDec();
		content += Runtime.rtl.toStr(t.s("}"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClassFooter
	 */
	OpDeclareClassFooter: function(t, op_code)
	{
		var content = "";
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClass
	 */
	OpDeclareClass: function(t, op_code)
	{
		if (op_code.is_abstract)
		{
			return Runtime.Vector.from([t,""]);
		}
		if (op_code.is_declare)
		{
			throw new BayLang.Exceptions.DeclaredClass()
			return Runtime.Vector.from([t,""]);
		}
		var content = "";
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class"]), op_code);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_name"]), op_code.name);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_full_name"]), t.current_namespace_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(t.current_class_name));
		if (op_code.class_extends != null)
		{
			var extends_name = Runtime.rs.join(".", op_code.class_extends.entity_name.names);
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_extends_name"]), extends_name);
		}
		else if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_extends_name"]), "Runtime.BaseStruct");
		}
		else if (op_code.kind == BayLang.OpCodes.OpDeclareClass.KIND_STRUCT)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["current_class_extends_name"]), "");
		}
		if (op_code.kind != BayLang.OpCodes.OpDeclareClass.KIND_INTERFACE)
		{
			if (op_code.class_extends != null)
			{
				content = "class " + Runtime.rtl.toStr(t.current_class_name) + Runtime.rtl.toStr(" extends ") + Runtime.rtl.toStr(t.expression.constructor.getModuleName(t, t.current_class_extends_name));
			}
			else
			{
				content = "class " + Runtime.rtl.toStr(t.current_class_name);
			}
		}
		else
		{
			content = "interface " + Runtime.rtl.toStr(t.current_class_name);
		}
		/* Add implements */
		if (op_code.class_implements != null && op_code.class_implements.count() > 0)
		{
			var arr = op_code.class_implements.map((item) =>
			{
				return t.expression.constructor.getModuleNames(t, item.entity_name.names);
			});
			var s1 = Runtime.rs.join(", ", arr);
			content += Runtime.rtl.toStr(" implements " + Runtime.rtl.toStr(s1));
		}
		/* Class body */
		var res = this.OpDeclareClassBody(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		/* Class comments */
		var res = t.operator.constructor.AddComments(t, op_code.comments, content);
		content = Runtime.rtl.attr(res, 1);
		/* Class footer */
		var res = this.OpDeclareClassFooter(t, op_code);
		content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
		return Runtime.Vector.from([t,t.s(content)]);
	},
	/**
	 * Translate item
	 */
	translateItem: function(t, op_code)
	{
		if (op_code instanceof BayLang.OpCodes.OpNamespace)
		{
			return this.OpNamespace(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpDeclareClass)
		{
			return this.OpDeclareClass(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpComment)
		{
			return t.operator.constructor.OpComment(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorIfCode)
		{
			return t.operator.constructor.OpPreprocessorIfCode(t, op_code);
		}
		else if (op_code instanceof BayLang.OpCodes.OpPreprocessorSwitch)
		{
			var content = "";
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var res = t.operator.constructor.OpPreprocessorIfCode(t, op_code.items.item(i));
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
			return Runtime.Vector.from([t,content]);
		}
		return Runtime.Vector.from([t,""]);
	},
	/**
	 * Translate program
	 */
	translateProgramHeader: function(t, op_code)
	{
		var content = "<?php";
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * Translate program
	 */
	translateProgram: function(t, op_code)
	{
		var content = "";
		if (op_code == null)
		{
			return Runtime.Vector.from([t,content]);
		}
		if (op_code.uses != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["modules"]), op_code.uses);
		}
		if (op_code.items != null)
		{
			var res = this.translateProgramHeader(t, op_code);
			content += Runtime.rtl.toStr(Runtime.rtl.attr(res, 1));
			for (var i = 0; i < op_code.items.count(); i++)
			{
				var item = op_code.items.item(i);
				var res = this.translateItem(t, item);
				t = Runtime.rtl.attr(res, 0);
				var s = Runtime.rtl.attr(res, 1);
				if (s == "")
				{
					continue;
				}
				content += Runtime.rtl.toStr(s);
			}
		}
		content = Runtime.rs.trim(content);
		/* Disable context */
		if (t.enable_context == false)
		{
			content = Runtime.rs.replace("($ctx)", "()", content);
			content = Runtime.rs.replace("($ctx, ", "(", content);
			content = Runtime.rs.replace("($ctx,", "(", content);
			content = Runtime.rs.replace(",$ctx,", ",", content);
		}
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangPHP";
	},
	getClassName: function()
	{
		return "BayLang.LangPHP.TranslatorPHPProgram";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangPHP.TranslatorPHPProgram);
window["BayLang.LangPHP.TranslatorPHPProgram"] = BayLang.LangPHP.TranslatorPHPProgram;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangPHP.TranslatorPHPProgram;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.BaseOpCode = function(params)
{
	if (params == undefined) params = null;
	Runtime.BaseObject.call(this);
	this._assign_values(params);
};
BayLang.OpCodes.BaseOpCode.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.OpCodes.BaseOpCode.prototype.constructor = BayLang.OpCodes.BaseOpCode;
Object.assign(BayLang.OpCodes.BaseOpCode.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "caret_start", data);
		serializer.process(this, "caret_end", data);
	},
	/**
	 * Is multiline
	 */
	isMultiLine: function()
	{
		if (!this.caret_start)
		{
			return true;
		}
		if (!this.caret_end)
		{
			return true;
		}
		return this.caret_start.y != this.caret_end.y;
	},
	/**
	 * Clone this struct with new values
	 * @param Map obj = null
	 * @return BaseStruct
	 */
	clone: function(obj)
	{
		if (obj == undefined) obj = null;
		if (obj == null)
		{
			return this;
		}
		var proto = Object.getPrototypeOf(this);
		var item = Object.create(proto);
		item = Object.assign(item, this);
		item._assign_values(obj);
		
		return item;
		return this;
	},
	/**
	 * Copy this struct with new values
	 * @param Map obj = null
	 * @return BaseStruct
	 */
	copy: function(obj)
	{
		if (obj == undefined) obj = null;
		return this.clone(obj);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.caret_start = null;
		this.caret_end = null;
	},
});
Object.assign(BayLang.OpCodes.BaseOpCode, Runtime.BaseObject);
Object.assign(BayLang.OpCodes.BaseOpCode,
{
	op: "",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
	__implements__:
	[
		Runtime.SerializeInterface,
	],
});
Runtime.rtl.defClass(BayLang.OpCodes.BaseOpCode);
window["BayLang.OpCodes.BaseOpCode"] = BayLang.OpCodes.BaseOpCode;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.BaseOpCode;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpAnnotation = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpAnnotation.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpAnnotation.prototype.constructor = BayLang.OpCodes.OpAnnotation;
Object.assign(BayLang.OpCodes.OpAnnotation.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "name", data);
		serializer.process(this, "params", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_annotation";
		this.name = null;
		this.params = null;
	},
});
Object.assign(BayLang.OpCodes.OpAnnotation, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpAnnotation,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpAnnotation";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpAnnotation);
window["BayLang.OpCodes.OpAnnotation"] = BayLang.OpCodes.OpAnnotation;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpAnnotation;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpAssign = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpAssign.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpAssign.prototype.constructor = BayLang.OpCodes.OpAssign;
Object.assign(BayLang.OpCodes.OpAssign.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "annotations", data);
		serializer.process(this, "comments", data);
		serializer.process(this, "condition", data);
		serializer.process(this, "expression", data);
		serializer.process(this, "flags", data);
		serializer.process(this, "kind", data);
		serializer.process(this, "names", data);
		serializer.process(this, "pattern", data);
		serializer.process(this, "values", data);
		serializer.process(this, "var_name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.kind = "";
		this.var_name = "";
		this.flags = null;
		this.pattern = null;
		this.annotations = null;
		this.comments = null;
		this.values = null;
		this.names = null;
		this.expression = null;
		this.condition = null;
	},
});
Object.assign(BayLang.OpCodes.OpAssign, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpAssign,
{
	KIND_ASSIGN: "assign",
	KIND_DECLARE: "declare",
	KIND_STRUCT: "struct",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpAssign";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpAssign);
window["BayLang.OpCodes.OpAssign"] = BayLang.OpCodes.OpAssign;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpAssign;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpAssignStruct = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpAssignStruct.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpAssignStruct.prototype.constructor = BayLang.OpCodes.OpAssignStruct;
Object.assign(BayLang.OpCodes.OpAssignStruct.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "annotations", data);
		serializer.process(this, "comments", data);
		serializer.process(this, "expression", data);
		serializer.process(this, "names", data);
		serializer.process(this, "var_name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.var_name = "";
		this.annotations = null;
		this.comments = null;
		this.names = null;
		this.expression = null;
	},
});
Object.assign(BayLang.OpCodes.OpAssignStruct, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpAssignStruct,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpAssignStruct";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpAssignStruct);
window["BayLang.OpCodes.OpAssignStruct"] = BayLang.OpCodes.OpAssignStruct;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpAssignStruct;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpAssignValue = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpAssignValue.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpAssignValue.prototype.constructor = BayLang.OpCodes.OpAssignValue;
Object.assign(BayLang.OpCodes.OpAssignValue.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "expression", data);
		serializer.process(this, "op_code", data);
		serializer.process(this, "var_name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "";
		this.var_name = "";
		this.op_code = null;
		this.expression = null;
	},
});
Object.assign(BayLang.OpCodes.OpAssignValue, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpAssignValue,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpAssignValue";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpAssignValue);
window["BayLang.OpCodes.OpAssignValue"] = BayLang.OpCodes.OpAssignValue;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpAssignValue;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpAttr = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpAttr.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpAttr.prototype.constructor = BayLang.OpCodes.OpAttr;
Object.assign(BayLang.OpCodes.OpAttr.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "attrs", data);
		serializer.process(this, "kind", data);
		serializer.process(this, "obj", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_attr";
		this.kind = "";
		this.obj = null;
		this.value = null;
		this.attrs = null;
	},
});
Object.assign(BayLang.OpCodes.OpAttr, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpAttr,
{
	KIND_ATTR: "attr",
	KIND_STATIC: "static",
	KIND_DYNAMIC: "dynamic",
	KIND_DYNAMIC_ATTRS: "dynamic_attrs",
	KIND_PIPE: "pipe",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpAttr";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpAttr);
window["BayLang.OpCodes.OpAttr"] = BayLang.OpCodes.OpAttr;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpAttr;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpBreak = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpBreak.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpBreak.prototype.constructor = BayLang.OpCodes.OpBreak;
Object.assign(BayLang.OpCodes.OpBreak.prototype,
{
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_break";
	},
});
Object.assign(BayLang.OpCodes.OpBreak, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpBreak,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpBreak";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpBreak);
window["BayLang.OpCodes.OpBreak"] = BayLang.OpCodes.OpBreak;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpBreak;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpCall = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpCall.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpCall.prototype.constructor = BayLang.OpCodes.OpCall;
Object.assign(BayLang.OpCodes.OpCall.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "args", data);
		serializer.process(this, "is_await", data);
		serializer.process(this, "is_context", data);
		serializer.process(this, "is_html", data);
		serializer.process(this, "obj", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_call";
		this.obj = null;
		this.args = null;
		this.is_await = false;
		this.is_context = true;
		this.is_html = false;
	},
});
Object.assign(BayLang.OpCodes.OpCall, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpCall,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpCall";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpCall);
window["BayLang.OpCodes.OpCall"] = BayLang.OpCodes.OpCall;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpCall;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpClassOf = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpClassOf.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpClassOf.prototype.constructor = BayLang.OpCodes.OpClassOf;
Object.assign(BayLang.OpCodes.OpClassOf.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "entity_name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_classof";
		this.entity_name = null;
	},
});
Object.assign(BayLang.OpCodes.OpClassOf, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpClassOf,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpClassOf";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpClassOf);
window["BayLang.OpCodes.OpClassOf"] = BayLang.OpCodes.OpClassOf;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpClassOf;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpClassRef = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpClassRef.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpClassRef.prototype.constructor = BayLang.OpCodes.OpClassRef;
Object.assign(BayLang.OpCodes.OpClassRef.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_classref";
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpClassRef, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpClassRef,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpClassRef";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpClassRef);
window["BayLang.OpCodes.OpClassRef"] = BayLang.OpCodes.OpClassRef;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpClassRef;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpCollection = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpCollection.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpCollection.prototype.constructor = BayLang.OpCodes.OpCollection;
Object.assign(BayLang.OpCodes.OpCollection.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "values", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_collection";
		this.values = null;
	},
});
Object.assign(BayLang.OpCodes.OpCollection, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpCollection,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpCollection";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpCollection);
window["BayLang.OpCodes.OpCollection"] = BayLang.OpCodes.OpCollection;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpCollection;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpComment = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpComment.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpComment.prototype.constructor = BayLang.OpCodes.OpComment;
Object.assign(BayLang.OpCodes.OpComment.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_comment";
		this.value = "";
	},
});
Object.assign(BayLang.OpCodes.OpComment, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpComment,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpComment";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpComment);
window["BayLang.OpCodes.OpComment"] = BayLang.OpCodes.OpComment;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpComment;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpContinue = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpContinue.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpContinue.prototype.constructor = BayLang.OpCodes.OpContinue;
Object.assign(BayLang.OpCodes.OpContinue.prototype,
{
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_continue";
	},
});
Object.assign(BayLang.OpCodes.OpContinue, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpContinue,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpContinue";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpContinue);
window["BayLang.OpCodes.OpContinue"] = BayLang.OpCodes.OpContinue;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpContinue;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpCurry = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpCurry.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpCurry.prototype.constructor = BayLang.OpCodes.OpCurry;
Object.assign(BayLang.OpCodes.OpCurry.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "args", data);
		serializer.process(this, "obj", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_curry";
		this.obj = null;
		this.args = null;
	},
});
Object.assign(BayLang.OpCodes.OpCurry, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpCurry,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpCurry";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpCurry);
window["BayLang.OpCodes.OpCurry"] = BayLang.OpCodes.OpCurry;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpCurry;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpCurryArg = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpCurryArg.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpCurryArg.prototype.constructor = BayLang.OpCodes.OpCurryArg;
Object.assign(BayLang.OpCodes.OpCurryArg.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "pos", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_curry";
		this.pos = 0;
	},
});
Object.assign(BayLang.OpCodes.OpCurryArg, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpCurryArg,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpCurryArg";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpCurryArg);
window["BayLang.OpCodes.OpCurryArg"] = BayLang.OpCodes.OpCurryArg;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpCurryArg;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDeclareClass = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDeclareClass.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDeclareClass.prototype.constructor = BayLang.OpCodes.OpDeclareClass;
Object.assign(BayLang.OpCodes.OpDeclareClass.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "annotations", data);
		serializer.process(this, "class_extends", data);
		serializer.process(this, "class_implements", data);
		serializer.process(this, "comments", data);
		serializer.process(this, "extend_name", data);
		serializer.process(this, "flags", data);
		serializer.process(this, "fn_create", data);
		serializer.process(this, "fn_destroy", data);
		serializer.process(this, "functions", data);
		serializer.process(this, "is_abstract", data);
		serializer.process(this, "is_component", data);
		serializer.process(this, "is_declare", data);
		serializer.process(this, "is_model", data);
		serializer.process(this, "items", data);
		serializer.process(this, "kind", data);
		serializer.process(this, "name", data);
		serializer.process(this, "template", data);
		serializer.process(this, "vars", data);
	},
	/**
	 * Find function
	 */
	findFunction: function(name)
	{
		return this.items.findItem((op_code) =>
		{
			return op_code instanceof BayLang.OpCodes.OpDeclareFunction && op_code.name == name;
		});
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_class";
		this.kind = "";
		this.name = "";
		this.extend_name = "";
		this.annotations = null;
		this.comments = null;
		this.template = null;
		this.flags = null;
		this.fn_create = null;
		this.fn_destroy = null;
		this.class_extends = null;
		this.class_implements = null;
		this.vars = null;
		this.functions = null;
		this.items = null;
		this.is_abstract = false;
		this.is_static = false;
		this.is_declare = false;
		this.is_component = false;
		this.is_model = false;
	},
});
Object.assign(BayLang.OpCodes.OpDeclareClass, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDeclareClass,
{
	KIND_CLASS: "class",
	KIND_STRUCT: "struct",
	KIND_INTERFACE: "interface",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDeclareClass";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDeclareClass);
window["BayLang.OpCodes.OpDeclareClass"] = BayLang.OpCodes.OpDeclareClass;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDeclareClass;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDeclareFunction = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDeclareFunction.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDeclareFunction.prototype.constructor = BayLang.OpCodes.OpDeclareFunction;
Object.assign(BayLang.OpCodes.OpDeclareFunction.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "annotations", data);
		serializer.process(this, "args", data);
		serializer.process(this, "comments", data);
		serializer.process(this, "expression", data);
		serializer.process(this, "flags", data);
		serializer.process(this, "is_context", data);
		serializer.process(this, "is_html", data);
		serializer.process(this, "is_html_default_args", data);
		serializer.process(this, "items", data);
		serializer.process(this, "name", data);
		serializer.process(this, "result_type", data);
		serializer.process(this, "vars", data);
	},
	/**
	 * Returns true if static function
	 */
	isStatic: function()
	{
		return this.flags != null && (this.flags.isFlag("static") || this.flags.isFlag("lambda") || this.flags.isFlag("pure"));
	},
	/**
	 * Returns true if is flag
	 */
	isFlag: function(flag_name)
	{
		return this.flags != null && this.flags.isFlag(flag_name);
	},
	/**
	 * Returns function expression
	 */
	getExpression: function()
	{
		if (this.expression != null)
		{
			return this.expression;
		}
		if (!(this.items instanceof BayLang.OpCodes.OpItems))
		{
			return null;
		}
		var op_code_item = this.items.items.get(0);
		if (!(op_code_item instanceof BayLang.OpCodes.OpReturn))
		{
			return null;
		}
		return op_code_item.expression;
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_function";
		this.name = "";
		this.annotations = null;
		this.comments = null;
		this.args = null;
		this.vars = null;
		this.result_type = null;
		this.expression = null;
		this.items = null;
		this.flags = null;
		this.is_context = true;
		this.is_html = false;
		this.is_html_default_args = false;
	},
});
Object.assign(BayLang.OpCodes.OpDeclareFunction, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDeclareFunction,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDeclareFunction";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDeclareFunction);
window["BayLang.OpCodes.OpDeclareFunction"] = BayLang.OpCodes.OpDeclareFunction;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDeclareFunction;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDeclareFunctionArg = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDeclareFunctionArg.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDeclareFunctionArg.prototype.constructor = BayLang.OpCodes.OpDeclareFunctionArg;
Object.assign(BayLang.OpCodes.OpDeclareFunctionArg.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "expression", data);
		serializer.process(this, "name", data);
		serializer.process(this, "pattern", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_function_arg";
		this.pattern = null;
		this.name = "";
		this.expression = null;
	},
});
Object.assign(BayLang.OpCodes.OpDeclareFunctionArg, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDeclareFunctionArg,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDeclareFunctionArg";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDeclareFunctionArg);
window["BayLang.OpCodes.OpDeclareFunctionArg"] = BayLang.OpCodes.OpDeclareFunctionArg;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDeclareFunctionArg;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDelete = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDelete.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDelete.prototype.constructor = BayLang.OpCodes.OpDelete;
Object.assign(BayLang.OpCodes.OpDelete.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "op_code", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_delete";
		this.op_code = null;
	},
});
Object.assign(BayLang.OpCodes.OpDelete, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDelete,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDelete";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDelete);
window["BayLang.OpCodes.OpDelete"] = BayLang.OpCodes.OpDelete;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDelete;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDict = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDict.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDict.prototype.constructor = BayLang.OpCodes.OpDict;
Object.assign(BayLang.OpCodes.OpDict.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "values", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_dict";
		this.values = null;
	},
});
Object.assign(BayLang.OpCodes.OpDict, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDict,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDict";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDict);
window["BayLang.OpCodes.OpDict"] = BayLang.OpCodes.OpDict;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDict;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpDictPair = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpDictPair.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpDictPair.prototype.constructor = BayLang.OpCodes.OpDictPair;
Object.assign(BayLang.OpCodes.OpDictPair.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "key", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.key = "";
		this.value = null;
		this.condition = null;
	},
});
Object.assign(BayLang.OpCodes.OpDictPair, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpDictPair,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpDictPair";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpDictPair);
window["BayLang.OpCodes.OpDictPair"] = BayLang.OpCodes.OpDictPair;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpDictPair;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpEntityName = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpEntityName.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpEntityName.prototype.constructor = BayLang.OpCodes.OpEntityName;
Object.assign(BayLang.OpCodes.OpEntityName.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "names", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_entity_name";
		this.names = null;
	},
});
Object.assign(BayLang.OpCodes.OpEntityName, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpEntityName,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpEntityName";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpEntityName);
window["BayLang.OpCodes.OpEntityName"] = BayLang.OpCodes.OpEntityName;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpEntityName;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpFlags = function(params)
{
	if (params == undefined) params = null;
	Runtime.BaseObject.call(this);
	this._assign_values(params);
};
BayLang.OpCodes.OpFlags.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.OpCodes.OpFlags.prototype.constructor = BayLang.OpCodes.OpFlags;
Object.assign(BayLang.OpCodes.OpFlags.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "p_assignable", data);
		serializer.process(this, "p_async", data);
		serializer.process(this, "p_cloneable", data);
		serializer.process(this, "p_const", data);
		serializer.process(this, "p_declare", data);
		serializer.process(this, "p_export", data);
		serializer.process(this, "p_lambda", data);
		serializer.process(this, "p_memorize", data);
		serializer.process(this, "p_multiblock", data);
		serializer.process(this, "p_private", data);
		serializer.process(this, "p_props", data);
		serializer.process(this, "p_protected", data);
		serializer.process(this, "p_public", data);
		serializer.process(this, "p_pure", data);
		serializer.process(this, "p_serializable", data);
		serializer.process(this, "p_static", data);
	},
	/**
	 * Read is Flag
	 */
	isFlag: function(name)
	{
		if (!BayLang.OpCodes.OpFlags.hasFlag(name))
		{
			return false;
		}
		return Runtime.rtl.attr(this, "p_" + Runtime.rtl.toStr(name));
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.p_async = false;
		this.p_export = false;
		this.p_static = false;
		this.p_const = false;
		this.p_public = false;
		this.p_private = false;
		this.p_protected = false;
		this.p_declare = false;
		this.p_serializable = false;
		this.p_cloneable = false;
		this.p_assignable = false;
		this.p_memorize = false;
		this.p_multiblock = false;
		this.p_lambda = false;
		this.p_pure = false;
		this.p_props = false;
	},
});
Object.assign(BayLang.OpCodes.OpFlags, Runtime.BaseObject);
Object.assign(BayLang.OpCodes.OpFlags,
{
	/**
	 * Get flags
	 */
	getFlags: function()
	{
		return Runtime.Vector.from(["async","export","static","const","public","private","declare","protected","serializable","cloneable","assignable","memorize","multiblock","pure","props"]);
	},
	/**
	 * Get flags
	 */
	hasFlag: function(flag_name)
	{
		if (flag_name == "async" || flag_name == "export" || flag_name == "static" || flag_name == "const" || flag_name == "public" || flag_name == "private" || flag_name == "declare" || flag_name == "protected" || flag_name == "serializable" || flag_name == "cloneable" || flag_name == "assignable" || flag_name == "memorize" || flag_name == "multiblock" || flag_name == "lambda" || flag_name == "pure" || flag_name == "props")
		{
			return true;
		}
		return false;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpFlags";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
	__implements__:
	[
		Runtime.SerializeInterface,
	],
});
Runtime.rtl.defClass(BayLang.OpCodes.OpFlags);
window["BayLang.OpCodes.OpFlags"] = BayLang.OpCodes.OpFlags;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpFlags;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpFor = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpFor.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpFor.prototype.constructor = BayLang.OpCodes.OpFor;
Object.assign(BayLang.OpCodes.OpFor.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "expr1", data);
		serializer.process(this, "expr2", data);
		serializer.process(this, "expr3", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_for";
		this.expr1 = null;
		this.expr2 = null;
		this.expr3 = null;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpFor, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpFor,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpFor";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpFor);
window["BayLang.OpCodes.OpFor"] = BayLang.OpCodes.OpFor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpFor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlAttribute = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlAttribute.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlAttribute.prototype.constructor = BayLang.OpCodes.OpHtmlAttribute;
Object.assign(BayLang.OpCodes.OpHtmlAttribute.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "is_spread", data);
		serializer.process(this, "key", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_attr";
		this.key = "";
		this.value = null;
		this.is_spread = false;
	},
});
Object.assign(BayLang.OpCodes.OpHtmlAttribute, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlAttribute,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlAttribute";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlAttribute);
window["BayLang.OpCodes.OpHtmlAttribute"] = BayLang.OpCodes.OpHtmlAttribute;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlAttribute;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlContent = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlContent.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlContent.prototype.constructor = BayLang.OpCodes.OpHtmlContent;
Object.assign(BayLang.OpCodes.OpHtmlContent.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_content";
		this.value = "";
	},
});
Object.assign(BayLang.OpCodes.OpHtmlContent, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlContent,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlContent";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlContent);
window["BayLang.OpCodes.OpHtmlContent"] = BayLang.OpCodes.OpHtmlContent;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlContent;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlItems = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlItems.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlItems.prototype.constructor = BayLang.OpCodes.OpHtmlItems;
Object.assign(BayLang.OpCodes.OpHtmlItems.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html";
		this.items = Runtime.Vector.from([]);
	},
});
Object.assign(BayLang.OpCodes.OpHtmlItems, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlItems,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlItems";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlItems);
window["BayLang.OpCodes.OpHtmlItems"] = BayLang.OpCodes.OpHtmlItems;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlItems;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlSlot = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlSlot.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlSlot.prototype.constructor = BayLang.OpCodes.OpHtmlSlot;
Object.assign(BayLang.OpCodes.OpHtmlSlot.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "attrs", data);
		serializer.process(this, "items", data);
		serializer.process(this, "name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_slot";
		this.name = "";
		this.args = null;
		this.attrs = null;
		this.vars = null;
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpHtmlSlot, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlSlot,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlSlot";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlSlot);
window["BayLang.OpCodes.OpHtmlSlot"] = BayLang.OpCodes.OpHtmlSlot;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlSlot;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlStyle = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlStyle.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlStyle.prototype.constructor = BayLang.OpCodes.OpHtmlStyle;
Object.assign(BayLang.OpCodes.OpHtmlStyle.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "content", data);
		serializer.process(this, "is_global", data);
		serializer.process(this, "value", data);
	},
	/**
	 * Read styles from content
	 */
	readStyles: function()
	{
		var reader = new BayLang.TokenReader();
		reader.init(new BayLang.Caret(Runtime.Map.from({"content":new Runtime.Reference(this.content)})));
		var styles = Runtime.Map.from({});
		while (!reader.eof() && reader.nextToken() == ".")
		{
			var selector = this.readSelector(reader);
			var code = this.readCssBlock(reader);
			styles.set(selector, code);
		}
		return styles;
	},
	/**
	 * Read selector
	 */
	readSelector: function(reader)
	{
		var items = Runtime.Vector.from([]);
		while (!reader.eof() && reader.nextToken() != "{")
		{
			items.push(reader.readToken());
		}
		return Runtime.rs.join("", items);
	},
	/**
	 * Read css block
	 */
	readCssBlock: function(reader)
	{
		reader.matchToken("{");
		var caret = reader.main_caret;
		caret.skipSpace();
		var level = 0;
		var items = Runtime.Vector.from([]);
		while (!caret.eof() && (caret.nextChar() != "}" && level == 0 || level > 0))
		{
			var ch = caret.readChar();
			if (ch != "\t")
			{
				items.push(ch);
			}
			if (ch == "{")
			{
				level = level + 1;
			}
			if (ch == "}")
			{
				level = level - 1;
			}
		}
		reader.init(caret);
		reader.matchToken("}");
		return Runtime.rs.trim(Runtime.rs.join("", items));
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_style";
		this.content = "";
		this.is_global = false;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpHtmlStyle, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlStyle,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlStyle";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlStyle);
window["BayLang.OpCodes.OpHtmlStyle"] = BayLang.OpCodes.OpHtmlStyle;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlStyle;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlTag = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlTag.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlTag.prototype.constructor = BayLang.OpCodes.OpHtmlTag;
Object.assign(BayLang.OpCodes.OpHtmlTag.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "attrs", data);
		serializer.process(this, "items", data);
		serializer.process(this, "op_code_name", data);
		serializer.process(this, "spreads", data);
		serializer.process(this, "tag_name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_tag";
		this.tag_name = "";
		this.op_code_name = null;
		this.attrs = null;
		this.spreads = null;
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpHtmlTag, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlTag,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlTag";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlTag);
window["BayLang.OpCodes.OpHtmlTag"] = BayLang.OpCodes.OpHtmlTag;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlTag;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpHtmlValue = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpHtmlValue.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpHtmlValue.prototype.constructor = BayLang.OpCodes.OpHtmlValue;
Object.assign(BayLang.OpCodes.OpHtmlValue.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "kind", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_html_value";
		this.kind = "";
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpHtmlValue, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpHtmlValue,
{
	KIND_RAW: "raw",
	KIND_JSON: "json",
	KIND_HTML: "html",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpHtmlValue";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpHtmlValue);
window["BayLang.OpCodes.OpHtmlValue"] = BayLang.OpCodes.OpHtmlValue;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpHtmlValue;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpIdentifier = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpIdentifier.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpIdentifier.prototype.constructor = BayLang.OpCodes.OpIdentifier;
Object.assign(BayLang.OpCodes.OpIdentifier.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "kind", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_identifier";
		this.value = "";
		this.kind = "";
	},
});
Object.assign(BayLang.OpCodes.OpIdentifier, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpIdentifier,
{
	KIND_PIPE: "pipe",
	KIND_VARIABLE: "var",
	KIND_SYS_TYPE: "sys",
	KIND_SYS_FUNCTION: "sys_fn",
	KIND_FUNCTION: "fn",
	KIND_CONTEXT: "ctx",
	KIND_CONSTANT: "const",
	KIND_CLASS: "class",
	KIND_CLASSREF: "classref",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpIdentifier";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpIdentifier);
window["BayLang.OpCodes.OpIdentifier"] = BayLang.OpCodes.OpIdentifier;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpIdentifier;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpIf = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpIf.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpIf.prototype.constructor = BayLang.OpCodes.OpIf;
Object.assign(BayLang.OpCodes.OpIf.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "if_else", data);
		serializer.process(this, "if_false", data);
		serializer.process(this, "if_true", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_if";
		this.condition = null;
		this.if_true = null;
		this.if_false = null;
		this.if_else = null;
	},
});
Object.assign(BayLang.OpCodes.OpIf, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpIf,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpIf";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpIf);
window["BayLang.OpCodes.OpIf"] = BayLang.OpCodes.OpIf;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpIf;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpIfElse = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpIfElse.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpIfElse.prototype.constructor = BayLang.OpCodes.OpIfElse;
Object.assign(BayLang.OpCodes.OpIfElse.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "if_true", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.condition = null;
		this.if_true = null;
	},
});
Object.assign(BayLang.OpCodes.OpIfElse, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpIfElse,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpIfElse";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpIfElse);
window["BayLang.OpCodes.OpIfElse"] = BayLang.OpCodes.OpIfElse;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpIfElse;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpInc = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpInc.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpInc.prototype.constructor = BayLang.OpCodes.OpInc;
Object.assign(BayLang.OpCodes.OpInc.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "kind", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_inc";
		this.kind = "";
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpInc, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpInc,
{
	KIND_PRE_INC: "pre_inc",
	KIND_PRE_DEC: "pre_dec",
	KIND_POST_INC: "post_inc",
	KIND_POST_DEC: "post_dec",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpInc";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpInc);
window["BayLang.OpCodes.OpInc"] = BayLang.OpCodes.OpInc;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpInc;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpItems = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpItems.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpItems.prototype.constructor = BayLang.OpCodes.OpItems;
Object.assign(BayLang.OpCodes.OpItems.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_items";
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpItems, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpItems,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpItems";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpItems);
window["BayLang.OpCodes.OpItems"] = BayLang.OpCodes.OpItems;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpItems;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpMath = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpMath.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpMath.prototype.constructor = BayLang.OpCodes.OpMath;
Object.assign(BayLang.OpCodes.OpMath.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "math", data);
		serializer.process(this, "value1", data);
		serializer.process(this, "value2", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_math";
		this.value1 = null;
		this.value2 = null;
		this.math = "";
	},
});
Object.assign(BayLang.OpCodes.OpMath, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpMath,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpMath";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpMath);
window["BayLang.OpCodes.OpMath"] = BayLang.OpCodes.OpMath;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpMath;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpMethod = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpMethod.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpMethod.prototype.constructor = BayLang.OpCodes.OpMethod;
Object.assign(BayLang.OpCodes.OpMethod.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "kind", data);
		serializer.process(this, "value1", data);
		serializer.process(this, "value2", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_method";
		this.value1 = null;
		this.value2 = null;
		this.kind = "";
	},
});
Object.assign(BayLang.OpCodes.OpMethod, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpMethod,
{
	KIND_ATTR: "attr",
	KIND_STATIC: "static",
	KIND_CLASS: "class",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpMethod";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpMethod);
window["BayLang.OpCodes.OpMethod"] = BayLang.OpCodes.OpMethod;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpMethod;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpModule = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpModule.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpModule.prototype.constructor = BayLang.OpCodes.OpModule;
Object.assign(BayLang.OpCodes.OpModule.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "is_component", data);
		serializer.process(this, "items", data);
		serializer.process(this, "uses", data);
	},
	/**
	 * Add module
	 */
	addModule: function(class_name, alias_name, is_component)
	{
		if (alias_name == undefined) alias_name = "";
		if (is_component == undefined) is_component = true;
		if (alias_name != "")
		{
			this.uses.set(alias_name, class_name);
		}
		/* Add op_code */
		var pos = this.items.find(Runtime.lib.isInstance("BayLang.OpCodes.OpNamespace"));
		var op_code = new BayLang.OpCodes.OpUse(Runtime.Map.from({"alias":alias_name,"name":class_name,"is_component":is_component}));
		if (pos != -1)
		{
			pos = pos + 1;
			while (pos < this.items.count())
			{
				var item = this.items.get(pos);
				if (item == null)
				{
					break;
				}
				if (!(item instanceof BayLang.OpCodes.OpUse))
				{
					break;
				}
				if (Runtime.rs.compare(class_name, item.name) == -1)
				{
					break;
				}
				pos = pos + 1;
			}
			this.items.insert(pos, op_code);
		}
		else
		{
			this.items.prepend(op_code);
		}
	},
	/**
	 * Has module
	 */
	hasModule: function(alias_name)
	{
		return this.uses.has(alias_name);
	},
	/**
	 * Find alias name
	 */
	findModule: function(class_name)
	{
		var keys = this.uses.keys();
		for (var i = 0; i < keys.count(); i++)
		{
			var key_name = keys.get(i);
			if (this.uses.get(key_name) == class_name)
			{
				return key_name;
			}
		}
		return null;
	},
	/**
	 * Find class
	 */
	findClass: function()
	{
		return (this.items) ? (this.items.findItem(Runtime.lib.isInstance("BayLang.OpCodes.OpDeclareClass"))) : (null);
	},
	/**
	 * Find class by name
	 */
	findClassByName: function(name)
	{
		return this.items.findItem((item) =>
		{
			if (!(item instanceof BayLang.OpCodes.OpDeclareClass))
			{
				return false;
			}
			if (item.name == name)
			{
				return false;
			}
			return true;
		});
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.uses = null;
		this.items = null;
		this.is_component = false;
	},
});
Object.assign(BayLang.OpCodes.OpModule, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpModule,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpModule";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpModule);
window["BayLang.OpCodes.OpModule"] = BayLang.OpCodes.OpModule;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpModule;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpNamespace = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpNamespace.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpNamespace.prototype.constructor = BayLang.OpCodes.OpNamespace;
Object.assign(BayLang.OpCodes.OpNamespace.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "name", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_namespace";
		this.name = "";
	},
});
Object.assign(BayLang.OpCodes.OpNamespace, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpNamespace,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpNamespace";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpNamespace);
window["BayLang.OpCodes.OpNamespace"] = BayLang.OpCodes.OpNamespace;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpNamespace;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpNegative = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpNegative.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpNegative.prototype.constructor = BayLang.OpCodes.OpNegative;
Object.assign(BayLang.OpCodes.OpNegative.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_negative";
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpNegative, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpNegative,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpNegative";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpNegative);
window["BayLang.OpCodes.OpNegative"] = BayLang.OpCodes.OpNegative;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpNegative;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpNew = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpNew.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpNew.prototype.constructor = BayLang.OpCodes.OpNew;
Object.assign(BayLang.OpCodes.OpNew.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "args", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_new";
		this.args = null;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpNew, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpNew,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpNew";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpNew);
window["BayLang.OpCodes.OpNew"] = BayLang.OpCodes.OpNew;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpNew;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpNumber = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpNumber.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpNumber.prototype.constructor = BayLang.OpCodes.OpNumber;
Object.assign(BayLang.OpCodes.OpNumber.prototype,
{
	/*bool negative = false;*/
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_number";
		this.value = 0;
	},
});
Object.assign(BayLang.OpCodes.OpNumber, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpNumber,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpNumber";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpNumber);
window["BayLang.OpCodes.OpNumber"] = BayLang.OpCodes.OpNumber;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpNumber;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpPipe = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpPipe.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpPipe.prototype.constructor = BayLang.OpCodes.OpPipe;
Object.assign(BayLang.OpCodes.OpPipe.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "is_async", data);
		serializer.process(this, "is_monad", data);
		serializer.process(this, "kind", data);
		serializer.process(this, "obj", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_pipe";
		this.kind = "";
		this.obj = null;
		this.value = null;
		this.is_async = false;
		this.is_monad = false;
	},
});
Object.assign(BayLang.OpCodes.OpPipe, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpPipe,
{
	KIND_ATTR: "attr",
	KIND_CALL: "call",
	KIND_METHOD: "method",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpPipe";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpPipe);
window["BayLang.OpCodes.OpPipe"] = BayLang.OpCodes.OpPipe;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpPipe;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpPreprocessorIfCode = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpPreprocessorIfCode.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpPreprocessorIfCode.prototype.constructor = BayLang.OpCodes.OpPreprocessorIfCode;
Object.assign(BayLang.OpCodes.OpPreprocessorIfCode.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "content", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_preprocessor_ifcode";
		this.condition = null;
		this.content = null;
	},
});
Object.assign(BayLang.OpCodes.OpPreprocessorIfCode, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpPreprocessorIfCode,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpPreprocessorIfCode";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpPreprocessorIfCode);
window["BayLang.OpCodes.OpPreprocessorIfCode"] = BayLang.OpCodes.OpPreprocessorIfCode;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpPreprocessorIfCode;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpPreprocessorIfDef = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpPreprocessorIfDef.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpPreprocessorIfDef.prototype.constructor = BayLang.OpCodes.OpPreprocessorIfDef;
Object.assign(BayLang.OpCodes.OpPreprocessorIfDef.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "items", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_preprocessor_ifdef";
		this.condition = null;
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpPreprocessorIfDef, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpPreprocessorIfDef,
{
	KIND_PROGRAM: "program",
	KIND_CLASS_BODY: "class_body",
	KIND_OPERATOR: "operator",
	KIND_EXPRESSION: "expression",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpPreprocessorIfDef";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpPreprocessorIfDef);
window["BayLang.OpCodes.OpPreprocessorIfDef"] = BayLang.OpCodes.OpPreprocessorIfDef;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpPreprocessorIfDef;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpPreprocessorSwitch = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpPreprocessorSwitch.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpPreprocessorSwitch.prototype.constructor = BayLang.OpCodes.OpPreprocessorSwitch;
Object.assign(BayLang.OpCodes.OpPreprocessorSwitch.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_preprocessor_switch";
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpPreprocessorSwitch, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpPreprocessorSwitch,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpPreprocessorSwitch";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpPreprocessorSwitch);
window["BayLang.OpCodes.OpPreprocessorSwitch"] = BayLang.OpCodes.OpPreprocessorSwitch;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpPreprocessorSwitch;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpReturn = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpReturn.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpReturn.prototype.constructor = BayLang.OpCodes.OpReturn;
Object.assign(BayLang.OpCodes.OpReturn.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "expression", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_return";
		this.expression = null;
	},
});
Object.assign(BayLang.OpCodes.OpReturn, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpReturn,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpReturn";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpReturn);
window["BayLang.OpCodes.OpReturn"] = BayLang.OpCodes.OpReturn;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpReturn;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpSafe = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpSafe.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpSafe.prototype.constructor = BayLang.OpCodes.OpSafe;
Object.assign(BayLang.OpCodes.OpSafe.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
		serializer.process(this, "obj", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_safe";
		this.obj = null;
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpSafe, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpSafe,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpSafe";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpSafe);
window["BayLang.OpCodes.OpSafe"] = BayLang.OpCodes.OpSafe;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpSafe;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpString = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpString.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpString.prototype.constructor = BayLang.OpCodes.OpString;
Object.assign(BayLang.OpCodes.OpString.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_string";
		this.value = "";
	},
});
Object.assign(BayLang.OpCodes.OpString, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpString,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpString";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpString);
window["BayLang.OpCodes.OpString"] = BayLang.OpCodes.OpString;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpString;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpTernary = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpTernary.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpTernary.prototype.constructor = BayLang.OpCodes.OpTernary;
Object.assign(BayLang.OpCodes.OpTernary.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "if_false", data);
		serializer.process(this, "if_true", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_ternary";
		this.condition = null;
		this.if_true = null;
		this.if_false = null;
	},
});
Object.assign(BayLang.OpCodes.OpTernary, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpTernary,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpTernary";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpTernary);
window["BayLang.OpCodes.OpTernary"] = BayLang.OpCodes.OpTernary;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpTernary;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpThrow = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpThrow.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpThrow.prototype.constructor = BayLang.OpCodes.OpThrow;
Object.assign(BayLang.OpCodes.OpThrow.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "expression", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_throw";
		this.expression = null;
	},
});
Object.assign(BayLang.OpCodes.OpThrow, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpThrow,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpThrow";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpThrow);
window["BayLang.OpCodes.OpThrow"] = BayLang.OpCodes.OpThrow;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpThrow;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpTryCatch = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpTryCatch.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpTryCatch.prototype.constructor = BayLang.OpCodes.OpTryCatch;
Object.assign(BayLang.OpCodes.OpTryCatch.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
		serializer.process(this, "op_try", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_try_catch";
		this.op_try = null;
		this.items = null;
	},
});
Object.assign(BayLang.OpCodes.OpTryCatch, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpTryCatch,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpTryCatch";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpTryCatch);
window["BayLang.OpCodes.OpTryCatch"] = BayLang.OpCodes.OpTryCatch;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpTryCatch;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpTryCatchItem = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpTryCatchItem.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpTryCatchItem.prototype.constructor = BayLang.OpCodes.OpTryCatchItem;
Object.assign(BayLang.OpCodes.OpTryCatchItem.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "name", data);
		serializer.process(this, "pattern", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_try_catch_item";
		this.name = "";
		this.pattern = null;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpTryCatchItem, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpTryCatchItem,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpTryCatchItem";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpTryCatchItem);
window["BayLang.OpCodes.OpTryCatchItem"] = BayLang.OpCodes.OpTryCatchItem;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpTryCatchItem;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpTypeConvert = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpTypeConvert.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpTypeConvert.prototype.constructor = BayLang.OpCodes.OpTypeConvert;
Object.assign(BayLang.OpCodes.OpTypeConvert.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "pattern", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_type_convert";
		this.pattern = null;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpTypeConvert, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpTypeConvert,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpTypeConvert";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpTypeConvert);
window["BayLang.OpCodes.OpTypeConvert"] = BayLang.OpCodes.OpTypeConvert;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpTypeConvert;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpTypeIdentifier = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpTypeIdentifier.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpTypeIdentifier.prototype.constructor = BayLang.OpCodes.OpTypeIdentifier;
Object.assign(BayLang.OpCodes.OpTypeIdentifier.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "entity_name", data);
		serializer.process(this, "template", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_type_identifier";
		this.entity_name = null;
		this.template = null;
	},
});
Object.assign(BayLang.OpCodes.OpTypeIdentifier, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpTypeIdentifier,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpTypeIdentifier";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpTypeIdentifier);
window["BayLang.OpCodes.OpTypeIdentifier"] = BayLang.OpCodes.OpTypeIdentifier;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpTypeIdentifier;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpUse = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpUse.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpUse.prototype.constructor = BayLang.OpCodes.OpUse;
Object.assign(BayLang.OpCodes.OpUse.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "alias", data);
		serializer.process(this, "name", data);
		serializer.process(this, "is_component", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_use";
		this.alias = "";
		this.name = "";
		this.is_component = false;
	},
});
Object.assign(BayLang.OpCodes.OpUse, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpUse,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpUse";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpUse);
window["BayLang.OpCodes.OpUse"] = BayLang.OpCodes.OpUse;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpUse;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpWhile = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpWhile.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpWhile.prototype.constructor = BayLang.OpCodes.OpWhile;
Object.assign(BayLang.OpCodes.OpWhile.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "condition", data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_while";
		this.condition = null;
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpWhile, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpWhile,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpWhile";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpWhile);
window["BayLang.OpCodes.OpWhile"] = BayLang.OpCodes.OpWhile;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpWhile;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpWidget = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpWidget.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpWidget.prototype.constructor = BayLang.OpCodes.OpWidget;
Object.assign(BayLang.OpCodes.OpWidget.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "items", data);
		serializer.process(this, "settings", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_widget";
		this.items = null;
		this.settings = null;
	},
});
Object.assign(BayLang.OpCodes.OpWidget, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpWidget,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpWidget";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpWidget);
window["BayLang.OpCodes.OpWidget"] = BayLang.OpCodes.OpWidget;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpWidget;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.OpCodes == 'undefined') BayLang.OpCodes = {};
BayLang.OpCodes.OpWidgetData = function()
{
	BayLang.OpCodes.BaseOpCode.apply(this, arguments);
};
BayLang.OpCodes.OpWidgetData.prototype = Object.create(BayLang.OpCodes.BaseOpCode.prototype);
BayLang.OpCodes.OpWidgetData.prototype.constructor = BayLang.OpCodes.OpWidgetData;
Object.assign(BayLang.OpCodes.OpWidgetData.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		BayLang.OpCodes.BaseOpCode.prototype.serialize.call(this, serializer, data);
		serializer.process(this, "value", data);
	},
	_init: function()
	{
		BayLang.OpCodes.BaseOpCode.prototype._init.call(this);
		this.op = "op_widget_data";
		this.value = null;
	},
});
Object.assign(BayLang.OpCodes.OpWidgetData, BayLang.OpCodes.BaseOpCode);
Object.assign(BayLang.OpCodes.OpWidgetData,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.OpCodes";
	},
	getClassName: function()
	{
		return "BayLang.OpCodes.OpWidgetData";
	},
	getParentClassName: function()
	{
		return "BayLang.OpCodes.BaseOpCode";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.OpCodes.OpWidgetData);
window["BayLang.OpCodes.OpWidgetData"] = BayLang.OpCodes.OpWidgetData;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.OpCodes.OpWidgetData;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangNode == 'undefined') BayLang.LangNode = {};
BayLang.LangNode.TranslatorNode = function()
{
	BayLang.LangES6.TranslatorES6.apply(this, arguments);
};
BayLang.LangNode.TranslatorNode.prototype = Object.create(BayLang.LangES6.TranslatorES6.prototype);
BayLang.LangNode.TranslatorNode.prototype.constructor = BayLang.LangNode.TranslatorNode;
Object.assign(BayLang.LangNode.TranslatorNode.prototype,
{
	_init: function()
	{
		BayLang.LangES6.TranslatorES6.prototype._init.call(this);
		this.async_await = null;
		this.expression = null;
		this.html = null;
		this.operator = null;
		this.program = null;
		this.use_module_name = true;
		this.enable_async_await = true;
		this.emulate_async_await = false;
		this.enable_introspection = false;
		this.enable_context = true;
	},
	takeValue: function(k,d)
	{
		if (d == undefined) d = null;
		if (k == "async_await")return this.async_await;
		else if (k == "expression")return this.expression;
		else if (k == "html")return this.html;
		else if (k == "operator")return this.operator;
		else if (k == "program")return this.program;
		else if (k == "use_module_name")return this.use_module_name;
		else if (k == "enable_async_await")return this.enable_async_await;
		else if (k == "emulate_async_await")return this.emulate_async_await;
		else if (k == "enable_introspection")return this.enable_introspection;
		else if (k == "enable_context")return this.enable_context;
		return BayLang.LangES6.TranslatorES6.prototype.takeValue.call(this,k,d);
	},
});
Object.assign(BayLang.LangNode.TranslatorNode, BayLang.LangES6.TranslatorES6);
Object.assign(BayLang.LangNode.TranslatorNode,
{
	/**
	 * Reset translator
	 */
	reset: function(t)
	{
		t = BayLang.LangES6.TranslatorES6.reset.bind(this)(t);
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["expression"]), new BayLang.LangNode.TranslatorNodeExpression());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["program"]), new BayLang.LangNode.TranslatorNodeProgram());
		t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["preprocessor_flags"]), t.preprocessor_flags.concat(Runtime.Map.from({"BACKEND":true,"NODEJS":true,"ES6":false})));
		return t;
	},
	/**
	 * Translate BaseOpCode
	 */
	translate: function(t, op_code)
	{
		return t.program.constructor.translateProgram(t, op_code);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangNode";
	},
	getClassName: function()
	{
		return "BayLang.LangNode.TranslatorNode";
	},
	getParentClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		a.push("async_await");
		a.push("expression");
		a.push("html");
		a.push("operator");
		a.push("program");
		a.push("use_module_name");
		a.push("enable_async_await");
		a.push("emulate_async_await");
		a.push("enable_introspection");
		a.push("enable_context");
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangNode.TranslatorNode);
window["BayLang.LangNode.TranslatorNode"] = BayLang.LangNode.TranslatorNode;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangNode.TranslatorNode;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangNode == 'undefined') BayLang.LangNode = {};
BayLang.LangNode.TranslatorNodeExpression = function()
{
	BayLang.LangES6.TranslatorES6Expression.apply(this, arguments);
};
BayLang.LangNode.TranslatorNodeExpression.prototype = Object.create(BayLang.LangES6.TranslatorES6Expression.prototype);
BayLang.LangNode.TranslatorNodeExpression.prototype.constructor = BayLang.LangNode.TranslatorNodeExpression;
Object.assign(BayLang.LangNode.TranslatorNodeExpression.prototype,
{
});
Object.assign(BayLang.LangNode.TranslatorNodeExpression, BayLang.LangES6.TranslatorES6Expression);
Object.assign(BayLang.LangNode.TranslatorNodeExpression,
{
	/**
	 * OpIdentifier
	 */
	OpIdentifier: function(t, op_code)
	{
		if (op_code.value == "@")
		{
			return Runtime.Vector.from([t,"ctx"]);
		}
		if (op_code.value == "_")
		{
			return Runtime.Vector.from([t,"ctx.constructor.translate"]);
		}
		if (op_code.value == "log")
		{
			return Runtime.Vector.from([t,"console.log"]);
		}
		if (t.modules.has(op_code.value) || op_code.kind == BayLang.OpCodes.OpIdentifier.KIND_SYS_TYPE)
		{
			var module_name = op_code.value;
			var new_module_name = this.findModuleName(t, module_name);
			if (module_name != new_module_name)
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"op_code":op_code,"var_content":this.useModuleName(t, module_name)}));
				t = Runtime.rtl.attr(res, 0);
				var var_name = Runtime.rtl.attr(res, 1);
				return Runtime.Vector.from([t,var_name]);
			}
		}
		return Runtime.Vector.from([t,op_code.value]);
	},
	/**
	 * OpTypeIdentifier
	 */
	OpTypeIdentifier: function(t, op_code)
	{
		var var_name = "";
		if (op_code.entity_name.names.count() > 0)
		{
			var module_name = op_code.entity_name.names.first();
			var new_module_name = this.findModuleName(t, module_name);
			if (module_name != new_module_name)
			{
				var res = t.constructor.addSaveOpCode(t, Runtime.Map.from({"var_content":this.useModuleName(t, module_name)}));
				t = Runtime.rtl.attr(res, 0);
				var_name = Runtime.rtl.attr(res, 1);
			}
		}
		if (var_name == "")
		{
			var_name = Runtime.rs.join(".", op_code.entity_name.names);
		}
		return Runtime.Vector.from([t,var_name]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangNode";
	},
	getClassName: function()
	{
		return "BayLang.LangNode.TranslatorNodeExpression";
	},
	getParentClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Expression";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangNode.TranslatorNodeExpression);
window["BayLang.LangNode.TranslatorNodeExpression"] = BayLang.LangNode.TranslatorNodeExpression;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangNode.TranslatorNodeExpression;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.LangNode == 'undefined') BayLang.LangNode = {};
BayLang.LangNode.TranslatorNodeProgram = function()
{
	BayLang.LangES6.TranslatorES6Program.apply(this, arguments);
};
BayLang.LangNode.TranslatorNodeProgram.prototype = Object.create(BayLang.LangES6.TranslatorES6Program.prototype);
BayLang.LangNode.TranslatorNodeProgram.prototype.constructor = BayLang.LangNode.TranslatorNodeProgram;
Object.assign(BayLang.LangNode.TranslatorNodeProgram.prototype,
{
});
Object.assign(BayLang.LangNode.TranslatorNodeProgram, BayLang.LangES6.TranslatorES6Program);
Object.assign(BayLang.LangNode.TranslatorNodeProgram,
{
	/**
	 * Translate program
	 */
	translateProgramHeader: function(t, op_code)
	{
		var content = "\"use strict;\"";
		content += Runtime.rtl.toStr(t.s("var use = require('bay-lang').use;"));
		return Runtime.Vector.from([t,content]);
	},
	/**
	 * OpDeclareClassFooter
	 */
	OpDeclareClassFooter: function(t, op_code)
	{
		var content = "";
		var name = "";
		content += Runtime.rtl.toStr("use.add(" + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(");"));
		/*
		content ~= t.s("if (module.exports == undefined) module.exports = {};");
		Collection<string> arr = rs::split(".", t.current_namespace_name);
		for (int i=0; i<arr.count(); i++)
		{
			name = name ~ ((i == 0) ? "" : ".") ~ arr.item(i);
			string s = "if (module.exports." ~ name ~ " == undefined) module.exports." ~ name ~ " = {};";
			content ~= (content == 0) ? s : t.s(s);
		}
		
		content ~= t.s("module.exports." ~
			t.current_class_full_name ~ " = " ~ t.current_class_full_name ~ ";");
		*/
		content += Runtime.rtl.toStr(t.s("module.exports = " + Runtime.rtl.toStr(t.current_class_full_name) + Runtime.rtl.toStr(";")));
		return Runtime.Vector.from([t,content]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.LangNode";
	},
	getClassName: function()
	{
		return "BayLang.LangNode.TranslatorNodeProgram";
	},
	getParentClassName: function()
	{
		return "BayLang.LangES6.TranslatorES6Program";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.LangNode.TranslatorNodeProgram);
window["BayLang.LangNode.TranslatorNodeProgram"] = BayLang.LangNode.TranslatorNodeProgram;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.LangNode.TranslatorNodeProgram;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
BayLang.ModuleDescription = function()
{
};
Object.assign(BayLang.ModuleDescription.prototype,
{
});
Object.assign(BayLang.ModuleDescription,
{
	/**
	 * Returns module name
	 * @return string
	 */
	getModuleName: function()
	{
		return "BayLang";
	},
	/**
	 * Returns module name
	 * @return string
	 */
	getModuleVersion: function()
	{
		return "0.12.3";
	},
	/**
	 * Returns required modules
	 * @return Map<string>
	 */
	requiredModules: function()
	{
		return Runtime.Map.from({"Runtime":">=0.11 <1.0"});
	},
	/**
	 * Returns enities
	 */
	entities: function()
	{
		return null;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang";
	},
	getClassName: function()
	{
		return "BayLang.ModuleDescription";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.ModuleDescription);
window["BayLang.ModuleDescription"] = BayLang.ModuleDescription;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.ModuleDescription;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Code == 'undefined') BayLang.Constructor.Frontend.Code = {};
BayLang.Constructor.Frontend.Code.CodeEditor = {
	name: "BayLang.Constructor.Frontend.Code.CodeEditor",
	extends: Runtime.Web.Component,
	methods:
	{
		renderMenu: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["code_editor__menu"])});
			
			/* Element 'a' */
			let __v1 = this._e(__v0, "a", {"href":((this.layout.route.data) ? (this.layout.route.data.get("back_url")) : (this.layout.url("baylang:project:modules", Runtime.Map.from({"project_id":this.model.project_id})))),"class":this._class_name(["code_editor__menu_item nolink"])});
			
			/* Text */
			this._t(__v1, "Back");
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"onClick":() =>
			{
				this.model.save();
			},"class":this._class_name(["code_editor__menu_item"])});
			
			/* Text */
			this._t(__v2, "Save");
			
			/* Element 'div' */
			let __v3 = this._e(__v0, "div", {"class":this._class_name(["code_editor_menu_item code_editor_menu_item_file_name"])});
			
			if (this.model.selected_tab)
			{
				/* Render */
				this._t(__v3, this.model.selected_tab.file_path);
			}
			
			return this._flatten(__v);
		},
		renderTabs: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"ref":"tabs","onMousewheel":(e) =>
			{
				var tabs = this.getRef("tabs");
				tabs.scrollLeft = tabs.scrollLeft + e.deltaY;
				e.preventDefault();
				e.stopPropagation();
			},"class":this._class_name(["code_editor__tabs"])});
			
			for (let i = 0; i < this.model.tabs.count(); i++)
			{
				let item = this.model.tabs.get(i);
				
				/* Element 'div' */
				let __v1 = this._e(__v0, "div", {"onMousedown":(e) =>
				{
					if (e.button == 1)
					{
						this.model.removeTab(item);
					}
				},"onClick":(e) =>
				{
					this.model.selectTab(item);
				},"class":this._class_name(["code_editor__tab", ((item == this.model.selected_tab) ? ("selected") : (""))]),"key":item.file_path});
				
				/* Element 'div' */
				let __v2 = this._e(__v1, "div", {"class":this._class_name(["code_editor__label"])});
				
				/* Render */
				this._t(__v2, item.label);
				
				/* Element 'div' */
				let __v3 = this._e(__v1, "div", {"onClick":(e) =>
				{
					this.model.removeTab(item);
					e.preventDefault();
					e.stopPropagation();
				},"class":this._class_name(["code_editor__icon"])});
				
				/* Element 'span' */
				let __v4 = this._e(__v3, "span", {});
				
				/* Raw */
				this._t(__v4, new Runtime.RawString("&#10005;"));
			}
			
			return this._flatten(__v);
		},
		renderStatusBar: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["code_editor__status_bar"])});
			
			/* Render */
			this._t(__v0, this.model.save_result.message);
			
			return this._flatten(__v);
		},
		renderFileEditor: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["code_editor__file_edit"])});
			
			for (let i = 0; i < this.model.tabs.count(); i++)
			{
				let item = this.model.tabs.get(i);
				
				/* Element 'div' */
				let __v1 = this._e(__v0, "div", {"class":this._class_name(["code_editor__file", ((item == this.model.selected_tab) ? ("") : ("hide"))]),"key":item.file_path});
				
				/* Component 'TextEditable' */
				let __v2 = this._c(__v1, "BayLang.Constructor.Frontend.Code.TextEditable", {"value":item.content,"reference":item.code_editor,"onValueChange":(e) =>
				{
					item.content = e.value;
				},"class":this._class_name(["wrap"])});
			}
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["code_editor"])});
			
			/* Render */
			this._t(__v0, this.renderMenu());
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["code_editor__main"])});
			
			/* Element 'div' */
			let __v2 = this._e(__v1, "div", {"class":this._class_name(["code_editor__file_manager"])});
			
			/* Render */
			this._t(__v2, this.renderWidget(this.model.tree));
			
			/* Element 'div' */
			let __v3 = this._e(__v1, "div", {"class":this._class_name(["code_editor__content"])});
			
			/* Render */
			this._t(__v3, this.renderTabs());
			
			/* Render */
			this._t(__v3, this.renderFileEditor());
			
			/* Render */
			this._t(__v3, this.renderStatusBar());
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.confirm_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.prompt_dialog));
			
			return this._flatten(__v);
		},
		/**
 * Mounted
 */
		onMounted: function()
		{
			document.addEventListener("keydown", this.onKeyDown);
		},
		/**
 * Key down
 */
		onKeyDown: function(e)
		{
			if (e.key == "s" && e.ctrlKey)
			{
				this.model.save();
				e.preventDefault();
			}
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Code.CodeEditor,
{
	components: function()
	{
		return Runtime.Vector.from(["BayLang.Constructor.Frontend.Code.TextEditable"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".code_editor.h-fd5f{display: flex;position: relative;flex-direction: column;overflow-y: hidden;height: 100vh}.code_editor__menu.h-fd5f{display: flex;border-bottom: 1px var(--widget-color-border) solid}.code_editor__menu_item.h-fd5f{cursor: pointer;user-select: none;padding: 10px}.code_editor_menu_item_file_name.h-fd5f{display: flex;align-items: center;justify-content: center;flex: 1}.code_editor__main.h-fd5f{display: flex;height: calc(100% - 37px)}.code_editor__file_manager.h-fd5f{position: relative;border-right: 1px var(--widget-color-border) solid;overflow-x: auto;padding-left: 5px;width: 300px;overflow-x: auto;padding-left: 5px}.code_editor__content.h-fd5f{display: flex;flex-direction: column;height: 100%;width: calc(100% - 300px)}.code_editor__tabs.h-fd5f{display: flex;height: 32px;border-bottom: 1px var(--widget-color-border) solid;overflow-x: auto;scrollbar-width: none}.code_editor__tab.h-fd5f{display: flex;border-right: 1px var(--widget-color-border) solid;padding: 5px;cursor: pointer;user-select: none}.code_editor__tab.selected.h-fd5f{background-color: var(--widget-color-primary);color: var(--widget-color-primary-text)}.code_editor__label.h-fd5f{display: flex;align-items: center;padding-left: 5px;flex: 1}.code_editor__icon.h-fd5f{display: flex;align-items: center;justify-content: center;padding-top: 3px;width: 24px}.code_editor__icon.h-fd5f span{padding: 1px}.code_editor__icon.h-fd5f:hover span{background-color: #f0f0f0}.code_editor__tab.selected.h-fd5f .code_editor__icon:hover span{background-color: var(--widget-color-primary)}.code_editor__file_edit.h-fd5f{position: relative;height: calc(100% - 56px)}.code_editor__file.h-fd5f{overflow-y: auto;height: 100%}.code_editor__file.h-fd5f .widget_text_editable.h-6975{border-width: 0px;padding: 5px}.code_editor__file.hide.h-fd5f{display: none}.code_editor__status_bar.h-fd5f{display: flex;align-items: center;padding: 2px;padding-left: 5px;border-top: 1px var(--widget-color-border) solid;height: 24px}");
		res += Runtime.rtl.toStr(".code_editor__tabs.h-fd5f::-webkit-scrollbar{width: 0}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Code";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Code.CodeEditor";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Code.CodeEditor);
window["BayLang.Constructor.Frontend.Code.CodeEditor"] = BayLang.Constructor.Frontend.Code.CodeEditor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Code.CodeEditor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Code == 'undefined') BayLang.Constructor.Frontend.Code = {};
BayLang.Constructor.Frontend.Code.CodeEditorModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Code.CodeEditorModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Code.CodeEditorModel.prototype.constructor = BayLang.Constructor.Frontend.Code.CodeEditorModel;
Object.assign(BayLang.Constructor.Frontend.Code.CodeEditorModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Setup settings */
		this.project_id = this.layout.route.matches.get("project_id");
		/* Save result */
		this.save_result = this.addWidget("Runtime.Widget.WidgetResultModel", Runtime.Map.from({"widget_name":"save_result"}));
		/* Confirm dialog */
		this.confirm_dialog = this.addWidget("Runtime.Widget.Dialog.ConfirmDialogModel", Runtime.Map.from({"widget_name":"confirm_dialog","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onDialogConfirm")})}));
		/* Prompt dialog */
		this.prompt_dialog = this.addWidget("Runtime.Widget.Dialog.PromptDialogModel", Runtime.Map.from({"widget_name":"prompt_dialog","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onDialogConfirm")})}));
		/* Create Tree */
		this.tree = this.addWidget("Runtime.Widget.Tree.TreeModel", Runtime.Map.from({"component":"BayLang.Constructor.Frontend.Code.TreeWidget","dnd":false,"icons":true,"events":Runtime.Map.from({"selectItem":new Runtime.Callback(this, "onTreeSelectItem"),"contextMenu":new Runtime.Callback(this, "onTreeContextMenu")}),"context_menu":Runtime.Map.from({"items":Runtime.Vector.from([Runtime.Map.from({"label":"Create file","key":"create_file"}),Runtime.Map.from({"label":"Create folder","key":"create_folder"}),Runtime.Map.from({"label":"Rename","key":"rename"}),Runtime.Map.from({"label":"Cut","key":"cut"}),Runtime.Map.from({"label":"Copy","key":"copy"}),Runtime.Map.from({"label":"Paste","key":"paste"}),Runtime.Map.from({"label":"Delete","key":"delete"})]),"events":Runtime.Map.from({"clickItem":new Runtime.Callback(this, "onContextMenuItemClick")})})}));
		this.tree.root = new BayLang.Constructor.Frontend.Code.TreeItem(Runtime.Map.from({"project_id":this.project_id,"open":true}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Code editor");
	},
	/**
	 * Load data
	 */
	loadData: async function(container)
	{
		await Runtime.Web.BasePageModel.prototype.loadData.call(this, container);
		/* Load root */
		await this.loadItems(this.tree.root);
	},
	/**
	 * Remove tab
	 */
	selectTab: function(item)
	{
		this.selected_tab = item;
	},
	/**
	 * Add tab
	 */
	addTab: function(item)
	{
		this.tabs.push(this.selected_item);
	},
	/**
	 * Remove tab
	 */
	removeTab: function(item)
	{
		this.tabs.removeItem(item);
		this.save_result.clear();
		if (this.selected_tab == item)
		{
			this.selected_tab = null;
		}
	},
	/**
	 * Tree context menu
	 */
	onTreeContextMenu: function(message)
	{
		var item = message.item;
		this.tree.context_menu.items.each((params) =>
		{
			var key = params.get("key");
			/* Copy */
			if (key == "copy" || key == "cut" || key == "rename" || key == "delete")
			{
				if (item == null)
				{
					params.set("hidden", true);
				}
				else
				{
					params.set("hidden", false);
				}
			}
			/* Paste */
			if (key == "paste")
			{
				if (this.copy_past_path == "" || item != null && Runtime.rs.dirname(this.copy_past_path) == item.file_path || item == null && Runtime.rs.dirname(this.copy_past_path) == "")
				{
					params.set("hidden", true);
				}
				else
				{
					params.set("hidden", false);
				}
			}
		});
	},
	/**
	 * Context menu item click
	 */
	onContextMenuItemClick: async function(message)
	{
		var item_key = message.item.get("key");
		/* Hide context menu */
		message.widget.hide();
		/* Create file */
		if (item_key == "create_file")
		{
			var confirm_button = this.prompt_dialog.buttons.getWidget("confirm_button");
			confirm_button.content = "Create";
			this.prompt_dialog.action = "create_file";
			this.prompt_dialog.title = "Create file";
			this.prompt_dialog.value = "";
			this.prompt_dialog.show();
		}
		else if (item_key == "create_folder")
		{
			var confirm_button = this.prompt_dialog.buttons.getWidget("confirm_button");
			confirm_button.content = "Create";
			this.prompt_dialog.action = "create_folder";
			this.prompt_dialog.title = "Create folder";
			this.prompt_dialog.value = "";
			this.prompt_dialog.show();
		}
		else if (item_key == "rename")
		{
			var confirm_button = this.prompt_dialog.buttons.getWidget("confirm_button");
			confirm_button.content = "Rename";
			this.prompt_dialog.action = "rename";
			this.prompt_dialog.title = "Rename item " + Runtime.rtl.toStr(this.selected_item.label);
			this.prompt_dialog.value = this.selected_item.label;
			this.prompt_dialog.show();
		}
		else if (item_key == "remove" || item_key == "delete")
		{
			var confirm_button = this.confirm_dialog.buttons.getWidget("confirm_button");
			confirm_button.content = "Remove";
			confirm_button.styles = Runtime.Vector.from(["danger"]);
			this.confirm_dialog.action = "remove";
			this.confirm_dialog.title = "Remove item " + Runtime.rtl.toStr(this.selected_item.label);
			this.confirm_dialog.show();
		}
		else if (item_key == "copy" || item_key == "cut")
		{
			this.copy_past_path = this.selected_item.file_path;
			this.copy_past_kind = item_key;
		}
		else if (item_key == "paste")
		{
			if (this.copy_past_path == "")
			{
				return Promise.resolve();
			}
			var parent_path = (this.selected_path) ? (this.selected_path.slice()) : (Runtime.Vector.from([]));
			var parent_item = this.tree.root.get(parent_path);
			/* Paste item */
			var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"move","data":Runtime.Map.from({"project_id":this.project_id,"file_path":this.copy_past_path,"dest_path":parent_item.file_path,"kind":(this.copy_past_kind == "copy") ? ("copy") : ("")})}));
			/* Success */
			if (res.isSuccess())
			{
				/* Clear path */
				this.copy_past_path = "";
				/* Reload items */
				parent_item.is_loaded = false;
				await this.loadItems(parent_item);
			}
		}
	},
	/**
	 * Confirm dialog
	 */
	onDialogConfirm: async function(message)
	{
		/* Create file */
		if (message.widget.action == "create_file" || message.widget.action == "create_folder")
		{
			var parent_path = (this.selected_path) ? (this.selected_path.slice()) : (Runtime.Vector.from([]));
			var parent_item = this.tree.root.get(parent_path);
			/* Create item */
			var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"create","data":Runtime.Map.from({"project_id":this.project_id,"file_path":(this.selected_item) ? (this.selected_item.file_path) : (""),"file_name":message.value,"kind":(message.widget.action == "create_file") ? ("file") : ("folder")})}));
			/* Reload items */
			if (res.isSuccess())
			{
				parent_item.is_loaded = false;
				await this.loadItems(parent_item);
			}
		}
		else if (message.widget.action == "rename")
		{
			var parent_path = this.selected_path.slice(0, -1);
			var parent_item = this.tree.root.get(parent_path);
			this.selected_item.label = message.value;
			/* Rename item */
			var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"rename","data":Runtime.Map.from({"project_id":this.project_id,"file_path":this.selected_item.file_path,"file_new_name":message.value})}));
			/* Reload items */
			if (res.isSuccess())
			{
				parent_item.is_loaded = false;
				await this.loadItems(parent_item);
			}
		}
		else if (message.widget.action == "remove")
		{
			var parent_path = this.selected_path.slice(0, -1);
			var parent_item = this.tree.root.get(parent_path);
			/* Rename item */
			var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"remove","data":Runtime.Map.from({"project_id":this.project_id,"file_path":this.selected_item.file_path})}));
			/* Reload items */
			if (res.isSuccess())
			{
				parent_item.is_loaded = false;
				await this.loadItems(parent_item);
			}
		}
	},
	/**
	 * Select item
	 */
	onTreeSelectItem: async function(message)
	{
		this.selected_item = message.item;
		this.selected_path = (message.path) ? (message.path.slice()) : (null);
		if (!this.selected_item)
		{
			return Promise.resolve();
		}
		if (message.kind != "click")
		{
			return Promise.resolve();
		}
		if (this.selected_item.kind == "dir")
		{
			await this.loadItems(this.selected_item);
		}
		else if (this.selected_item.kind == "file")
		{
			if (this.tabs.indexOf(this.selected_item) == -1)
			{
				this.addTab(this.selected_item);
				this.selectTab(this.selected_item);
				await this.loadFileContent(this.selected_item);
			}
			else
			{
				this.selectTab(this.selected_item);
			}
		}
	},
	/**
	 * Save file
	 */
	save: async function()
	{
		if (!this.selected_tab)
		{
			return Promise.resolve();
		}
		this.save_result.setWaitMessage();
		var content = this.selected_tab.code_editor.value().getValue();
		var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"saveContent","data":Runtime.Map.from({"project_id":this.project_id,"file_path":this.selected_tab.file_path,"content":content})}));
		this.save_result.setApiResult(res);
	},
	/**
	 * Load file content
	 */
	loadFileContent: async function(item)
	{
		/* Clear content */
		item.content = "";
		item.is_loaded = true;
		/* Send request */
		var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"getContent","data":Runtime.Map.from({"project_id":item.project_id,"module_id":item.module_id,"file_path":item.file_path})}));
		/* Check is response is success */
		if (!res.isSuccess())
		{
			return Promise.resolve();
		}
		/* Set file content */
		item.content = res.data.get("content");
	},
	/**
	 * Load items
	 */
	loadItems: async function(item)
	{
		if (item.isLoaded())
		{
			return Promise.resolve();
		}
		var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.code","method_name":"getFiles","data":Runtime.Map.from({"project_id":item.project_id,"module_id":item.module_id,"file_path":item.file_path})}));
		item.is_loaded = true;
		if (!res.isSuccess())
		{
			return Promise.resolve();
		}
		var items = res.data.get("items");
		/* Add items */
		for (var i = 0; i < items.count(); i++)
		{
			var file = items.get(i);
			var label = file.get("file_name");
			var pos = item.items.find(Runtime.lib.equalAttr("label", label));
			/* Change item */
			if (pos >= 0)
			{
				var find_item = item.items.get(pos);
				find_item.label = file.get("file_name");
				find_item.file_path = file.get("file_path");
			}
			else
			{
				item.items.push(new BayLang.Constructor.Frontend.Code.TreeItem(Runtime.Map.from({"kind":file.get("kind"),"label":file.get("file_name"),"file_path":file.get("file_path"),"module_id":item.module_id,"project_id":item.project_id})));
			}
		}
		/* Remove items */
		for (var i = item.items.count() - 1; i >= 0; i--)
		{
			var find_item = item.items.get(i);
			var pos = items.find(Runtime.lib.equalAttr("file_name", find_item.label));
			if (pos == -1)
			{
				item.items.remove(i);
			}
		}
		/* Sort items */
		item.items = item.items.sort((a, b) =>
		{
			if (a.kind == "dir" && b.kind == "file")
			{
				return -1;
			}
			if (a.kind == "file" && b.kind == "dir")
			{
				return 1;
			}
			return Runtime.rs.compare(a.label, b.label);
		});
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Code.CodeEditor";
		this.project_id = "";
		this.copy_past_kind = "";
		this.copy_past_path = "";
		this.confirm_dialog = null;
		this.prompt_dialog = null;
		this.tree = null;
		this.selected_item = null;
		this.selected_tab = null;
		this.selected_path = null;
		this.tabs = Runtime.Vector.from([]);
		this.save_result = null;
		this.context_menu = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Code.CodeEditorModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Code.CodeEditorModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Code";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Code.CodeEditorModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Code.CodeEditorModel);
window["BayLang.Constructor.Frontend.Code.CodeEditorModel"] = BayLang.Constructor.Frontend.Code.CodeEditorModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Code.CodeEditorModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Code == 'undefined') BayLang.Constructor.Frontend.Code = {};
BayLang.Constructor.Frontend.Code.TextEditable = {
	name: "BayLang.Constructor.Frontend.Code.TextEditable",
	extends: Runtime.Web.Component,
	props: {
		"reference": {
			default: null,
		},
		"readonly": {
			default: false,
		},
		"timeout": {
			default: 500,
		},
		"name": {
			default: "",
		},
		"value": {
			default: "",
		},
	},
	data: function ()
	{
		return {
			lines: Runtime.Vector.from([]),
			change_timer: null,
			old_value: null,
		};
	},
	methods:
	{
		render: function()
		{
			let __v = [];
			let props = this.getProps();
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_text"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_text__lines"])});
			
			for (let i = 0; i < this.lines.count(); i++)
			{
				/* Element 'div' */
				let __v2 = this._e(__v1, "div", {"style":"width: " + Runtime.rtl.toStr(this.lines.get(i)) + Runtime.rtl.toStr("px"),"class":this._class_name(["line"]),"key":i});
				
				/* Render */
				this._t(__v2, i + 1);
			}
			
			/* Element 'div' */
			let __v3 = this._e(__v0, "div", this._merge_attrs({"name":this.name,"contenteditable":"plaintext-only","onKeydown":this.onKeyDown,"onInput":this.onInput,"onPaste":this.onPaste,"ref":"text","class":this._class_name(["widget_text__editable", this.class])}, props));
			
			return this._flatten(__v);
		},
		/**
 * Returns value
 */
		getValue: function()
		{
			var nodes = this.getRef("text").childNodes;
			var content = Runtime.Vector.from([]);
			for (var i = 0; i < nodes.length; i++)
			{
				var item = nodes.item(i).innerText.trimRight();
				content.push(item);
			}
			return Runtime.rs.join("\n", content);
		},
		/**
 * Set value
 */
		setValue: function(content)
		{
			var text = this.getRef("text");
			this.old_value = content;
			/* Add lines */
			text.innerHTML = "";
			var lines = Runtime.rs.split("\n", content);
			for (var i = 0; i < lines.count(); i++)
			{
				var line_text = lines.get(i).trimRight();
				var line_elem = this.createNewLine(line_text);
				text.append(line_elem);
			}
			/* Update lines */
			this.updateLinesCount();
		},
		/**
 * Returns textarea props
 */
		getProps: function()
		{
			if (this.readonly)
			{
				return Runtime.Map.from({"readonly":true});
			}
			return Runtime.Map.from({});
		},
		/**
 * Returns new line
 */
		createNewLine: function(text)
		{
			if (text == undefined) text = "";
			var div = document.createElement("div");
			div.classList.add("line");
			div.innerText = text;
			return div;
		},
		/**
 * Returns line
 */
		findLine: function(node)
		{
			while (node && (node.nodeType == 3 || !node.classList.contains("line")))
			{
				node = node.parentElement;
			}
			return node;
		},
		/**
 * Returns line element
 */
		getLineElement: function(pos)
		{
			return this.getRef("text").childNodes.item(pos);
		},
		/**
 * Returns line element
 */
		getLinePosition: function(line)
		{
			var nodes = this.getRef("text").childNodes;
			for (var i = 0; i < nodes.length; i++)
			{
				if (nodes.item(i) == line)
				{
					return i;
				}
			}
			return -1;
		},
		/**
 * Returns node offset
 */
		getNodeOffset: function(line, node, offset)
		{
			var pos = 0;
			var is_line = line == node;
			var current = line.firstChild;
			while (current)
			{
				if (is_line && offset == 0)
				{
					break;
				}
				if (current.nodeType == 3)
				{
					if (is_line)
					{
						offset = offset - 1;
					}
					else
					{
						if (current == node)
						{
							return pos + offset;
						}
					}
					pos = pos + current.textContent.length;
				}
				current = current.nextSibling;
			}
			return pos;
		},
		/**
 * Returns selection
 */
		getSelection: function()
		{
			return this.getRef("text").ownerDocument.defaultView.getSelection();
		},
		/**
 * Returns cursor position
 */
		getCursorPos: function()
		{
			var selection = this.getSelection();
			var range = selection.getRangeAt(0);
			/* Get range start */
			var start_line = this.findLine(range.startContainer);
			var start_y = this.getLinePosition(start_line);
			var start_x = this.getNodeOffset(start_line, range.startContainer, range.startOffset);
			/* Get range end */
			var end_line = this.findLine(range.endContainer);
			var end_y = this.getLinePosition(end_line);
			var end_x = this.getNodeOffset(end_line, range.endContainer, range.endOffset);
			return Runtime.Map.from({"start_y":start_y,"start_x":start_x,"end_y":end_y,"end_x":end_x});
		},
		/**
 * Set cursor position
 */
		setCursorPos: function(x, y)
		{
			var selection = this.getSelection();
			var range = document.createRange();
			/* Get first node of line */
			var line_elem = this.getLineElement(y);
			var current = line_elem.firstChild;
			/* Find node contains x */
			var pos = 0;
			var offset = 0;
			while (current)
			{
				if (current.nodeType == 3)
				{
					var node_size = current.textContent.length;
					if (pos + node_size >= x)
					{
						offset = x - pos;
						break;
					}
					pos = pos + node_size;
				}
				current = current.nextSibling;
			}
			/* If node not found */
			if (current == null)
			{
				current = line_elem;
				offset = line_elem.childNodes.length;
			}
			/* Set cursor */
			range.setStart(current, offset);
			range.setEnd(current, offset);
			selection.removeAllRanges();
			selection.addRange(range);
			return range;
		},
		/**
 * Update lines count
 */
		updateLinesCount: function()
		{
			this.lines = Runtime.Vector.from([]);
			var nodes = this.getRef("text").childNodes;
			for (var i = 0; i < nodes.length; i++)
			{
				var item = nodes.item(i);
				this.lines.push(item.getBoundingClientRect().height);
			}
		},
		/**
 * Mounted event
 */
		onMounted: function()
		{
			if (this.reference)
			{
				this.reference.setValue(this);
			}
			this.setValue(this.value);
		},
		/**
 * Updated event
 */
		onUpdated: function()
		{
			if (this.old_value == this.value)
			{
				return ;
			}
			if (this.change_timer)
			{
				return ;
			}
			this.setValue(this.value);
		},
		/**
 * Paste text to current position
 */
		pasteText: function(text)
		{
			var cursor = this.getCursorPos();
			var line_pos = cursor.get("end_y");
			var line_offset = cursor.get("end_x");
			var line_offset_new = 0;
			var line_elem = this.getLineElement(line_pos);
			var line_text = line_elem.innerText;
			var lines = Runtime.rs.split("\n", text);
			if (lines.count() > 1)
			{
				/* Change first line */
				var first_line = lines.shift();
				line_elem.innerText = line_text.slice(0, line_offset) + Runtime.rtl.toStr(first_line);
				/* Change last line */
				var lines_last_pos = lines.count() - 1;
				lines.set(lines_last_pos, lines.get(lines_last_pos) + Runtime.rtl.toStr(line_text.slice(line_offset)));
			}
			else
			{
				var first_line = line_text.slice(0, line_offset) + Runtime.rtl.toStr(lines.pop());
				line_elem.innerText = first_line + Runtime.rtl.toStr(line_text.slice(line_offset));
				line_offset_new = Runtime.rs.strlen(first_line);
			}
			/* Insert lines after line_elem */
			var lines_count = lines.count();
			for (var i = 0; i < lines_count; i++)
			{
				var line_content = lines.get(i);
				var line_new = this.createNewLine(line_content);
				line_elem = line_elem.insertAdjacentElement("afterend", line_new);
				if (i == lines_count - 1)
				{
					line_offset_new = Runtime.rs.strlen(line_content);
				}
			}
			this.setCursorPos(line_offset_new, line_pos + lines.count());
			this.updateLinesCount();
		},
		/**
 * Key down event
 */
		onKeyDown: function(e)
		{
			if (e.key == "Enter")
			{
				e.preventDefault();
				e.stopPropagation();
				this.pasteText("\n");
			}
			else if (e.key == "Backspace")
			{
				var cursor = this.getCursorPos();
				if (cursor.get("start_x") == 0)
				{
					window.setTimeout(() =>
					{
						this.updateLinesCount();
					}, 10);
				}
			}
			else if (e.key == "Delete")
			{
				var cursor = this.getCursorPos();
				var line = this.getLineElement(cursor.get("start_y"));
				if (cursor.get("start_x") == line.innerText.length)
				{
					window.setTimeout(() =>
					{
						this.updateLinesCount();
					}, 10);
				}
			}
			else if (e.key == "Tab")
			{
				e.preventDefault();
				e.stopPropagation();
				/* Shift + Tab */
				if (e.shiftKey)
				{
					var cursor = this.getCursorPos();
					var line = this.getLineElement(cursor.get("start_y"));
					var offset = cursor.get("start_x");
					if (offset == 0)
					{
						return ;
					}
					var text = line.innerText;
					var last_char = Runtime.rs.charAt(text, offset - 1);
					if (last_char != "\t")
					{
						return ;
					}
					line.innerText = text.slice(0, offset - 1) + Runtime.rtl.toStr(text.slice(offset));
					this.setCursorPos(offset - 1, cursor.get("start_y"));
				}
				else
				{
					var node = document.createTextNode("\t");
					var selection = this.getSelection();
					var range = selection.getRangeAt(0);
					range.insertNode(node);
					range.setStartAfter(node);
					range.setEndAfter(node);
				}
			}
		},
		/**
 * Paste event
 */
		onPaste: function(e)
		{
			e.preventDefault();
			e.stopPropagation();
			var text = e.clipboardData.getData("text");
			this.pasteText(text);
		},
		/**
 * Input event
 */
		onInput: function(e)
		{
			if (this.change_timer != null)
			{
				window.clearTimeout(this.change_timer);
				this.change_timer = null;
			}
			this.change_timer = window.setTimeout(() =>
			{
				this.onChange();
			}, this.timeout);
		},
		/**
 * Change event
 */
		onChange: function(e)
		{
			var value = this.getValue();
			/* Send value change */
			this.emit("valueChange", new Runtime.Web.Messages.ValueChangeMessage(Runtime.Map.from({"value":value,"old_value":this.old_value,"data":this.data})));
			/* Set old value */
			this.old_value = value;
			this.change_timer = null;
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Code.TextEditable,
{
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_text.h-6975{display: flex;align-items: stretch;width: 100%;max-width: 100%;border-width: var(--widget-border-width);border-color: var(--widget-color-border);border-style: solid;border-radius: 4px;overflow: auto}.widget_text__lines.h-6975{width: 20px;padding-top: 7px;border-right-width: var(--widget-border-width);border-right-color: var(--widget-color-border);border-right-style: solid}.widget_text__lines.h-6975 .line{display: flex;align-items: center;justify-content: center;min-height: 21px}.widget_text__editable.h-6975{width: calc(100% - 20px);font-family: monospace;font-size: var(--widget-font-size);padding: var(--widget-button-padding-y) var(--widget-button-padding-x);margin: 0;background-color: var(--widget-color-default);box-shadow: none;outline: transparent;line-height: 1.5;tab-size: 4;text-wrap: balance;white-space: pre}.widget_text__editable.h-6975 .line{min-height: 21px}.widget_text__editable.wrap.h-6975{overflow-wrap: break-word;text-wrap: wrap}.widget_text__editable.overflow.h-6975{overflow: auto;text-wrap: nowrap}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Code";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Code.TextEditable";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Code.TextEditable);
window["BayLang.Constructor.Frontend.Code.TextEditable"] = BayLang.Constructor.Frontend.Code.TextEditable;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Code.TextEditable;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Code == 'undefined') BayLang.Constructor.Frontend.Code = {};
BayLang.Constructor.Frontend.Code.TreeItem = function()
{
	Runtime.Widget.Tree.TreeItem.apply(this, arguments);
};
BayLang.Constructor.Frontend.Code.TreeItem.prototype = Object.create(Runtime.Widget.Tree.TreeItem.prototype);
BayLang.Constructor.Frontend.Code.TreeItem.prototype.constructor = BayLang.Constructor.Frontend.Code.TreeItem;
Object.assign(BayLang.Constructor.Frontend.Code.TreeItem.prototype,
{
	/**
	 * Serialize object
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "kind", data);
		serializer.process(this, "file_path", data);
		serializer.process(this, "module_id", data);
		serializer.process(this, "project_id", data);
		serializer.process(this, "is_loaded", data);
		Runtime.Widget.Tree.TreeItem.prototype.serialize.call(this, serializer, data);
	},
	/**
	 * Returns true if loaded
	 */
	isLoaded: function()
	{
		return this.is_loaded;
	},
	/**
	 * Click
	 */
	onClick: function(model)
	{
		if (this.kind != "dir")
		{
			return ;
		}
		if (this.is_loaded)
		{
			this.open = !this.open;
		}
	},
	_init: function()
	{
		Runtime.Widget.Tree.TreeItem.prototype._init.call(this);
		this.kind = "";
		this.file_path = "";
		this.module_id = "";
		this.project_id = "";
		this.content = "";
		this.code_editor = new Runtime.Reference();
		this.is_loaded = false;
	},
});
Object.assign(BayLang.Constructor.Frontend.Code.TreeItem, Runtime.Widget.Tree.TreeItem);
Object.assign(BayLang.Constructor.Frontend.Code.TreeItem,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Code";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Code.TreeItem";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Tree.TreeItem";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Code.TreeItem);
window["BayLang.Constructor.Frontend.Code.TreeItem"] = BayLang.Constructor.Frontend.Code.TreeItem;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Code.TreeItem;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Code == 'undefined') BayLang.Constructor.Frontend.Code = {};
BayLang.Constructor.Frontend.Code.TreeWidget = {
	name: "BayLang.Constructor.Frontend.Code.TreeWidget",
	extends: Runtime.Widget.Tree.TreeWidget,
	methods:
	{
		renderItemContent: function(item, path)
		{
			let __v = [];
			
			/* Element 'span' */
			let __v0 = this._e(__v, "span", {"class":this._class_name(["tree_widget__item_icon"])});
			
			if (item.kind == "dir")
			{
				if (!item.is_loaded)
				{
					/* Element 'span' */
					let __v1 = this._e(__v0, "span", {});
					
					/* Raw */
					this._t(__v1, new Runtime.RawString("&#128448;"));
				}
				else if (item.open)
				{
					/* Element 'span' */
					let __v2 = this._e(__v0, "span", {});
					
					/* Raw */
					this._t(__v2, new Runtime.RawString("&#128449;"));
				}
				else
				{
					/* Element 'span' */
					let __v3 = this._e(__v0, "span", {});
					
					/* Raw */
					this._t(__v3, new Runtime.RawString("&#128448;"));
				}
			}
			else
			{
				/* Element 'span' */
				let __v4 = this._e(__v0, "span", {});
				
				/* Raw */
				this._t(__v4, new Runtime.RawString("&#128462;"));
			}
			
			/* Render */
			this._t(__v, this.renderItemLabel(item, path));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Code.TreeWidget,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Tree.TreeWidget"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".tree_widget__item_icon.h-67f7{display: inline-block;font-family: monospace;text-align: center;cursor: pointer;width: 24px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Code";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Code.TreeWidget";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Tree.TreeWidget";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Code.TreeWidget);
window["BayLang.Constructor.Frontend.Code.TreeWidget"] = BayLang.Constructor.Frontend.Code.TreeWidget;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Code.TreeWidget;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Components == 'undefined') BayLang.Constructor.Frontend.Components = {};
BayLang.Constructor.Frontend.Components.SelectImageButton = {
	name: "BayLang.Constructor.Frontend.Components.SelectImageButton",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Component 'Button' */
			let __v0 = this._c(__v, "Runtime.Widget.Button", {"onClick":this.onSelectImageClick}, () => {
				let __v = [];
				
				/* Text */
				this._t(__v, "Select image");
				
				return this._flatten(__v);
			});
			
			return this._flatten(__v);
		},
		/**
 * Select image click
 */
		onSelectImageClick: function(message)
		{
			var select_image_dialog = this.layout.getPageModel().select_image_dialog;
			select_image_dialog.clearListener("confirm");
			select_image_dialog.addListener("confirm", new Runtime.Callback(this, "onSelectImage"));
			select_image_dialog.show();
		},
		/**
 * On select image
 */
		onSelectImage: function()
		{
			var select_image_dialog = this.layout.getPageModel().select_image_dialog;
			var selected_item = select_image_dialog.getSelectedItem();
			var value = (selected_item) ? (selected_item.get("file_path")) : ("");
			/* Send value change */
			this.emit("valueChange", new Runtime.Web.Messages.ValueChangeMessage(Runtime.Map.from({"value":value,"data":this.data})));
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Components.SelectImageButton,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Button"]);
	},
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Components";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Components.SelectImageButton";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Components.SelectImageButton);
window["BayLang.Constructor.Frontend.Components.SelectImageButton"] = BayLang.Constructor.Frontend.Components.SelectImageButton;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Components.SelectImageButton;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Components == 'undefined') BayLang.Constructor.Frontend.Components = {};
BayLang.Constructor.Frontend.Components.SortableParams = {
	name: "BayLang.Constructor.Frontend.Components.SortableParams",
	extends: Runtime.Widget.SortableList,
	props: {
		"fields": {
			default: Runtime.Vector.from([]),
		},
	},
	methods:
	{
		renderValue: function(pos, item)
		{
			let __v = [];
			
			for (let i = 0; i < this.fields.count(); i++)
			{
				let field = this.fields.get(i);
				let field_name = field.get("name");
				let field_component = field.get("component");
				let field_props = field.get("props");
				
				/* Element 'div' */
				let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_sortable_list__item_value_row"])});
				
				/* Element 'div' */
				let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_sortable_list__item_value_label"])});
				
				/* Render */
				this._t(__v1, field.get("label"));
				
				/* Element 'div' */
				let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_sortable_list__item_value_item"])});
				
				/* Component '{field_component}' */
				let __v3 = this._c(__v2, field_component, this._merge_attrs({"name":field_name,"value":item.get(field_name),"onValueChange":(message) =>
				{
					var item = this.value.get(pos);
					item.set(field_name, message.value);
					this.onValueChange();
				}}, field_props));
			}
			
			return this._flatten(__v);
		},
		/**
 * Add item click
 */
		onAddItemClick: function()
		{
			var value = Runtime.Map.from({});
			for (var i = 0; i < this.fields.count(); i++)
			{
				var field = this.fields.get(i);
				var field_name = field.get("name");
				var field_default = field.get("default", "");
				value.set(field_name, field_default);
			}
			this.value.push(value);
			this.onValueChange();
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Components.SortableParams,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.SortableList","Runtime.Widget.Input","Runtime.Widget.Select","BayLang.Constructor.Frontend.Components.SelectImageButton"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_sortable_list__item_value.h-d333{padding: 5px}.widget_sortable_list__item_value_row.h-d333{display: flex;align-items: center}.widget_sortable_list__item_value_label.h-d333{width: 40px}.widget_sortable_list__item_value_item.h-d333{flex: 1}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Components";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Components.SortableParams";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.SortableList";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Components.SortableParams);
window["BayLang.Constructor.Frontend.Components.SortableParams"] = BayLang.Constructor.Frontend.Components.SortableParams;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Components.SortableParams;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog = {
	name: "BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog",
	extends: Runtime.Widget.Dialog.Dialog,
	methods:
	{
		renderContent: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_dialog__content"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["groups"])});
			
			/* Element 'div' */
			let __v2 = this._e(__v1, "div", {"class":this._class_name(["list_title"])});
			
			/* Text */
			this._t(__v2, "Groups");
			
			/* Element 'div' */
			let __v3 = this._e(__v1, "div", {"class":this._class_name(["list_items"])});
			
			for (let i = 0; i < this.model.current_groups.count(); i++)
			{
				let group = this.model.current_groups.get(i);
				
				/* Element 'div' */
				let __v4 = this._e(__v3, "div", {"onClick":() =>
				{
					this.model.selected_group_name = group.get("name");
				},"class":this._class_name(["list_item", ((this.model.selected_group_name == group.get("name")) ? ("selected") : (""))])});
				
				/* Render */
				this._t(__v4, group.get("label"));
			}
			
			/* Element 'div' */
			let __v5 = this._e(__v0, "div", {"class":this._class_name(["widgets"])});
			
			/* Element 'div' */
			let __v6 = this._e(__v5, "div", {"class":this._class_name(["list_title"])});
			
			/* Text */
			this._t(__v6, "Select component");
			
			/* Element 'div' */
			let __v7 = this._e(__v5, "div", {"class":this._class_name(["list_items"])});
			
			if (this.model.current_widgets)
			{
				for (let i = 0; i < this.model.current_widgets.count(); i++)
				{
					let widget = this.model.current_widgets.get(i);
					
					if (this.model.selected_group_name == widget.getGroupName())
					{
						/* Element 'div' */
						let __v8 = this._e(__v7, "div", {"onClick":() =>
						{
							this.model.selectItem(widget);
						},"class":this._class_name(["list_item"])});
						
						/* Render */
						this._t(__v8, widget.getWidgetName());
					}
				}
			}
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Dialog.Dialog","Runtime.Widget.Input","Runtime.Widget.Select"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_dialog__content.h-864d{display: flex;min-height: 250px}.list_title.h-864d{margin-bottom: 10px}.list_item.h-864d{cursor: pointer;padding: 10px}.list_item.h-864d:hover{background-color: var(--widget-color-hover)}.list_item.selected.h-864d{background-color: var(--widget-color-primary);color: var(--widget-color-primary-text)}.widget_dialog__content.h-864d .groups{width: 30%;padding-right: 10px}.widget_dialog__content.h-864d .groups .list_items.h-864d{border: var(--widget-border-width) var(--widget-color-border) solid;border-radius: 4px}.widget_dialog__content.h-864d .groups .list_item.h-864d{border-bottom: var(--widget-border-width) var(--widget-color-border) solid}.widget_dialog__content.h-864d .groups .list_item.h-864d:last-child{border-bottom-width: 0px}.widget_dialog__content.h-864d .widgets{width: 70%}.widget_dialog__content.h-864d .widgets .list_items.h-864d{display: flex;align-items: stretch;justify-content: space-between;flex-wrap: wrap;gap: 15px}.widget_dialog__content.h-864d .widgets .list_item.h-864d{border: var(--widget-border-width) var(--widget-color-border) solid;border-radius: 4px;text-align: center;flex: 1 1 30%}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.Dialog";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog);
window["BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog"] = BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel = function()
{
	Runtime.Widget.Dialog.DialogModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel.prototype = Object.create(Runtime.Widget.Dialog.DialogModel.prototype);
BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Widget.Dialog.DialogModel.prototype.initWidget.call(this, params);
		/* Setup close buttons */
		this.buttons.addButton(Runtime.Map.from({"content":"Cancel","widget_name":"cancel_button","styles":Runtime.Vector.from(["gray"]),"events":Runtime.Map.from({"click":new Runtime.Callback(this, "onCloseButtonClick")})}));
	},
	/**
	 * Select item
	 */
	selectItem: function(widget_settings)
	{
		var editor = this.parent_widget.getFrameEditor();
		/* Create widget name */
		var default_widget_name = widget_settings.getSelectorName();
		var widget_name_value = this.parent_widget.attribute_processor.createWidgetName(default_widget_name);
		/* Create widget */
		var op_code = this.parent_widget.component_processor.createWidget(widget_settings, widget_name_value);
		this.parent_widget.addOpCode(op_code, this.selected_widget_path, this.kind);
		this.hide();
	},
	/**
	 * Add close button click
	 */
	onCloseButtonClick: function(message)
	{
		this.hide();
	},
	/**
	 * Returns widget label
	 */
	getTagWidgetInfo: function(op_code)
	{
		var class_name_attr = op_code.attrs.findItem(Runtime.lib.equalAttr("key", "class"));
		if (!class_name_attr)
		{
			return Runtime.Map.from({"label":op_code.tag_name,"tag_name":op_code.tag_name,"class_name":"","widget_name":""});
		}
		var class_name = class_name_attr.value.value;
		var attrs = Runtime.rs.split(" ", class_name);
		attrs = attrs.filter(Runtime.lib.equalNot(""));
		return Runtime.Map.from({"label":op_code.tag_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(attrs.first()),"tag_name":op_code.tag_name,"class_name":class_name,"widget_name":attrs.first()});
	},
	/**
	 * Update frame widgets
	 */
	updateFrameWidgets: function()
	{
		/* Update selected widget */
		var selected_widget = this.selected_widget;
		if (this.kind == "before" || this.kind == "after")
		{
			var selected_widget_path = this.selected_widget_path.slice(0, -1);
			selected_widget = this.parent_widget.widget_manager.getWidget(selected_widget_path);
		}
		/* Setup widget */
		selected_widget.setup();
		/* Get editor provider */
		var editor = this.parent_widget.getFrameEditor();
		/* Update widgets */
		var widgets = editor.getWidgets();
		this.current_widgets = widgets.filter((widget_settings) =>
		{
			if (!widget_settings.getComponentName())
			{
				return false;
			}
			if (!selected_widget.canInsert(widget_settings))
			{
				return false;
			}
			return true;
		});
		/* Get groups used */
		var groups = Runtime.Map.from({});
		this.selected_group_name = "";
		for (var i = 0; i < this.current_widgets.count(); i++)
		{
			var group_name = this.current_widgets.get(i).getGroupName();
			groups.set(group_name, 1);
			if (this.selected_group_name == "")
			{
				this.selected_group_name = group_name;
			}
		}
		/* Update groups */
		this.current_groups = Runtime.Vector.from([]);
		var group_settings = editor.getGroups();
		for (var i = 0; i < group_settings.count(); i++)
		{
			var group = group_settings.get(i);
			var group_name = group.get("name");
			if (groups.has(group_name))
			{
				this.current_groups.push(group);
			}
		}
	},
	/**
	 * Show dialog
	 */
	show: function(selected_path, kind)
	{
		if (selected_path == undefined) selected_path = null;
		if (kind == undefined) kind = "after";
		this.step = 1;
		this.kind = kind;
		this.title = "Add item";
		/* If selected_path is main widget */
		if (!selected_path)
		{
			this.kind = "last";
		}
		/* Setup selected widget */
		this.selected_widget_path = (selected_path) ? (selected_path.slice()) : (Runtime.Vector.from([]));
		this.selected_widget = this.parent_widget.widget_manager.getWidget(this.selected_widget_path);
		/* Update widgets list */
		this.updateFrameWidgets();
		Runtime.Widget.Dialog.DialogModel.prototype.show.call(this);
	},
	_init: function()
	{
		Runtime.Widget.Dialog.DialogModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialog";
		this.widget_name = "add_item_dialog";
		this.kind = "after";
		this.width = "700px";
		this.selected_group_name = "basic";
		this.current_groups = Runtime.Vector.from([]);
		this.current_widgets = Runtime.Vector.from([]);
		this.selected_widget = null;
		this.selected_widget_path = null;
		this.selected_widget_info = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel, Runtime.Widget.Dialog.DialogModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.DialogModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel);
window["BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel"] = BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog = {
	name: "BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog",
	extends: Runtime.Widget.Dialog.Dialog,
	methods:
	{
		renderContent: function()
		{
			let __v = [];
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Dialog.Dialog","Runtime.Widget.Select","Runtime.Widget.Form.FormRow"]);
	},
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.Dialog";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog);
window["BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog"] = BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel = function()
{
	Runtime.Widget.Dialog.ConfirmDialogModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel.prototype = Object.create(Runtime.Widget.Dialog.ConfirmDialogModel.prototype);
BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.initWidget.call(this, params);
		/* Remove button */
		var confirm_button = this.buttons.getWidget("confirm_button");
		confirm_button.content = "Remove";
		confirm_button.styles.add("danger");
		confirm_button.styles.removeItem("primary");
	},
	/**
	 * On value change
	 */
	onValueChange: function(message)
	{
		this.remove_value = message.value;
	},
	/**
	 * Confirm button click
	 */
	onConfirmButtonClick: function(message)
	{
		var path = this.parent_widget.selected.path.slice();
		if (path)
		{
			this.parent_widget.removeWidget(path, true);
		}
		this.hide();
	},
	_init: function()
	{
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialog";
		this.widget_name = "remove_item_dialog";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel, Runtime.Widget.Dialog.ConfirmDialogModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.ConfirmDialogModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel);
window["BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel"] = BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog = {
	name: "BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog",
	extends: Runtime.Widget.Dialog.Dialog,
	methods:
	{
		renderUploadImage: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["item item_upload"])});
			
			/* Element 'input' */
			let __v1 = this._e(__v0, "input", {"type":"file","ref":"upload_file","onChange":this.onFileUploadChange});
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"onClick":this.onFileUploadClick,"class":this._class_name(["item_image_wrap"])});
			
			/* Text */
			this._t(__v2, "Upload image");
			
			return this._flatten(__v);
		},
		renderContent: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"ref":"items","onClick":() =>
			{
				this.model.context_menu.hide();
			},"class":this._class_name(["select_image_items"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.context_menu));
			
			/* Render */
			this._t(__v0, this.renderUploadImage());
			
			for (let i = 0; i < this.model.items.count(); i++)
			{
				let item = this.model.items.get(i);
				
				if (this.isImage(item))
				{
					/* Element 'div' */
					let __v1 = this._e(__v0, "div", {"onClick":() =>
					{
						this.model.selectItem(i);
					},"onContextmenu":(event) =>
					{
						var rect = this.getRef("items").getBoundingClientRect();
						var x = event.clientX - rect.left;
						var y = event.clientY - rect.top;
						this.model.selectItem(i);
						this.model.contextMenu(x, y);
						event.preventDefault();
					},"class":this._class_name(["item", ((this.model.selected == i) ? ("active") : (""))])});
					
					/* Element 'div' */
					let __v2 = this._e(__v1, "div", {"class":this._class_name(["item_image_wrap"])});
					
					/* Element 'img' */
					let __v3 = this._e(__v2, "img", {"src":item.get("url"),"class":this._class_name(["item_image"])});
					
					/* Element 'div' */
					let __v4 = this._e(__v1, "div", {"class":this._class_name(["item_label"])});
					
					/* Element 'span' */
					let __v5 = this._e(__v4, "span", {});
					
					/* Render */
					this._t(__v5, item.get("file_name"));
				}
			}
			
			return this._flatten(__v);
		},
		/**
 * File upload click event
 */
		onFileUploadClick: function()
		{
			var upload_file = this.getRef("upload_file");
			upload_file.click();
		},
		/**
 * File upload change
 */
		onFileUploadChange: function()
		{
			var upload_file = this.getRef("upload_file");
			var file = Runtime.rtl.attr(upload_file.files, 0);
			if (file)
			{
				this.model.uploadFile(file);
			}
		},
		/**
 * Returns true if item is image
 */
		isImage: function(item)
		{
			var file_name = item.get("file_name");
			var file_extension = Runtime.rs.extname(file_name);
			var arr = Runtime.Vector.from(["jpg","jpeg","png","svg"]);
			if (arr.indexOf(file_extension) == -1)
			{
				return false;
			}
			return true;
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Dialog.Dialog"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".select_image_items.h-1804{position: relative;display: flex;flex-wrap: wrap}.select_image_items.h-1804 .item.h-1804{margin: 5px;text-align: center;cursor: pointer}.select_image_items.h-1804 .item_image_wrap.h-1804{display: flex;position: relative;align-items: center;justify-content: center;width: 100px;height: 100px;padding: 2px;border: 2px transparent solid}.select_image_items.h-1804 .item_upload.h-1804 input{display: none}.select_image_items.h-1804 .item_upload.h-1804 .item_image_wrap.h-1804{border: 1px var(--widget-color-border) solid;border-radius: 4px}.select_image_items.h-1804 .item_image.h-1804{max-width: 100%;max-height: 100%}.select_image_items.h-1804 .item_label.h-1804{margin-top: 5px;overflow-wrap: anywhere;width: 100px;text-align: center}.select_image_items.h-1804 .item_label.h-1804 span{display: inline-block;padding: 5px}.select_image_items.h-1804 .item.active.h-1804 .item_image_wrap.h-1804{border-color: var(--widget-color-primary);user-select: none}.select_image_items.h-1804 .item.active.h-1804 .item_label.h-1804 span{background-color: var(--widget-color-primary);color: white}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.Dialog";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog);
window["BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog"] = BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Dialog == 'undefined') BayLang.Constructor.Frontend.Editor.Dialog = {};
BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel = function()
{
	Runtime.Widget.Dialog.ConfirmDialogModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel.prototype = Object.create(Runtime.Widget.Dialog.ConfirmDialogModel.prototype);
BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.initWidget.call(this, params);
		/* Clear button */
		this.buttons.addButton(Runtime.Map.from({"content":"Clear","widget_name":"clear_button","dest":"cancel_button","kind":"before","styles":Runtime.Vector.from(["danger"]),"events":Runtime.Map.from({"click":new Runtime.Callback(this, "onConfirmButtonClick")})}));
		/* Create ContextMenu */
		this.context_menu = this.addWidget("Runtime.Widget.ContextMenu.ContextMenuModel");
		this.context_menu.addItem(Runtime.Map.from({"label":"Delete","key":"delete"}));
		this.context_menu.addListener("clickItem", new Runtime.Callback(this, "onContextClickItem"));
		/* Select button */
		var confirm_button = this.buttons.getWidget("confirm_button");
		confirm_button.content = "Select";
	},
	/**
	 * Upload file
	 */
	uploadFile: async function(file)
	{
		var result = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.assets","method_name":"uploadFile","data":Runtime.Map.from({"project_id":this.parent_widget.project_id,"path":"images","file":file})}));
		if (result.isSuccess())
		{
			await this.loadItems();
		}
	},
	/**
	 * Load items
	 */
	loadItems: async function()
	{
		var result = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.assets","method_name":"getFiles","data":Runtime.Map.from({"project_id":this.parent_widget.project_id,"path":"images"})}));
		if (result.isSuccess())
		{
			this.items = result.data.get("items");
			this.path = result.data.get("path");
		}
	},
	/**
	 * Load data
	 */
	loadData: async function(container)
	{
		await this.loadItems();
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.loadData.call(this, container);
	},
	/**
	 * Process frontend data
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "items", data);
		serializer.process(this, "path", data);
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.serialize.call(this, serializer, data);
	},
	/**
	 * Context menu click
	 */
	onContextClickItem: function(message)
	{
		var item = message.item;
		var item_key = item.get("key");
		this.context_menu.hide();
		/* Delete item */
		if (item_key == "delete")
		{
			this.removeSelectedItem();
		}
	},
	/**
	 * Clear button click
	 */
	onConfirmButtonClick: function(message)
	{
		if (message.widget.widget_name == "confirm_button")
		{
			if (this.selected == -1)
			{
				return ;
			}
		}
		else if (message.widget.widget_name == "clear_button")
		{
			this.value = "";
			this.selected = -1;
		}
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.onConfirmButtonClick.call(this, message);
	},
	/**
	 * Select item
	 */
	selectItem: function(i)
	{
		this.selected = i;
	},
	/**
	 * Context menu
	 */
	contextMenu: function(x, y)
	{
		this.context_menu.show(x, y);
	},
	/**
	 * Returns selected item
	 */
	getSelectedItem: function()
	{
		return this.items.get(this.selected);
	},
	/**
	 * Remove selected item
	 */
	removeSelectedItem: async function()
	{
		var item = this.getSelectedItem();
		var result = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.assets","method_name":"removeFile","data":Runtime.Map.from({"project_id":this.parent_widget.project_id,"path":"images","file_name":item.get("file_name")})}));
		if (result.isSuccess())
		{
			this.items.remove(this.selected);
			this.selectItem(-1);
		}
	},
	/**
	 * Show dialog
	 */
	show: function()
	{
		this.selected = -1;
		this.loadItems();
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype.show.call(this);
	},
	_init: function()
	{
		Runtime.Widget.Dialog.ConfirmDialogModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialog";
		this.title = "Select image";
		this.width = "90%";
		this.path = "";
		this.selected = -1;
		this.items = Runtime.Vector.from([]);
		this.context_menu = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel, Runtime.Widget.Dialog.ConfirmDialogModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Dialog.ConfirmDialogModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel);
window["BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel"] = BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.Parameter = function(params)
{
	if (params == undefined) params = null;
	Runtime.BaseObject.call(this);
	this._assign_values(params);
};
BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.Parameter;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype,
{
	/**
	 * Init parameter
	 */
	init: function()
	{
		if (this.default == null)
		{
			return ;
		}
		if (this.value != null)
		{
			return ;
		}
		this.setValue(this.default);
	},
	/**
	 * Is op_code
	 */
	isOpCode: function(op_code)
	{
		return false;
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_code)
	{
		this.op_code = op_code;
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
	},
	/**
	 * Change param
	 */
	changeValue: function(value)
	{
		this.setValue(value);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.name = "";
		this.label = "";
		this.component = "";
		this.tab = "params";
		this.display = true;
		this.value = null;
		this.default = null;
		this.props = null;
		this.op_code = null;
		this.widget = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.Parameter, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.Parameter,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
window["BayLang.Constructor.Frontend.Editor.Parameters.Parameter"] = BayLang.Constructor.Frontend.Editor.Parameters.Parameter;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.Parameter;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.Parameter.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype,
{
	/**
	 * Is op_code
	 */
	isOpCode: function(op_code)
	{
		return op_code instanceof BayLang.OpCodes.OpHtmlAttribute && this.name == op_code.key;
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_code)
	{
		this.op_code = op_code;
		this.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(op_code.value);
	},
	/**
	 * Find code
	 */
	findOpCode: function()
	{
		if (this.op_code != null)
		{
			return ;
		}
		/* Find code */
		this.op_code = this.widget.code.attrs.findItem(Runtime.lib.equalAttr("key", this.name));
	},
	/**
	 * Create attribute
	 */
	createHtmlAttribute: function()
	{
		if (this.op_code != null)
		{
			return ;
		}
		this.op_code = new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":this.name}));
		this.widget.code.attrs.prepend(this.op_code);
	},
	/**
	 * Remove attribute
	 */
	removeHtmlAttribute: function()
	{
		if (this.op_code == null)
		{
			return ;
		}
		/* Clear code */
		this.op_code = null;
		/* Remove attribute */
		var pos = this.widget.code.attrs.find(Runtime.lib.equalAttr("key", this.name));
		if (pos >= 0)
		{
			this.widget.code.attrs.remove(pos);
		}
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		if (value === "")
		{
			this.removeHtmlAttribute();
			this.value = "";
			return ;
		}
		/* Find item */
		this.findOpCode();
		/* Create html attribute */
		if (this.op_code == null)
		{
			this.createHtmlAttribute();
		}
		/* Set value */
		this.value = value;
		this.op_code.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(value);
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype._init.call(this);
		this.op_code = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent, BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName.prototype,
{
	/**
	 * Is op_code
	 */
	isOpCode: function(op_attr)
	{
		return op_attr.key == "class";
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_attr)
	{
		var class_name = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(op_attr.value);
		var value = Runtime.rs.split(" ", class_name);
		value = value.filter((s) =>
		{
			return s != "";
		});
		this.value = value.slice(1);
		this.op_attr = op_attr;
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		/* Create html attribute */
		if (this.op_attr == null)
		{
			this.createHtmlAttribute();
		}
		/* Set value */
		var arr = Runtime.Vector.from([this.param_widget_name.value]);
		arr.appendItems(value);
		this.value = arr.slice(1);
		this.op_attr.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(Runtime.rs.join(" ", arr));
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype._init.call(this);
		this.display = false;
		this.name = "class_name";
		this.value = Runtime.Vector.from([]);
		this.param_widget_name = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName, BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.Parameter.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent.prototype,
{
	/**
	 * Init parameter
	 */
	init: function()
	{
		var text_item = this.widget.code.items.items.get(0);
		if (text_item instanceof BayLang.OpCodes.OpHtmlContent)
		{
			this.value = text_item.value;
		}
		else if (text_item instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (text_item.value instanceof BayLang.OpCodes.OpString)
			{
				this.value = text_item.value.value;
			}
		}
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		/* Get code */
		var text_item = this.widget.code.items.items.get(0);
		/* Set value */
		this.value = value;
		/* Set content */
		if (text_item instanceof BayLang.OpCodes.OpHtmlContent)
		{
			text_item.value = this.value;
		}
		else if (text_item instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (text_item.value instanceof BayLang.OpCodes.OpString)
			{
				text_item.value.value = this.value;
			}
		}
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype._init.call(this);
		this.name = "html_content";
		this.label = "Content";
		this.component = "Runtime.Widget.TextEditable";
		this.value = "";
		this.props = Runtime.Map.from({"direct_update":true});
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent, BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterContent;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.Parameter.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype,
{
	/**
	 * Is op_code
	 */
	isOpCode: function(op_attr)
	{
		return op_attr instanceof BayLang.OpCodes.OpDictPair && this.name == op_attr.key;
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_dict_pair)
	{
		this.op_code = op_dict_pair;
		this.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(op_dict_pair.value);
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
		this.op_code.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(value);
	},
	/**
	 * Change model value
	 */
	changeValue: function(value)
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype.changeValue.call(this, value);
		/* Update model value */
		this.changeModelValue();
	},
	/**
	 * Change model value
	 */
	changeModelValue: function()
	{
		/* Get widget model */
		var model = this.widget.getModel();
		if (!model)
		{
			return ;
		}
		/* Model settings onChange event */
		if (Runtime.rtl.exists(this.widget.model_settings.onChange))
		{
			var is_updated = this.widget.model_settings.onChange(model, this);
			if (is_updated)
			{
				return ;
			}
		}
		/* Update model value */
		this.updateModelValue(model);
	},
	/**
	 * Update model value
	 */
	updateModelValue: function(model)
	{
		/* Get key value */
		var key = this.name;
		var value = this.value;
		/* Set params */
		var params = Runtime.Map.from({});
		params.set(key, value);
		model.initParams(params);
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype._init.call(this);
		this.op_code = null;
		this.onChange = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel, BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel.prototype,
{
	/**
	 * Is op_code
	 */
	isOpCode: function(op_attr)
	{
		if (!this.path)
		{
			return false;
		}
		if (this.path.count() == 0)
		{
			return false;
		}
		return op_attr instanceof BayLang.OpCodes.OpDictPair && this.path.first() == op_attr.key;
	},
	/**
	 * Get OpDictPair from OpDict by name
	 */
	findCodeByName: function(code, name)
	{
		if (!(code instanceof BayLang.OpCodes.OpDict))
		{
			return false;
		}
		for (var i = 0; i < code.values.count(); i++)
		{
			var pair = code.values.get(i);
			if (pair.key == name)
			{
				return pair;
			}
		}
		return null;
	},
	/**
	 * Find OpDictPair by path
	 */
	getCode: function()
	{
		var code = this.op_code;
		var path = this.path.slice(1);
		while (path.count() > 0 && code != null)
		{
			var name = path.first();
			code = this.findCodeByName(code.value, name);
			path = path.slice(1);
		}
		return code;
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_dict_pair)
	{
		this.op_code = op_dict_pair;
		var code = this.getCode();
		if (code)
		{
			this.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(code.value);
		}
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
		var code = this.getCode();
		if (code)
		{
			code.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(value);
		}
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype._init.call(this);
		this.path = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel, BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterDictModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel.prototype,
{
	/**
	 * Find OpDictPair by path
	 */
	getCode: function()
	{
		var op_code = this.op_code.value;
		if (!(op_code instanceof BayLang.OpCodes.OpNew))
		{
			return ;
		}
		if (op_code.args.count() != 2)
		{
			return ;
		}
		var op_code_params = op_code.args.get(1);
		if (!(op_code_params instanceof BayLang.OpCodes.OpDict))
		{
			return ;
		}
		var op_code_api_name = op_code_params.values.findItem(Runtime.lib.equalAttr("api_name"));
		if (!op_code_api_name)
		{
			return ;
		}
		return op_code_api_name;
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_dict_pair)
	{
		this.op_code = op_dict_pair;
		var code = this.getCode();
		if (code)
		{
			this.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(code.value);
		}
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
		var code = this.getCode();
		if (code)
		{
			code.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(value);
		}
	},
	/**
	 * Update model value
	 */
	updateModelValue: function(model)
	{
		var name = this.name;
		var path = this.path;
		var value = this.value;
		model[name][path] = value;
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel.prototype._init.call(this);
		this.path = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel, BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterFactoryModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.Parameter.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml.prototype,
{
	/**
	 * Init parameter
	 */
	init: function()
	{
		var text_item = this.widget.code.items.items.get(0);
		if (text_item instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (text_item.kind == "raw")
			{
				this.value = "1";
			}
		}
	},
	/**
	 * Returns HTML content
	 */
	getHtmlContent: function()
	{
		var text_item = this.widget.code.items.items.get(0);
		if (text_item instanceof BayLang.OpCodes.OpHtmlContent)
		{
			return text_item.value;
		}
		else if (text_item instanceof BayLang.OpCodes.OpHtmlValue)
		{
			if (text_item.value instanceof BayLang.OpCodes.OpString)
			{
				return text_item.value.value;
			}
		}
		return "";
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
		/* Update key debug attr */
		var attr_item = this.widget.code.attrs.findItem(Runtime.lib.equalAttr("key", "@key_debug"));
		if (attr_item)
		{
			if (this.value == "1")
			{
				if (Runtime.rs.indexOf(attr_item.value.value, "_raw") == -1)
				{
					attr_item.value.value = Runtime.rtl.attr(attr_item.value.value, ["value", "value"]) + Runtime.rtl.toStr("_raw");
				}
			}
			else
			{
				if (Runtime.rs.indexOf(attr_item.value.value, "_raw") != -1)
				{
					attr_item.value.value = Runtime.rs.replace("_raw", "", attr_item.value.value);
				}
			}
		}
		/* Set content */
		var code = null;
		if (this.value == "1")
		{
			code = new BayLang.OpCodes.OpHtmlValue(Runtime.Map.from({"kind":"raw","value":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":this.getHtmlContent()}))}));
		}
		else
		{
			code = new BayLang.OpCodes.OpHtmlContent(Runtime.Map.from({"value":this.getHtmlContent()}));
		}
		/* Add content */
		this.widget.code.items.items = Runtime.Vector.from([]);
		this.widget.code.items.items.push(code);
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype._init.call(this);
		this.name = "is_raw_html";
		this.label = "Is Raw HTML";
		this.component = "Runtime.Widget.Select";
		this.value = "0";
		this.props = Runtime.Map.from({"show_select_value":false,"options":Runtime.Vector.from([Runtime.Map.from({"key":"0","value":"No"}),Runtime.Map.from({"key":"1","value":"Yes"})])});
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml, BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterRawHtml;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.Parameter.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName.prototype,
{
	/**
	 * Init parameter
	 */
	init: function()
	{
		this.value = Runtime.rs.lower(this.widget.code.tag_name);
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		if (value == "")
		{
			value = "div";
		}
		/* Update tag name */
		this.widget.code.tag_name = value;
		/* Setup widget */
		this.widget.reset();
		this.widget.setup();
		/* Update tree label */
		this.widget.tree_item.updateLabel();
		/* Set new value */
		this.value = value;
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.Parameter.prototype._init.call(this);
		this.name = "tag";
		this.label = "Tag";
		this.component = "Runtime.Widget.Select";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName, BayLang.Constructor.Frontend.Editor.Parameters.Parameter);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.Parameter";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterTagName;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Parameters == 'undefined') BayLang.Constructor.Frontend.Editor.Parameters = {};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName = function()
{
	BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype);
BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName.prototype.constructor = BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName;
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName.prototype,
{
	/**
	 * Is op_code
	 */
	isOpCode: function(op_attr)
	{
		return op_attr.key == "class";
	},
	/**
	 * Set op_code
	 */
	setOpCode: function(op_attr)
	{
		var class_name = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getValueFromOpCode(op_attr.value);
		var value = Runtime.rs.split(" ", class_name);
		value = value.filter((s) =>
		{
			return s != "";
		});
		this.value = value.get(0);
		this.op_attr = op_attr;
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		/* Create html attribute */
		if (this.op_attr == null)
		{
			this.createHtmlAttribute();
		}
		/* Set value */
		var arr = this.param_class_name.value.insertIm(0, value);
		this.value = arr.get(0);
		this.op_attr.value = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.getOpCodeByValue(Runtime.rs.join(" ", arr));
	},
	/**
	 * Change param
	 */
	changeValue: function(value)
	{
		BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype.changeValue.call(this, value);
		/* Update label */
		this.widget.tree_item.updateLabel();
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent.prototype._init.call(this);
		this.display = false;
		this.name = "widget_name";
		this.value = "";
		this.param_class_name = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName, BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent);
Object.assign(BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName);
window["BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName"] = BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Processor == 'undefined') BayLang.Constructor.Frontend.Editor.Processor = {};
BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor = function(page_model)
{
	Runtime.BaseObject.call(this);
	this.page_model = page_model;
};
BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor.prototype.constructor = BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor;
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor.prototype,
{
	/**
	 * Create widget name
	 */
	createWidgetName: function(widget_name)
	{
		var name = widget_name + Runtime.rtl.toStr("_") + Runtime.rtl.toStr(this.widget_inc);
		this.widget_inc = this.widget_inc + 1;
		return name;
	},
	/**
	 * Create key_debug name
	 */
	createKeyName: function(widget_name)
	{
		var name = widget_name + Runtime.rtl.toStr("_") + Runtime.rtl.toStr(this.key_debug_inc);
		this.key_debug_inc = this.key_debug_inc + 1;
		return name;
	},
	/**
	 * Init widget inc
	 */
	initWidgetInc: function()
	{
		this.widget_inc = this.key_debug_inc;
	},
	/**
	 * Generate widget name
	 */
	generateWidgetName: function(widget_name, item)
	{
		if (Runtime.rs.substr(item, 0, 2) != "[&")
		{
			return widget_name;
		}
		if (Runtime.rs.substr(item, -1) != "]")
		{
			return widget_name;
		}
		item = Runtime.rs.substr(item, 2, -1);
		return widget_name + Runtime.rtl.toStr(item);
	},
	/**
	 * Add op_code tag attrs
	 */
	processHtmlTag: function(op_code, widget_name)
	{
		var css_name = null;
		/* Create widget name */
		var createWidgetName = () =>
		{
			if (css_name == null)
			{
				css_name = this.createWidgetName("widget");
			}
			return css_name;
		};
		/* Generate widget name */
		var generateWidgetName = (item) =>
		{
			widget_name = this.generateWidgetName(widget_name, item);
			return widget_name;
		};
		/* Add render key */
		var key_attr = op_code.attrs.findItem(Runtime.lib.equalAttr("key", "@key"));
		var key_debug_attr = op_code.attrs.findItem(Runtime.lib.equalAttr("key", "@key_debug"));
		if (key_attr == null && key_debug_attr == null)
		{
			/* Create key debug */
			var key_debug_value = this.createKeyName("widget");
			if (op_code.items)
			{
				var item = op_code.items.items.get(0);
				if (item instanceof BayLang.OpCodes.OpHtmlValue && item.kind == "raw")
				{
					key_debug_value += Runtime.rtl.toStr("_raw");
				}
			}
			/* Add key debug */
			op_code.attrs.push(new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":"@key_debug","value":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":key_debug_value}))})));
		}
		/* Change widget name */
		var class_name_attr = op_code.attrs.findItem(Runtime.lib.equalAttr("key", "class"));
		if (class_name_attr && class_name_attr.value instanceof BayLang.OpCodes.OpString)
		{
			var class_name = class_name_attr.value.value;
			var attrs = Runtime.rs.split(" ", class_name);
			attrs = attrs.filter(Runtime.lib.equalNot(""));
			attrs = attrs.map((item) =>
			{
				if (item == "[widget_name]")
				{
					return createWidgetName();
				}
				if (Runtime.rs.substr(item, 0, 2) == "[&" && Runtime.rs.substr(item, -1) == "]")
				{
					return generateWidgetName(item);
				}
				return item;
			});
			class_name_attr.value.value = Runtime.rs.join(" ", attrs);
		}
	},
	/**
	 * Add op_code slot attrs
	 */
	processHtmSlot: function(op_code, widget_name)
	{
	},
	/**
	 * Generate html items attrs
	 */
	processHtmlItems: function(items, widget_name)
	{
		if (widget_name == undefined) widget_name = "";
		if (!items)
		{
			return ;
		}
		if (items instanceof BayLang.OpCodes.OpHtmlItems)
		{
			items = items.items;
		}
		for (var i = 0; i < items.count(); i++)
		{
			var item = items.get(i);
			/* Add render key to item */
			if (Runtime.rtl.is_instanceof(item, "BayLang.OpCodes.OpHtmlTag"))
			{
				this.processHtmlTag(item, widget_name);
			}
			else if (Runtime.rtl.is_instanceof(item, "BayLang.OpCodes.OpHtmlSlot"))
			{
				this.processHtmSlot(item, widget_name);
			}
			/* Generate html items attrs */
			this.processHtmlItems(item.items, widget_name);
		}
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.page_model = null;
		this.widget_inc = 1;
		this.key_debug_inc = 1;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor);
window["BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor"] = BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Processor == 'undefined') BayLang.Constructor.Frontend.Editor.Processor = {};
BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor = function(page_model)
{
	Runtime.BaseObject.call(this);
	this.page_model = page_model;
};
BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype.constructor = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor;
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype,
{
	/**
	 * Setup op code
	 */
	setupOpCode: function(code)
	{
		this.code = code;
		this.class_name = "";
		this.class_namespace = "";
		if (!this.code)
		{
			return ;
		}
		/* Setup component class name */
		for (var i = 0; i < this.code.items.count(); i++)
		{
			var item = this.code.items.get(i);
			if (item instanceof BayLang.OpCodes.OpNamespace)
			{
				this.class_namespace = item.name;
			}
			if (item instanceof BayLang.OpCodes.OpDeclareClass)
			{
				this.class_name = item.name;
			}
		}
	},
	/**
	 * Returns full class name
	 */
	getComponentFullClassName: function()
	{
		return (this.class_namespace != "") ? (this.class_namespace + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(this.class_name)) : (this.class_name);
	},
	/**
	 * Returns module class name
	 */
	getModuleClassName: function(widget_name)
	{
		if (!this.constructor.isComponent(widget_name))
		{
			return null;
		}
		if (!this.code)
		{
			return null;
		}
		if (!this.code.uses.has(widget_name))
		{
			return widget_name;
		}
		return this.code.uses.get(widget_name);
	},
	/**
	 * Returns components
	 */
	getComponents: function()
	{
		return this.code.uses.values();
	},
	/**
	 * Add module
	 */
	addModule: function(widget_name, alias_name, is_component)
	{
		if (alias_name == undefined) alias_name = "";
		if (is_component == undefined) is_component = false;
		if (alias_name == "")
		{
			var widget_name_arr = Runtime.rs.split(".", widget_name);
			alias_name = widget_name_arr.last();
		}
		if (!this.code.hasModule(alias_name) || alias_name == "")
		{
			this.code.addModule(widget_name, alias_name, is_component);
		}
		return alias_name;
	},
	/**
	 * Returns function
	 */
	findFunction: function(function_name)
	{
		if (!this.code)
		{
			return null;
		}
		var op_code_class = this.code.findClass();
		if (!op_code_class)
		{
			return null;
		}
		var op_code = op_code_class.findFunction(function_name);
		return op_code;
	},
	/**
	 * Create parser
	 */
	createParser: function()
	{
		/* Setup parser params */
		var params = Runtime.Map.from({"current_namespace_name":this.class_namespace,"current_class_name":this.class_name,"uses":this.code.uses});
		/* Create new instance */
		var parser = new BayLang.LangBay.ParserBay();
		parser = parser.constructor.reset(parser);
		if (params.has("current_namespace_name"))
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_namespace_name"]), params.get("current_namespace_name"));
		}
		if (params.has("current_class_name"))
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["current_class_name"]), params.get("current_class_name"));
		}
		if (params.has("uses"))
		{
			parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["uses"]), params.get("uses"));
		}
		return parser;
	},
	/**
	 * Create translator
	 */
	createTranslator: function()
	{
		/* New instance */
		var t = new BayLang.LangES6.TranslatorES6();
		/* Reset translator */
		var t = BayLang.LangES6.TranslatorES6.reset(t);
		if (this.code.uses != null)
		{
			t = Runtime.rtl.setAttr(t, Runtime.Collection.from(["modules"]), this.code.uses);
		}
		/* Enable debug */
		t = t.setFlag("DEBUG_COMPONENT", true);
		/* Return */
		return t;
	},
	/**
	 * Build code
	 */
	buildContent: function()
	{
		var t = new BayLang.LangBay.TranslatorBay();
		var res = t.constructor.translate(t, this.code, false);
		return res.get(1);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.page_model = null;
		this.code = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor,
{
	/**
	 * Is component
	 */
	isComponent: function(tag_name)
	{
		var ch1 = Runtime.rs.substr(tag_name, 0, 1);
		var ch2 = Runtime.rs.upper(ch1);
		return ch1 == ch2;
	},
	/**
	 * Returns op code value
	 */
	getOpCodeByValue: function(value)
	{
		if (Runtime.rtl.isString(value))
		{
			return new BayLang.OpCodes.OpString(Runtime.Map.from({"value":value}));
		}
		else if (value instanceof Runtime.Dict)
		{
			var values = Runtime.Vector.from([]);
			var keys = value.keys();
			for (var i = 0; i < keys.count(); i++)
			{
				var key = keys.get(i);
				values.push(new BayLang.OpCodes.OpDictPair(Runtime.Map.from({"key":key,"value":this.getOpCodeByValue(value.get(key))})));
			}
			return new BayLang.OpCodes.OpDict(Runtime.Map.from({"values":values}));
		}
		else if (Runtime.rtl.is_instanceof(value, "Runtime.Collection"))
		{
			return new BayLang.OpCodes.OpCollection(Runtime.Map.from({"values":value.map((value) =>
			{
				return this.getOpCodeByValue(value);
			})}));
		}
		return null;
	},
	/**
	 * Returns op code value
	 */
	getValueFromOpCode: function(op_attr)
	{
		if (op_attr instanceof BayLang.OpCodes.OpString)
		{
			return op_attr.value;
		}
		else if (op_attr instanceof BayLang.OpCodes.OpDict)
		{
			var result = Runtime.Map.from({});
			for (var i = 0; i < op_attr.values.count(); i++)
			{
				var op_dict_item = op_attr.values.get(i);
				var key = op_dict_item.key;
				var item = op_dict_item.value;
				result.set(key, this.getValueFromOpCode(item));
			}
			return result;
		}
		else if (op_attr instanceof BayLang.OpCodes.OpCollection)
		{
			return op_attr.values.map((value) =>
			{
				return this.getValueFromOpCode(value);
			});
		}
		return null;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor);
window["BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor"] = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Processor == 'undefined') BayLang.Constructor.Frontend.Editor.Processor = {};
BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor = function()
{
	BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype);
BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor.prototype.constructor = BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor;
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor.prototype,
{
	/**
	 * Setup op code
	 */
	setupOpCode: function(code)
	{
		BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype.setupOpCode.call(this, code);
		/* Process op_code attrs */
		var op_code_render = this.findFunction("render");
		if (!op_code_render)
		{
			return ;
		}
		/* Process attributes */
		var op_code_expression = op_code_render.getExpression();
		this.page_model.attribute_processor.processHtmlItems(op_code_expression);
		this.page_model.attribute_processor.initWidgetInc();
		/* Set main widget */
		if (op_code_expression && op_code_expression instanceof BayLang.OpCodes.OpHtmlItems)
		{
			var op_code = op_code_expression.items.get(0);
			this.page_model.main_widget = this.page_model.widget_manager.addMain(op_code);
		}
	},
	/**
	 * Get styles op_code
	 */
	getStyleOpCode: function()
	{
		if (!this.code)
		{
			return null;
		}
		var op_code_class = this.code.findClass();
		if (!op_code_class)
		{
			return null;
		}
		return op_code_class.items.filter(Runtime.lib.isInstance("BayLang.OpCodes.OpHtmlStyle"));
	},
	/**
	 * Returns app content
	 */
	buildAppContent: function()
	{
		var translator = BayLang.LangUtils.createTranslator("bay");
		var content = BayLang.LangUtils.translate(translator, this.code);
		return content;
	},
	/**
	 * Build render function
	 */
	buildRenderContent: function(render_name)
	{
		if (render_name == undefined) render_name = "render";
		var op_code_render = this.findFunction(render_name);
		if (!op_code_render)
		{
			return "";
		}
		/* Create translator */
		var t = this.createTranslator();
		var save_op_codes = t.save_op_codes;
		/* Translate expression */
		var res = t.expression.constructor.OpDeclareFunction(t, op_code_render, false);
		t = res.get(0);
		/* Output save op code */
		var content = "";
		var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
		if (save != "")
		{
			content += Runtime.rtl.toStr(save);
		}
		content += Runtime.rtl.toStr(res.get(1));
		content = t.program.constructor.removeContext(content);
		content = Runtime.rs.trim(content);
		return content;
	},
	/**
	 * Add default template
	 */
	addDefaultTemplate: function(op_code, widget_name, template_content)
	{
		/* Parse default template */
		var default_template = null;
		var parser = this.createParser();
		try
		{
			var res = parser.constructor.parse(parser, template_content);
			parser = res.get(0);
			default_template = res.get(1);
		}
		catch (_ex)
		{
			if (true)
			{
				var e = _ex;
			}
			else
			{
				throw _ex;
			}
		}
		/* If default template is correct */
		if (!default_template)
		{
			return ;
		}
		/* Add default CSS */
		var op_code_class = default_template.findClass();
		if (op_code_class)
		{
			var op_code_style = op_code_class.items.findItem(Runtime.lib.isInstance("BayLang.OpCodes.OpHtmlStyle"));
			if (op_code_style)
			{
				this.page_model.styles.setSelectorContent("." + Runtime.rtl.toStr(widget_name), op_code_style.content);
			}
		}
		/* Add uses */
		var modules = default_template.uses.keys();
		for (var i = 0; i < default_template.items.count(); i++)
		{
			var item = default_template.items.get(i);
			if (item instanceof BayLang.OpCodes.OpUse)
			{
				this.addModule(item.name, item.alias, item.is_component);
			}
		}
		/* Find class from default_template */
		var op_code_class = default_template.findClass();
		if (!op_code_class)
		{
			return ;
		}
		/* Find render */
		var op_code_render = op_code_class.findFunction("render");
		if (!op_code_render)
		{
			return ;
		}
		if (!op_code_render.expression)
		{
			return ;
		}
		if (!(op_code_render.expression instanceof BayLang.OpCodes.OpHtmlItems))
		{
			return ;
		}
		/* Add items */
		op_code.items = op_code_render.expression;
	},
	/**
	 * Create widget
	 */
	createWidget: function(widget_settings, widget_name)
	{
		if (widget_name == undefined) widget_name = "widget";
		/* Default widget name */
		if (widget_name == "")
		{
			widget_name = "widget";
		}
		/* Get component class name */
		var class_name = widget_settings.getComponentName();
		var alias_name = class_name;
		/* Add module */
		if (this.constructor.isComponent(class_name))
		{
			alias_name = this.addModule(class_name, widget_settings.getAliasName(), true);
		}
		/* Create op_code */
		var key_debug = this.page_model.attribute_processor.createKeyName("widget");
		var op_code = new BayLang.OpCodes.OpHtmlTag(Runtime.Map.from({"attrs":Runtime.Vector.from([new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":"class","value":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":widget_name}))})),new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":"@key_debug","value":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":key_debug}))}))]),"items":new BayLang.OpCodes.OpHtmlItems(),"tag_name":alias_name}));
		/* Get default template */
		var template_info = widget_settings.getDefaultTemplate();
		var template_factory = template_info.get("default");
		if (!template_factory)
		{
			return op_code;
		}
		/* Get template content */
		var template_info = template_factory();
		var template_content = "<class>" + Runtime.rtl.toStr(template_info.get("content")) + Runtime.rtl.toStr("</class>");
		/* Add default template */
		this.addDefaultTemplate(op_code, widget_name, template_content);
		/* Add op_code attrs */
		this.page_model.attribute_processor.processHtmlTag(op_code, widget_name);
		return op_code;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor, BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor);
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor);
window["BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor"] = BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Processor == 'undefined') BayLang.Constructor.Frontend.Editor.Processor = {};
BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor = function()
{
	BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype);
BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor.prototype.constructor = BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor;
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor.prototype,
{
	/**
	 * Setup op code
	 */
	setupOpCode: function(code)
	{
		BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.prototype.setupOpCode.call(this, code);
	},
	/**
	 * Setup widget
	 */
	setupWidget: function(widget)
	{
		/* Setup settings */
		this.setupSettings(widget);
		/* Setup params */
		this.setupParams(widget);
		/* Setup model settings */
		if (widget.model_settings && Runtime.rtl.exists(widget.model_settings.setup))
		{
			widget.model_settings.setup(new Runtime.rtl(), widget);
		}
	},
	/**
	 * Setup settings
	 */
	setupSettings: function(widget)
	{
		widget.model_codes = Runtime.Vector.from([]);
		widget.model_class_name = null;
		widget.primary_model_code = null;
		widget.is_model = this.checkIsModel(widget);
		if (!widget.is_model)
		{
			return ;
		}
		/* Get model codes */
		this.setupModelCodes(widget);
		/* Get model settings */
		var editor = this.page_model.getFrameEditor();
		widget.model_settings = editor.getModelSettings(widget);
	},
	/**
	 * Check is model
	 */
	checkIsModel: function(widget)
	{
		var attrs = widget.code.attrs;
		if (attrs)
		{
			for (var i = 0; i < attrs.count(); i++)
			{
				var attr = attrs.get(i);
				if (attr.key == "@model")
				{
					return true;
				}
			}
		}
		return false;
	},
	/**
	 * Create init widget function
	 */
	createInitWidget: function()
	{
		var init_op_code = this.findFunction("initWidget");
		if (init_op_code)
		{
			return init_op_code;
		}
		var op_code_class = this.code.findClass();
		if (!op_code_class)
		{
			return null;
		}
		/* Create initWidget */
		var init_op_code = new BayLang.OpCodes.OpDeclareFunction(Runtime.Map.from({"name":"initWidget","args":Runtime.Vector.from([new BayLang.OpCodes.OpDeclareFunctionArg(Runtime.Map.from({"name":"params","pattern":new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"names":Runtime.Vector.from(["Dict"])}))}))}))]),"flags":new BayLang.OpCodes.OpFlags(),"result_type":new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"names":Runtime.Vector.from(["void"])}))})),"items":new BayLang.OpCodes.OpItems(Runtime.Map.from({"items":Runtime.Vector.from([new BayLang.OpCodes.OpCall(Runtime.Map.from({"args":Runtime.Vector.from([new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":"var","value":"params"}))]),"obj":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":"classref","value":"parent"}))}))])}))}));
		/* Add initWidget */
		op_code_class.functions.push(init_op_code);
		op_code_class.items.push(init_op_code);
		return init_op_code;
	},
	/**
	 * Setup to widget model codes
	 */
	setupModelCodes: function(widget)
	{
		var init_op_code = this.findFunction("initWidget");
		if (!init_op_code)
		{
			return Runtime.Vector.from([]);
		}
		/* Get widget name */
		var widget_name = widget.getName();
		for (var i = 0; i < init_op_code.items.items.count(); i++)
		{
			var op_code = init_op_code.items.items.get(i);
			/* Detect primary code */
			if (op_code instanceof BayLang.OpCodes.OpAssign)
			{
				var op_code_item = op_code.values.get(0);
				if (this.constructor.isPrimaryCode(op_code_item, widget_name))
				{
					widget.primary_model_code = op_code_item;
				}
			}
		}
		/* Set model class name */
		if (widget.primary_model_code)
		{
			var op_code_model_name = widget.primary_model_code.expression.args.get(0);
			if (op_code_model_name instanceof BayLang.OpCodes.OpClassOf)
			{
				widget.model_class_name = this.code.uses.get(op_code_model_name.entity_name.names.get(0));
			}
			else if (op_code_model_name instanceof BayLang.OpCodes.OpString)
			{
				widget.model_class_name = op_code_model_name.value;
			}
		}
	},
	/**
	 * Setup model params
	 */
	setupParams: function(widget)
	{
		if (!widget.model_class_name)
		{
			return ;
		}
		if (!widget.primary_model_code)
		{
			return ;
		}
		if (!widget.model_settings)
		{
			return ;
		}
		/* Add params */
		widget.params.appendItems(widget.model_settings.getParams().map((factory) =>
		{
			var param = factory.factory(new Runtime.rtl());
			param.widget = widget;
			return param;
		}));
		/* Get values */
		var op_dict = widget.primary_model_code.expression.args.get(1);
		if (!op_dict)
		{
			return ;
		}
		if (!(op_dict instanceof BayLang.OpCodes.OpDict))
		{
			return ;
		}
		/* Add params values */
		var values = op_dict.values;
		for (var i = 0; i < values.count(); i++)
		{
			var op_dict_pair = values.get(i);
			for (var j = 0; j < widget.params.count(); j++)
			{
				var param = widget.params.get(j);
				if (param instanceof BayLang.Constructor.Frontend.Editor.Parameters.ParameterModel && param.isOpCode(op_dict_pair))
				{
					param.setOpCode(op_dict_pair);
				}
			}
		}
	},
	/**
	 * Set widget name
	 */
	setWidgetName: function(widget, new_widget_name)
	{
		if (!widget.primary_model_code)
		{
			return ;
		}
		/* Set name */
		var old_widget_name = widget.primary_model_code.op_code.value.value;
		widget.primary_model_code.op_code.value.value = new_widget_name;
		/* Get dict */
		var op_dict = widget.primary_model_code.expression.args.get(1);
		if (!op_dict)
		{
			return ;
		}
		if (!(op_dict instanceof BayLang.OpCodes.OpDict))
		{
			return ;
		}
		/* Set assign name */
		var model_class_op_code = this.code.findClass();
		if (model_class_op_code)
		{
			for (var i = 0; i < model_class_op_code.items.count(); i++)
			{
				var op_code = model_class_op_code.items.get(i);
				if (op_code instanceof BayLang.OpCodes.OpAssign)
				{
					var op_assign_value = op_code.values.get(0);
					if (op_assign_value && op_assign_value.var_name == old_widget_name)
					{
						op_assign_value.var_name = new_widget_name;
					}
				}
			}
		}
		/* Set widget name */
		var values = op_dict.values;
		for (var i = 0; i < values.count(); i++)
		{
			var op_dict_pair = values.get(i);
			if (op_dict_pair.key != "widget_name")
			{
				continue;
			}
			op_dict_pair.value = this.constructor.getOpCodeByValue(new_widget_name);
		}
		/* Change attr model name */
		if (widget.code.attrs)
		{
			for (var i = 0; i < widget.code.attrs.count(); i++)
			{
				var op_code_attr = widget.code.attrs.get(i);
				if (op_code_attr.key == "@model")
				{
					op_code_attr.value.value.value = new_widget_name;
				}
			}
		}
	},
	/**
	 * Build primary content
	 */
	buildPrimaryContent: function(widget)
	{
		if (!widget.primary_model_code)
		{
			return "";
		}
		var content = "";
		try
		{
			/* Create translator */
			var t = this.createTranslator();
			var save_op_codes = t.save_op_codes;
			/* Translate expression */
			var res = t.expression.constructor.Expression(t, widget.primary_model_code.expression);
			t = res.get(0);
			/* Output save op code */
			var save = t.constructor.outputSaveOpCode(t, save_op_codes.count());
			if (save != "")
			{
				content += Runtime.rtl.toStr(save);
			}
			content += Runtime.rtl.toStr(res.get(1));
			content = t.program.constructor.removeContext(content);
			content = Runtime.rs.trim(content);
		}
		catch (_ex)
		{
			if (true)
			{
				var e = _ex;
			}
			else
			{
				throw _ex;
			}
		}
		return content;
	},
	/**
	 * Create primary code
	 */
	createPrimaryCode: function(widget)
	{
		/* Get default template */
		var template_info = widget.model_settings.getDefaultTemplate();
		var template_factory = template_info.get("default");
		if (!template_factory)
		{
			return ;
		}
		/* Get primary model content */
		var template_info = template_factory();
		var primary_model_content = template_info.get("model");
		if (primary_model_content == null)
		{
			return ;
		}
		/* Add modules */
		if (template_info.has("modules"))
		{
			var modules = template_info.get("modules");
			for (var i = 0; i < modules.count(); i++)
			{
				var module_name = modules.get(i);
				this.addModule(module_name);
			}
		}
		/* Parse default template */
		var primary_model_code = null;
		var parser = this.createParser();
		try
		{
			parser = parser.constructor.setContent(parser, primary_model_content);
			var res = parser.parser_operator.constructor.readAssign(parser);
			parser = res.get(0);
			primary_model_code = res.get(1);
		}
		catch (_ex)
		{
			if (true)
			{
				var e = _ex;
				
				throw e
			}
			else
			{
				throw _ex;
			}
		}
		return primary_model_code;
	},
	/**
	 * Add primary code
	 */
	addPrimaryCode: function(widget)
	{
		if (widget.primary_model_code)
		{
			return ;
		}
		var init_op_code = this.findFunction("initWidget");
		if (!init_op_code)
		{
			init_op_code = this.createInitWidget();
		}
		var primary_model_code = this.createPrimaryCode(widget);
		if (!primary_model_code)
		{
			return ;
		}
		/* Add primary model code */
		widget.primary_model_code = primary_model_code.values.get(0);
		init_op_code.items.items.push(primary_model_code);
	},
	/**
	 * Add assign model code
	 */
	addAssignCode: function(widget)
	{
		var model_class_op_code = this.code.findClass();
		if (!model_class_op_code)
		{
			return null;
		}
		/* Add module */
		var alias_name = this.code.findModule(widget.model_class_name);
		var widget_name = widget.getName();
		/* Assign code */
		var op_code_assign = new BayLang.OpCodes.OpAssign(Runtime.Map.from({"pattern":new BayLang.OpCodes.OpTypeIdentifier(Runtime.Map.from({"entity_name":new BayLang.OpCodes.OpEntityName(Runtime.Map.from({"names":Runtime.Vector.from([alias_name])}))})),"values":Runtime.Vector.from([new BayLang.OpCodes.OpAssignValue(Runtime.Map.from({"var_name":widget_name,"expression":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":"const","value":"null"}))}))])}));
		/* Add variable */
		var insert_pos = -1;
		for (var i = 0; i < model_class_op_code.items.count(); i++)
		{
			var op_code = model_class_op_code.items.get(i);
			if (op_code instanceof BayLang.OpCodes.OpAssign)
			{
				insert_pos = i;
			}
		}
		model_class_op_code.items.add(op_code_assign, insert_pos);
	},
	/**
	 * Add model attribute
	 */
	addModelAttribute: function(widget)
	{
		var op_code_attr = new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":"@model","value":new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":"attr","obj":new BayLang.OpCodes.OpAttr(Runtime.Map.from({"kind":"attr","obj":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":"classref","value":"this"})),"value":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"kind":"var","value":"model"}))})),"value":new BayLang.OpCodes.OpIdentifier(Runtime.Map.from({"value":widget.getName()}))}))}));
		widget.code.attrs.push(op_code_attr);
	},
	/**
	 * Create model
	 */
	createModel: function(widget)
	{
		/* Get editor */
		var editor = this.page_model.getFrameEditor();
		/* Set model settings */
		widget.model_class_name = widget.settings.getModelName();
		widget.model_settings = editor.getModelSettings(widget);
		if (!widget.model_settings)
		{
			return ;
		}
		if (!widget.getName())
		{
			return ;
		}
		/* Add module */
		this.addModule(widget.model_class_name, widget.model_settings.getAliasName());
		/* Add assign model code */
		this.addAssignCode(widget);
		/* Add primary model code */
		this.addPrimaryCode(widget);
		/* Add model attribute */
		this.addModelAttribute(widget);
		/* Set widget name */
		this.setWidgetName(widget, widget.getName());
	},
	/**
	 * Remove primary code
	 */
	removePrimaryCode: function(widget)
	{
		if (!widget.primary_model_code)
		{
			return ;
		}
		var init_op_code = this.findFunction("initWidget");
		if (!init_op_code)
		{
			return ;
		}
		/* Remove item */
		var widget_name = widget.getName();
		for (var i = init_op_code.items.items.count() - 1; i >= 0; i--)
		{
			var op_code = init_op_code.items.items.get(i);
			if (op_code instanceof BayLang.OpCodes.OpAssign && op_code.values.count() > 0)
			{
				var op_code_assign = op_code.values.get(0);
				if (this.constructor.isPrimaryCode(op_code_assign, widget_name))
				{
					init_op_code.items.items.remove(i);
				}
			}
		}
	},
	/**
	 * Add class model
	 */
	removeClassModel: function(widget)
	{
		var model_class_op_code = this.code.findClass();
		if (!model_class_op_code)
		{
			return null;
		}
		/* Remove item */
		var widget_name = widget.getName();
		for (var i = model_class_op_code.items.count() - 1; i >= 0; i--)
		{
			var op_code = model_class_op_code.items.get(i);
			if (op_code instanceof BayLang.OpCodes.OpAssign && op_code.values.count() > 0)
			{
				var op_code_assign = op_code.values.get(0);
				if (op_code_assign.var_name == widget_name)
				{
					model_class_op_code.items.remove(i);
				}
			}
		}
	},
	/**
	 * Remove model
	 */
	removeModel: function(widget)
	{
		if (!widget.model_settings)
		{
			return ;
		}
		this.removeClassModel(widget);
		this.removePrimaryCode(widget);
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor, BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor);
Object.assign(BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor,
{
	/**
	 * Returns true if primary code
	 */
	isPrimaryCode: function(op_code, widget_name)
	{
		if (!(op_code instanceof BayLang.OpCodes.OpAssignValue))
		{
			return false;
		}
		if (!(op_code.expression instanceof BayLang.OpCodes.OpCall))
		{
			return false;
		}
		if (!(op_code.op_code instanceof BayLang.OpCodes.OpAttr))
		{
			return false;
		}
		if (!(op_code.op_code.obj instanceof BayLang.OpCodes.OpIdentifier))
		{
			return false;
		}
		if (!(op_code.op_code.value instanceof BayLang.OpCodes.OpIdentifier))
		{
			return false;
		}
		if (!(op_code.expression.obj instanceof BayLang.OpCodes.OpAttr))
		{
			return false;
		}
		if (!(op_code.expression.obj.obj instanceof BayLang.OpCodes.OpIdentifier))
		{
			return false;
		}
		if (!(op_code.expression.obj.value instanceof BayLang.OpCodes.OpIdentifier))
		{
			return false;
		}
		if (op_code.op_code.obj.value != "this")
		{
			return false;
		}
		if (op_code.op_code.value.value != widget_name)
		{
			return false;
		}
		if (op_code.expression.obj.obj.value != "this")
		{
			return false;
		}
		if (op_code.expression.obj.value.value != "addWidget")
		{
			return false;
		}
		if (op_code.expression.args.count() != 2)
		{
			return false;
		}
		if (!(op_code.expression.args.get(0) instanceof BayLang.OpCodes.OpClassOf) && !(op_code.expression.args.get(0) instanceof BayLang.OpCodes.OpString))
		{
			return false;
		}
		if (!(op_code.expression.args.get(1) instanceof BayLang.OpCodes.OpDict))
		{
			return false;
		}
		return true;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor);
window["BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor"] = BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Styles == 'undefined') BayLang.Constructor.Frontend.Editor.Styles = {};
BayLang.Constructor.Frontend.Editor.Styles.Selector = function()
{
	Runtime.BaseObject.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Styles.Selector.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Styles.Selector.prototype.constructor = BayLang.Constructor.Frontend.Editor.Styles.Selector;
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.Selector.prototype,
{
	/**
	 * Build content
	 */
	buildContent: function()
	{
		var items = Runtime.Vector.from([]);
		var keys = this.styles.keys().sort();
		for (var i = 0; i < keys.count(); i++)
		{
			var key = keys.get(i);
			var value = this.styles.get(key);
			items.push(key + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(value.buildValue()));
		}
		items.push(this.css_ignore);
		var source = Runtime.rs.join(";\n", items);
		return Runtime.rs.trim(source);
	},
	/**
	 * Create style
	 */
	createStyle: function(key)
	{
		var value;
		if (key == "background-image")
		{
			value = new BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage();
		}
		else
		{
			value = new BayLang.Constructor.Frontend.Editor.Styles.StyleItem();
		}
		value.key = key;
		return value;
	},
	/**
	 * Returns style
	 */
	getStyle: function(key)
	{
		if (!this.styles.has(key))
		{
			return null;
		}
		return this.styles.get(key);
	},
	/**
	 * Set style value
	 */
	setStyleValue: function(key, value)
	{
		value = Runtime.rs.trim(value);
		if (value != "")
		{
			/* Get CSS Value */
			var css_value = this.getStyle(key);
			if (!css_value)
			{
				css_value = this.createStyle(key);
				this.styles.set(css_value.key, css_value);
			}
			/* Set CSS Value */
			css_value.setValue(value);
		}
		else
		{
			/* Remove style item */
			if (this.styles.has(key))
			{
				this.styles.remove(key);
			}
		}
		/* Update source */
		var source = this.buildContent();
		this.setContent(source, false);
	},
	/**
	 * Change style value
	 */
	changeStyleValue: function(key, value)
	{
		/* Set CSS Value */
		this.setStyleValue(key, value);
		/* Update CSS */
		this.parent_widget.parent_widget.updateFrameCSS();
	},
	/**
	 * Parse styles
	 */
	parseStyles: function()
	{
		var content = this.source;
		/* Create parser */
		var component_processor = this.parent_widget.parent_widget.component_processor;
		var parser = component_processor.createParser();
		parser = parser.constructor.setContent(parser, content);
		/* Parse CSS */
		var res = this.constructor.parseCSS(parser, content);
		/* CSS Values */
		this.styles = Runtime.Map.from({});
		var items = Runtime.rs.split(";", res.get(0));
		for (var i = 0; i < items.count(); i++)
		{
			var item = items.get(i);
			var pos = Runtime.rs.indexOf(item, ":");
			if (pos == -1)
			{
				continue;
			}
			var item_key = Runtime.rs.trim(Runtime.rs.substr(item, 0, pos));
			var item_value = Runtime.rs.trim(Runtime.rs.substr(item, pos + 1));
			var value = this.createStyle(item_key);
			value.initValue(item_value);
			this.styles.set(value.key, value);
		}
		/* CSS Ignore */
		this.css_ignore = Runtime.rs.trim(res.get(1));
	},
	/**
	 * Set content
	 */
	setContent: function(source, parse_styles)
	{
		if (parse_styles == undefined) parse_styles = true;
		var component_processor = this.parent_widget.parent_widget.component_processor;
		var parser = component_processor.createParser();
		var translator = component_processor.createTranslator();
		/* Parse CSS */
		var css_code = this.selector_name + Runtime.rtl.toStr("{") + Runtime.rtl.toStr(source) + Runtime.rtl.toStr("}");
		var content = this.constructor.translateCSS(parser, translator, css_code);
		/* Set content */
		this.source = source;
		this.content = content;
		if (parse_styles)
		{
			this.parseStyles();
		}
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.parent_widget = null;
		this.op_code = null;
		this.selector_name = "";
		this.source = "";
		this.content = "";
		this.css_ignore = "";
		this.styles = Runtime.Map.from({});
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.Selector, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.Selector,
{
	/**
	 * Translate CSS
	 */
	translateCSS: function(parser, translator, source)
	{
		/* Parse source */
		var op_code = null;
		try
		{
			parser = parser.constructor.setContent(parser, source + Runtime.rtl.toStr("}"));
			var res = parser.parser_html.constructor.readCssBody(parser);
			op_code = res.get(1);
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserUnknownError)
			{
				var e = _ex;
			}
			else
			{
				throw _ex;
			}
		}
		/* Translate source */
		if (!op_code)
		{
			return "";
		}
		translator = Runtime.rtl.setAttr(translator, Runtime.Collection.from(["is_static_function"]), true);
		var res = translator.expression.constructor.Expression(translator, op_code);
		return res.get(1);
	},
	/**
	 * Parse CSS
	 */
	parseCSS: function(parser, content)
	{
		var caret = new BayLang.Caret(Runtime.Map.from({"content":new Runtime.Reference(content)}));
		var start = 0;
		var styles = Runtime.Vector.from([]);
		var css_ignore = Runtime.Vector.from([]);
		while (!caret.eof())
		{
			var ch = caret.nextChar();
			var ch2 = caret.nextString(2);
			if (ch == "{")
			{
				var level = 1;
				if (start != caret.pos)
				{
					var s = Runtime.rs.substr(content, start, caret.pos - start);
					css_ignore.push(s);
				}
				start = caret.pos;
				while (!caret.eof() && (ch != "}" && level == 0 || level > 0))
				{
					caret.readChar();
					ch = caret.nextChar();
					if (ch == "{")
					{
						level = level + 1;
					}
					if (ch == "}")
					{
						level = level - 1;
					}
				}
				if (start != caret.pos)
				{
					css_ignore.push(Runtime.rs.substr(content, start, caret.pos - start + 1));
				}
				if (caret.pos < caret.content_sz)
				{
					start = caret.pos + 1;
				}
			}
			else if (ch2 == "${")
			{
				/* Save caret */
				caret.matchString("${");
				parser = Runtime.rtl.setAttr(parser, Runtime.Collection.from(["caret"]), caret);
				/* Read expression */
				try
				{
					var res = parser.parser_expression.constructor.readExpression(parser);
					parser = Runtime.rtl.attr(res, 0);
				}
				catch (_ex)
				{
					if (_ex instanceof BayLang.Exceptions.ParserUnknownError)
					{
						var e = _ex;
					}
					else
					{
						throw _ex;
					}
				}
				/* Restore caret */
				caret = parser.getCaret();
				caret.skipSpace();
				if (caret.isNextChar("}"))
				{
					caret.matchChar("}");
				}
			}
			else if (ch == ";")
			{
				caret.readChar();
				var s = Runtime.rs.substr(content, start, caret.pos - start);
				styles.push(s);
				start = caret.pos;
			}
			else
			{
				caret.readChar();
			}
		}
		if (start != caret.pos)
		{
			styles.push(Runtime.rs.substr(content, start, caret.pos - start));
		}
		return Runtime.Vector.from([Runtime.rs.join("", styles),Runtime.rs.join("", css_ignore)]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.Selector";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Styles.Selector);
window["BayLang.Constructor.Frontend.Editor.Styles.Selector"] = BayLang.Constructor.Frontend.Editor.Styles.Selector;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Styles.Selector;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Styles == 'undefined') BayLang.Constructor.Frontend.Editor.Styles = {};
BayLang.Constructor.Frontend.Editor.Styles.StyleItem = function()
{
};
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.StyleItem.prototype,
{
	/**
	 * Build value
	 */
	buildValue: function()
	{
		return this.value;
	},
	/**
	 * Init value
	 */
	initValue: function(value)
	{
		this.value = value;
	},
	/**
	 * Set value
	 */
	setValue: function(value)
	{
		this.value = value;
	},
	/**
	 * Returns value
	 */
	getValue: function()
	{
		return this.value;
	},
	_init: function()
	{
		this.key = "";
		this.value = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.StyleItem,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.StyleItem";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Styles.StyleItem);
window["BayLang.Constructor.Frontend.Editor.Styles.StyleItem"] = BayLang.Constructor.Frontend.Editor.Styles.StyleItem;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Styles.StyleItem;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Styles == 'undefined') BayLang.Constructor.Frontend.Editor.Styles = {};
BayLang.Constructor.Frontend.Editor.Styles.Styles = {
	name: "BayLang.Constructor.Frontend.Editor.Styles.Styles",
	extends: Runtime.Web.Component,
	data: function ()
	{
		return {
			old_selector_name: "",
			add_dialog: new Runtime.Widget.Dialog.PromptDialogModel(Runtime.Map.from({"widget_name":"add_dialog","confirm_button":"Add","title":"Add new style","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onAddStyle")})})),
			edit_dialog: new Runtime.Widget.Dialog.PromptDialogModel(Runtime.Map.from({"widget_name":"edit_dialog","confirm_button":"Rename","title":"Rename style","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onRenameStyle")})})),
			delete_dialog: new Runtime.Widget.Dialog.ConfirmDialogModel(Runtime.Map.from({"widget_name":"delete_dialog","confirm_button":"Delete","title":"Delete style","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onDeleteStyle")})})),
		};
	},
	methods:
	{
		renderStyle: function(selector_name)
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_style"]),"key":selector_name});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_style__name"])});
			
			/* Element 'div' */
			let __v2 = this._e(__v1, "div", {"class":this._class_name(["widget_style__label"])});
			
			/* Render */
			this._t(__v2, selector_name);
			
			/* Element 'div' */
			let __v3 = this._e(__v1, "div", {"onClick":() =>
			{
				this.onEditClick(selector_name);
			},"class":this._class_name(["widget_style__button"])});
			
			/* Text */
			this._t(__v3, "[Edit]");
			
			/* Element 'div' */
			let __v4 = this._e(__v1, "div", {"onClick":() =>
			{
				this.onDeleteClick(selector_name);
			},"class":this._class_name(["widget_style__button"])});
			
			/* Text */
			this._t(__v4, "[Delete]");
			
			/* Element 'div' */
			let __v5 = this._e(__v0, "div", {"class":this._class_name(["widget_style__content"])});
			
			/* Component 'TextEditable' */
			let __v6 = this._c(__v5, "Runtime.Widget.TextEditable", {"name":selector_name,"value":this.model.getSelectorContent(selector_name),"onValueChange":(message) =>
			{
				this.model.changeSelectorContent(selector_name, message.value);
			},"class":this._class_name(["widget_style__editable overflow"])});
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_styles"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_styles__buttons"])});
			
			/* Component 'Button' */
			let __v2 = this._c(__v1, "Runtime.Widget.Button", {"styles":Runtime.Vector.from(["small"]),"onClick":this.onAddClick}, () => {
				let __v = [];
				
				/* Text */
				this._t(__v, "Add");
				
				return this._flatten(__v);
			});
			
			/* Element 'div' */
			let __v3 = this._e(__v0, "div", {"class":this._class_name(["widget_styles__items"])});
			let keys = this.model.selectors.keys().sort();
			
			for (let i = 0; i < keys.count(); i++)
			{
				/* Render */
				this._t(__v3, this.renderStyle(keys.get(i)));
			}
			
			/* Render */
			this._t(__v0, this.renderWidget(this.add_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.edit_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.delete_dialog));
			
			return this._flatten(__v);
		},
		/**
 * Add dialog
 */
		onAddClick: function()
		{
			this.add_dialog.setValue("");
			this.add_dialog.show();
		},
		/**
 * Edit click
 */
		onEditClick: function(selector_name)
		{
			this.old_selector_name = selector_name;
			this.edit_dialog.setTitle("Rename style " + Runtime.rtl.toStr(selector_name));
			this.edit_dialog.setValue(selector_name);
			this.edit_dialog.show();
		},
		/**
 * Delete click
 */
		onDeleteClick: function(selector_name)
		{
			this.old_selector_name = selector_name;
			this.delete_dialog.setTitle("Delete style " + Runtime.rtl.toStr(selector_name));
			this.delete_dialog.show();
		},
		/**
 * Add style
 */
		onAddStyle: function(message)
		{
			var selector_name = message.value;
			if (Runtime.rs.charAt(selector_name, 0) != ".")
			{
				selector_name = "." + Runtime.rtl.toStr(selector_name);
			}
			if (this.model.selectors.has(selector_name))
			{
				throw new Runtime.Widget.Dialog.DialogModelException("selector " + Runtime.rtl.toStr(selector_name) + Runtime.rtl.toStr(" allready exists"))
			}
			this.model.changeSelectorContent(selector_name, "");
		},
		/**
 * Rename style
 */
		onRenameStyle: function(message)
		{
			var new_selector_name = message.value;
			if (Runtime.rs.charAt(new_selector_name, 0) != ".")
			{
				new_selector_name = "." + Runtime.rtl.toStr(new_selector_name);
			}
			if (this.model.selectors.has(new_selector_name))
			{
				throw new Runtime.Widget.Dialog.DialogModelException(new_selector_name + Runtime.rtl.toStr(" allready exists"))
				return ;
			}
			/* Rename style */
			var css_content = this.model.getSelectorContent(this.old_selector_name);
			this.model.selectors.remove(this.old_selector_name);
			this.model.changeSelectorContent(new_selector_name, css_content);
		},
		/**
 * Delete style
 */
		onDeleteStyle: function()
		{
			this.model.changeSelectorContent(this.old_selector_name, "");
			this.model.selectors.remove(this.old_selector_name);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.Styles,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Button","Runtime.Widget.TextEditable","Runtime.Widget.Dialog.PromptDialog"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_styles__buttons.h-f84f{padding-bottom: 5px}.widget_styles__items.h-f84f{border: 1px var(--widget-color-border) solid;border-bottom: 0px}.widget_style__name.h-f84f{display: flex;padding: 5px;gap: 5px;background-color: aliceblue;border-bottom: 1px var(--widget-color-border) solid;width: 100%}.widget_style__label.h-f84f{flex: 1;overflow-wrap: anywhere}.widget_style__button.h-f84f{cursor: pointer;font-size: 12px}.widget_style__button.h-f84f:hover{text-decoration: underline}.widget_style__name.h-f84f:hover .widget_style__button{display: block}.widget_style__content.h-f84f{padding: 5px;border-bottom: 1px var(--widget-color-border) solid}.widget_style__editable.h-f84f{border: 0;padding: 10px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.Styles";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Styles.Styles);
window["BayLang.Constructor.Frontend.Editor.Styles.Styles"] = BayLang.Constructor.Frontend.Editor.Styles.Styles;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Styles.Styles;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Styles == 'undefined') BayLang.Constructor.Frontend.Editor.Styles = {};
BayLang.Constructor.Frontend.Editor.Styles.StylesModel = function()
{
	Runtime.Web.BaseModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Styles.StylesModel.prototype = Object.create(Runtime.Web.BaseModel.prototype);
BayLang.Constructor.Frontend.Editor.Styles.StylesModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.Styles.StylesModel;
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.StylesModel.prototype,
{
	/**
	 * Returns CSS content
	 */
	getCSS: function()
	{
		var items = Runtime.Vector.from([]);
		var selectors = this.selectors.keys().sort();
		for (var i = 0; i < selectors.count(); i++)
		{
			var selector_name = selectors.get(i);
			var item = this.selectors.get(selector_name);
			items.push(item.content);
		}
		return items;
	},
	/**
	 * Returns selector by selector name
	 */
	getSelector: function(selector_name)
	{
		if (!this.selectors.has(selector_name))
		{
			return null;
		}
		return this.selectors.get(selector_name);
	},
	/**
	 * Returns selector content
	 */
	getSelectorContent: function(selector_name)
	{
		if (!this.selectors.has(selector_name))
		{
			return "";
		}
		return this.selectors.get(selector_name).source;
	},
	/**
	 * Create style item
	 */
	createSelector: function(selector_name, op_code)
	{
		if (op_code == undefined) op_code = null;
		if (op_code == null)
		{
			op_code = this.main_style_code;
		}
		var selector = new BayLang.Constructor.Frontend.Editor.Styles.Selector();
		selector.op_code = op_code;
		selector.selector_name = selector_name;
		selector.parent_widget = this;
		this.selectors.set(selector_name, selector);
		return selector;
	},
	/**
	 * Set css content
	 */
	setSelectorContent: function(selector_name, source, op_code)
	{
		if (op_code == undefined) op_code = null;
		/* Default item */
		if (op_code == null)
		{
			op_code = this.main_style_code;
		}
		/* Create style item if does not exists */
		if (!this.selectors.has(selector_name))
		{
			this.createSelector(selector_name, op_code);
		}
		/* Set content */
		var selector = this.selectors.get(selector_name);
		selector.setContent(source);
	},
	/**
	 * Change css content
	 */
	changeSelectorContent: function(selector_name, value)
	{
		/* Set CSS Value */
		this.setSelectorContent(selector_name, value);
		/* Update CSS */
		this.parent_widget.updateFrameCSS();
	},
	/**
	 * Clear styles
	 */
	clear: function()
	{
		this.selectors = Runtime.Map.from({});
	},
	/**
	 * Setup styles
	 */
	setupStyles: function(op_code)
	{
		var op_code_class = op_code.findClass();
		if (!op_code_class)
		{
			return ;
		}
		/* Add styles */
		for (var i = 0; i < op_code_class.items.count(); i++)
		{
			var item = op_code_class.items.get(i);
			if (item instanceof BayLang.OpCodes.OpHtmlStyle)
			{
				this.addHtmlStyle(item);
			}
		}
		/* Add style if not exists */
		if (this.main_style_code == null)
		{
			this.createMainHtmlStyle(op_code);
		}
	},
	/**
	 * Create main HTML Style
	 */
	createMainHtmlStyle: function(op_code)
	{
		if (this.main_style_code != null)
		{
			return ;
		}
		var op_code_class = op_code.findClass();
		if (!op_code_class)
		{
			return ;
		}
		/* Create main style code */
		this.main_style_code = new BayLang.OpCodes.OpHtmlStyle(Runtime.Map.from({"value":new BayLang.OpCodes.OpString(Runtime.Map.from({"value":""}))}));
		/* Find use */
		var pos = -1;
		for (var i = 0; i < op_code.items.count(); i++)
		{
			if (op_code.items.get(i) instanceof BayLang.OpCodes.OpUse)
			{
				pos = i;
			}
		}
		/* Register main style */
		op_code_class.items.add(this.main_style_code, pos);
	},
	/**
	 * Add HTML style
	 */
	addHtmlStyle: function(op_code)
	{
		if (this.main_style_code == null)
		{
			this.main_style_code = op_code;
		}
		var styles = op_code.readStyles();
		var arr = styles.keys();
		for (var i = 0; i < arr.count(); i++)
		{
			var selector_name = arr.get(i);
			if (this.selectors.has(selector_name))
			{
				continue;
			}
			/* Set CSS Value */
			var source = styles.get(selector_name);
			this.setSelectorContent(selector_name, source, op_code);
		}
	},
	/**
	 * Update HTML Style
	 */
	updateHtmlStyle: function(op_code)
	{
		/* Build style source */
		var source = Runtime.Vector.from([]);
		var selectors = this.selectors.keys().sort();
		for (var i = 0; i < selectors.count(); i++)
		{
			var selector_name = selectors.get(i);
			var selector = this.selectors.get(selector_name);
			if (selector.op_code != op_code)
			{
				continue;
			}
			/* Add content to source */
			source.push(selector_name + Runtime.rtl.toStr("{"));
			var lines = Runtime.rs.split("\n", selector.source);
			lines = lines.map((s) =>
			{
				return "\t" + Runtime.rtl.toStr(s);
			});
			source.appendItems(lines);
			source.push("}");
		}
		/* Set content to html style op_code */
		var content = Runtime.rs.join("\n", source);
		op_code.content = content;
		if (op_code.value instanceof BayLang.OpCodes.OpString)
		{
			op_code.value.value = content;
		}
	},
	_init: function()
	{
		Runtime.Web.BaseModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.Styles.Styles";
		this.widget_name = "styles";
		this.selectors = Runtime.Map.from({});
		this.main_style_code = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.StylesModel, Runtime.Web.BaseModel);
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.StylesModel,
{
	/**
	 * Returns source
	 */
	getCSSCode: function(selector_name, source)
	{
		return selector_name + Runtime.rtl.toStr("{") + Runtime.rtl.toStr(source) + Runtime.rtl.toStr("}");
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.StylesModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BaseModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Styles.StylesModel);
window["BayLang.Constructor.Frontend.Editor.Styles.StylesModel"] = BayLang.Constructor.Frontend.Editor.Styles.StylesModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Styles.StylesModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Styles == 'undefined') BayLang.Constructor.Frontend.Editor.Styles = {};
BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage = function()
{
	BayLang.Constructor.Frontend.Editor.Styles.StyleItem.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Styles.StyleItem.prototype);
BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage.prototype.constructor = BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage;
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage.prototype,
{
	/**
	 * Build value
	 */
	buildValue: function()
	{
		return "url(${ static::assets(\"" + Runtime.rtl.toStr(this.value) + Runtime.rtl.toStr("\")})");
	},
	/**
	 * Init value
	 */
	initValue: function(original_value)
	{
		var value = "";
		try
		{
			var reader = new BayLang.TokenReader();
			reader.init(new BayLang.Caret(Runtime.Map.from({"content":new Runtime.Reference(original_value)})));
			/* Match url expression */
			reader.matchToken("url");
			reader.matchToken("(");
			reader.matchToken("$");
			reader.matchToken("{");
			reader.matchToken("static");
			reader.matchToken(":");
			reader.matchToken(":");
			reader.matchToken("assets");
			reader.matchToken("(");
			/* Read begin of string */
			var open_string = reader.readToken();
			if (open_string != "'" && open_string != "\"")
			{
				throw new BayLang.Exceptions.ParserUnknownError("String expected", reader.main_caret)
			}
			/* Init caret */
			var caret = reader.main_caret;
			/* Read string value */
			while (!caret.eof() && !caret.isNextString(open_string))
			{
				var ch = caret.readChar();
				if (ch == "\\")
				{
					var ch2 = caret.readChar();
					if (ch2 == "n")
					{
						value += Runtime.rtl.toStr("\n");
					}
					else if (ch2 == "r")
					{
						value += Runtime.rtl.toStr("\r");
					}
					else if (ch2 == "t")
					{
						value += Runtime.rtl.toStr("\t");
					}
					else if (ch2 == "s")
					{
						value += Runtime.rtl.toStr(" ");
					}
					else if (ch2 == "\\")
					{
						value += Runtime.rtl.toStr("\\");
					}
					else if (ch2 == "'")
					{
						value += Runtime.rtl.toStr("'");
					}
					else if (ch2 == "\"")
					{
						value += Runtime.rtl.toStr("\"");
					}
					else
					{
						value += Runtime.rtl.toStr(ch + Runtime.rtl.toStr(ch2));
					}
				}
				else
				{
					value += Runtime.rtl.toStr(ch);
				}
			}
			/* Restore caret */
			reader.init(caret);
			/* Match end of expression */
			reader.matchToken(open_string);
			reader.matchToken(")");
			reader.matchToken("}");
			reader.matchToken(")");
		}
		catch (_ex)
		{
			if (_ex instanceof BayLang.Exceptions.ParserUnknownError)
			{
				var e = _ex;
			}
			else
			{
				throw _ex;
			}
		}
		this.original_value = original_value;
		this.value = value;
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Styles.StyleItem.prototype._init.call(this);
		this.original_value = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage, BayLang.Constructor.Frontend.Editor.Styles.StyleItem);
Object.assign(BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Styles.StyleItem";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage);
window["BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage"] = BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.Widget = function(page_model, code)
{
	Runtime.BaseObject.call(this);
	this.code = code;
	this.page_model = page_model;
};
BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.Widget;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype,
{
	/**
	 * Returns true if component
	 */
	isComponent: function()
	{
		return false;
	},
	/**
	 * Returns true if tag has model
	 */
	isModel: function()
	{
		return false;
	},
	/**
	 * Can insert widget
	 */
	canInsert: function(widget_settings)
	{
		return false;
	},
	/**
	 * Update tree item
	 */
	updateTreeItem: function()
	{
		if (!this.tree_item)
		{
			this.tree_item = new BayLang.Constructor.Frontend.Editor.WidgetTreeItem(this.code);
		}
		/* Update label */
		this.tree_item.updateLabel();
	},
	/**
	 * Update tree items
	 */
	updateTreeItems: function()
	{
		/* Create tree item if does not exists */
		if (!this.tree_item)
		{
			this.updateTreeItem();
		}
		/* Update items */
		this.tree_item.items = Runtime.Vector.from([]);
		if (this.code.items instanceof BayLang.OpCodes.OpHtmlItems)
		{
			for (var i = 0; i < this.code.items.count(); i++)
			{
				var op_code_item = this.code.items.get(i);
				var widget_item = this.page_model.widget_manager.get(op_code_item);
				this.tree_item.items.push(widget_item.tree_item);
			}
		}
	},
	/**
	 * Reset widget
	 */
	reset: function()
	{
		this.is_initialized = false;
		this.settings = null;
	},
	/**
	 * Setup
	 */
	setup: function()
	{
		if (this.is_initialized)
		{
			return ;
		}
		/* Setup settings */
		this.setupSettings();
		/* Setup params */
		this.setupParams();
		/* Setup attrs */
		this.setupAttrs();
		/* Init params */
		this.initParams();
		/* Set flag initialized */
		this.is_initialized = true;
	},
	/**
	 * Setup settings
	 */
	setupSettings: function()
	{
	},
	/**
	 * Setup attrs
	 */
	setupAttrs: function()
	{
	},
	/**
	 * Setup params
	 */
	setupParams: function()
	{
	},
	/**
	 * Init params
	 */
	initParams: function()
	{
		this.params.each((param) =>
		{
			param.init();
		});
		/* Setup widget settings */
		if (this.settings && Runtime.rtl.exists(this.settings.setup))
		{
			this.settings.setup(this);
		}
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.code = null;
		this.parent_code = null;
		this.page_model = null;
		this.tree_item = null;
		this.params = Runtime.Vector.from([]);
		this.settings = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.Widget, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.Widget,
{
	/**
	 * Create new instance
	 */
	newInstance: function(page_model, op_code)
	{
		if (!(op_code instanceof BayLang.OpCodes.OpHtmlTag))
		{
			return null;
		}
		var selected_tag_name = op_code.tag_name;
		if (BayLang.Constructor.Frontend.Editor.Processor.CodeProcessor.isComponent(selected_tag_name))
		{
			return new BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent(page_model, op_code);
		}
		/* Lower tag name */
		selected_tag_name = Runtime.rs.lower(selected_tag_name);
		return new BayLang.Constructor.Frontend.Editor.Widget.WidgetTag(page_model, op_code);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.Widget";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.Widget);
window["BayLang.Constructor.Frontend.Editor.Widget.Widget"] = BayLang.Constructor.Frontend.Editor.Widget.Widget;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.Widget;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.WidgetTag = function(page_model, code)
{
	BayLang.Constructor.Frontend.Editor.Widget.Widget.call(this, page_model, code);
	/* Create params */
	this.param_class_name = new BayLang.Constructor.Frontend.Editor.Parameters.ParameterClassName(Runtime.Map.from({"widget":this}));
	this.param_widget_name = new BayLang.Constructor.Frontend.Editor.Parameters.ParameterWidgetName(Runtime.Map.from({"widget":this}));
	this.param_class_name.param_widget_name = this.param_widget_name;
	this.param_widget_name.param_class_name = this.param_class_name;
	this.param_class_name.op_attr = null;
	this.param_class_name.value = Runtime.Vector.from([]);
	this.param_widget_name.op_attr = null;
	this.param_widget_name.value = "";
};
BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype);
BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.WidgetTag;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype,
{
	/**
	 * Returns widget name
	 */
	getName: function()
	{
		return this.param_widget_name.value;
	},
	/**
	 * Returns CSS Content
	 */
	getSelectorName: function()
	{
		return "." + Runtime.rtl.toStr(this.param_widget_name.value);
	},
	/**
	 * Returns selector
	 */
	getSelector: function()
	{
		var selector_name = this.getSelectorName();
		return this.page_model.styles.getSelector(selector_name);
	},
	/**
	 * Can insert widget
	 */
	canInsert: function(widget_settings)
	{
		if (!this.settings)
		{
			return false;
		}
		return this.settings.canInsert(widget_settings);
	},
	/**
	 * Setup settings
	 */
	setupSettings: function()
	{
		if (this.settings != null)
		{
			return ;
		}
		var op_code = this.code;
		/* Find component settings */
		this.settings = this.page_model.getFrameEditor().getWidgetSettings(this);
	},
	/**
	 * Setup params
	 */
	setupParams: function()
	{
		/* Clear params */
		this.params = Runtime.Vector.from([]);
		this.params.add(this.param_widget_name);
		this.params.add(this.param_class_name);
		/* Setup params from settings */
		if (this.settings)
		{
			this.params.appendItems(this.settings.getParams().map((factory) =>
			{
				var param = factory.factory(new Runtime.rtl());
				param.widget = this;
				return param;
			}));
		}
	},
	/**
	 * Setup attrs
	 */
	setupAttrs: function()
	{
		var attrs = this.code.attrs;
		if (!attrs)
		{
			return ;
		}
		/* Setup paremeters values */
		for (var i = 0; i < attrs.count(); i++)
		{
			var op_attr = attrs.get(i);
			for (var j = 0; j < this.params.count(); j++)
			{
				var param = this.params.get(j);
				if (param instanceof BayLang.Constructor.Frontend.Editor.Parameters.ParameterComponent && param.isOpCode(op_attr))
				{
					param.setOpCode(op_attr);
				}
			}
		}
		/* Create class attribute */
		if (this.param_class_name.op_attr == null)
		{
			var op_attr = new BayLang.OpCodes.OpHtmlAttribute(Runtime.Map.from({"key":"class"}));
			this.param_class_name.op_attr = op_attr;
			this.param_widget_name.op_attr = op_attr;
		}
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype._init.call(this);
		this.param_class_name = null;
		this.param_widget_name = null;
		this.is_raw = false;
		this.html_content = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag, BayLang.Constructor.Frontend.Editor.Widget.Widget);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetTag";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.Widget";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag);
window["BayLang.Constructor.Frontend.Editor.Widget.WidgetTag"] = BayLang.Constructor.Frontend.Editor.Widget.WidgetTag;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.WidgetTag;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent = function(page_model, code)
{
	BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.call(this, page_model, code);
	/* Setup component class name */
	this.component_class_name = this.page_model.component_processor.getModuleClassName(code.tag_name);
};
BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype);
BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent.prototype,
{
	/**
	 * Returns true if component
	 */
	isComponent: function()
	{
		return true;
	},
	/**
	 * Returns true if component has model
	 */
	isModel: function()
	{
		return this.is_model;
	},
	/**
	 * Return widget model
	 */
	getModel: function()
	{
		var iframe_page_model = this.page_model.getFramePageModel();
		var widget_name = this.getName();
		return iframe_page_model.widget_model.getWidget(widget_name);
	},
	/**
	 * Can insert widget
	 */
	canInsert: function(widget_settings)
	{
		if (!this.settings)
		{
			return false;
		}
		return this.settings.canInsert(widget_settings);
	},
	/**
	 * Init params
	 */
	initParams: function()
	{
		BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype.initParams.call(this);
		/* Setup widget */
		this.page_model.model_processor.setupWidget(this);
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype._init.call(this);
		this.is_model = false;
		this.model_class_name = null;
		this.component_class_name = null;
		this.primary_model_code = null;
		this.model_codes = null;
		this.model_settings = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent, BayLang.Constructor.Frontend.Editor.Widget.WidgetTag);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetTag";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent);
window["BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent"] = BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.WidgetComponent;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.WidgetMain = function()
{
	BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Widget.WidgetMain.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Widget.WidgetTag.prototype);
BayLang.Constructor.Frontend.Editor.Widget.WidgetMain.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.WidgetMain;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetMain.prototype,
{
	/**
	 * Setup settings
	 */
	setupSettings: function()
	{
		/* Setup settings */
		this.settings = this.page_model.getFrameEditor().get("Runtime.Widget.WidgetSettings.Settings.TemplateSettings");
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetMain, BayLang.Constructor.Frontend.Editor.Widget.WidgetTag);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetMain,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetMain";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetTag";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.WidgetMain);
window["BayLang.Constructor.Frontend.Editor.Widget.WidgetMain"] = BayLang.Constructor.Frontend.Editor.Widget.WidgetMain;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.WidgetMain;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.WidgetManager = function(page_model)
{
	Runtime.BaseObject.call(this);
	this.page_model = page_model;
};
BayLang.Constructor.Frontend.Editor.Widget.WidgetManager.prototype = Object.create(Runtime.BaseObject.prototype);
BayLang.Constructor.Frontend.Editor.Widget.WidgetManager.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.WidgetManager;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetManager.prototype,
{
	/**
	 * Returns widget by op_code
	 */
	get: function(op_code)
	{
		return (this.hash.has(op_code)) ? (this.hash.get(op_code)) : (null);
	},
	/**
	 * Get op_code by path
	 */
	getOpCode: function(path)
	{
		var item = this.page_model.tree.root.get(path);
		return (item) ? (item.code) : (null);
	},
	/**
	 * Get widget by path
	 */
	getWidget: function(path)
	{
		var op_code = this.getOpCode(path);
		return (op_code) ? (this.hash.get(op_code)) : (null);
	},
	/**
	 * Add op_code
	 */
	add: function(op_code)
	{
		if (!op_code)
		{
			return null;
		}
		/* Add widget to hash */
		if (!this.hash.has(op_code))
		{
			var widget = BayLang.Constructor.Frontend.Editor.Widget.Widget.newInstance(this.page_model, op_code);
			this.hash.set(op_code, widget);
		}
		/* Setup widget */
		var widget = this.hash.get(op_code);
		if (!widget)
		{
			return widget;
		}
		widget.updateTreeItem();
		return widget;
	},
	/**
	 * Add main op_code
	 */
	addMain: function(op_code)
	{
		if (!op_code)
		{
			return null;
		}
		/* Add widget to hash */
		if (!this.hash.has(op_code))
		{
			var widget = new BayLang.Constructor.Frontend.Editor.Widget.WidgetMain(this.page_model, op_code);
			this.hash.set(op_code, widget);
		}
		/* Setup widget */
		var widget = this.hash.get(op_code);
		widget.updateTreeItem();
		/* Update items */
		this.updateItems(op_code);
		return widget;
	},
	/**
	 * Update op_code items
	 */
	updateItems: function(op_code, recursive)
	{
		if (recursive == undefined) recursive = true;
		if (!op_code)
		{
			return null;
		}
		/* Add widget */
		var widget = this.add(op_code);
		if (!widget)
		{
			return null;
		}
		/* Get op_code items */
		var op_code_items = op_code.items;
		if (op_code_items == null)
		{
			return widget;
		}
		if (op_code_items.items == null)
		{
			return widget;
		}
		/* Clear tree items */
		widget.tree_item.items = Runtime.Vector.from([]);
		/* Add op_code items */
		for (var i = 0; i < op_code_items.items.count(); i++)
		{
			var new_op_code = op_code_items.items.get(i);
			var new_widget = this.add(new_op_code);
			if (new_widget)
			{
				/* Set new parent code */
				new_widget.parent_code = op_code;
				/* Add tree item */
				widget.tree_item.items.push(new_widget.tree_item);
			}
			if (recursive)
			{
				this.updateItems(new_op_code);
			}
		}
		return widget;
	},
	/**
	 * Remove op_code
	 */
	remove: function(op_code)
	{
		if (!this.hash.has(op_code))
		{
			return ;
		}
		/* Remove op_code */
		this.hash.remove(op_code);
	},
	/**
	 * Remove op_code with items
	 */
	removeItems: function(op_code, recursive)
	{
		if (recursive == undefined) recursive = true;
		var widget = this.get(op_code);
		if (!widget)
		{
			return ;
		}
		/* Get op_code items */
		var op_code_items = op_code.items;
		if (op_code_items == null)
		{
			return ;
		}
		if (op_code_items.items == null)
		{
			return ;
		}
		/* Clear tree items */
		widget.tree_item.items = Runtime.Vector.from([]);
		/* Remove widget items */
		for (var i = 0; i < op_code_items.items.count(); i++)
		{
			var op_code_item = op_code_items.items.get(i);
			this.remove(op_code_item);
			if (recursive)
			{
				this.removeItems(op_code_item);
			}
		}
	},
	/**
	 * Add new op_code to dest
	 */
	addOpCode: function(new_op_code, dest_op_code, kind)
	{
		/* Get widgets */
		var dest_widget = this.hash.get(dest_op_code);
		var parent_widget = this.hash.get(dest_widget.parent_code);
		/* Insert first */
		if (kind == "first")
		{
			parent_widget = dest_widget;
			dest_op_code = null;
			kind = "before";
		}
		else if (kind == "last")
		{
			parent_widget = dest_widget;
			dest_op_code = null;
			kind = "after";
		}
		/* Check widget exists */
		if (!parent_widget)
		{
			return -1;
		}
		/* Add item */
		var pos = parent_widget.code.items.items.addItem(new_op_code, dest_op_code, kind);
		/* Update items */
		this.add(new_op_code);
		this.updateItems(new_op_code);
		this.updateItems(parent_widget.code, false);
		return pos;
	},
	/**
	 * Move op_code
	 */
	moveOpCode: function(src_op_code, dest_op_code, kind)
	{
		/* Get widgets */
		var src_widget = this.hash.get(src_op_code);
		var dest_widget = this.hash.get(dest_op_code);
		if (!src_widget)
		{
			return ;
		}
		if (!dest_widget)
		{
			return ;
		}
		/* Get parent widget */
		var parent_src_widget = this.hash.get(src_widget.parent_code);
		var parent_dest_widget = this.hash.get(dest_widget.parent_code);
		if (!parent_src_widget)
		{
			return ;
		}
		if (!dest_widget)
		{
			return ;
		}
		/* Insert into */
		if (kind == "into")
		{
			parent_dest_widget = dest_widget;
			dest_op_code = null;
			dest_widget = null;
		}
		/* Remove code */
		parent_src_widget.code.items.items.removeItem(src_op_code);
		this.updateItems(parent_src_widget.code, false);
		/* Add widget */
		if (!parent_dest_widget.code.items)
		{
			parent_dest_widget.code.items = new BayLang.OpCodes.OpHtmlItems();
		}
		if (!parent_dest_widget.code.items.items)
		{
			parent_dest_widget.code.items.items = Runtime.Vector.from([]);
		}
		parent_dest_widget.code.items.items.addItem(src_op_code, dest_op_code, kind);
		/* Update items */
		this.updateItems(parent_dest_widget.code, false);
	},
	/**
	 * Duplicate op_code
	 */
	duplicateOpCode: function(dest_op_code)
	{
		/* Get widgets */
		var dest_widget = this.hash.get(dest_op_code);
		var parent_widget = this.hash.get(dest_widget.parent_code);
		if (!dest_widget)
		{
			return ;
		}
		if (!parent_widget)
		{
			return ;
		}
		/* Duplicate op_code */
		var new_op_code = Runtime.Serializer.copy(dest_op_code);
		var new_widget = this.add(new_op_code);
		/* Remove key debug */
		var attr_pos = new_op_code.attrs.find(Runtime.lib.equalAttr("key", "@key_debug"));
		if (attr_pos >= 0)
		{
			new_op_code.attrs.remove(attr_pos);
		}
		/* Process op_code */
		this.page_model.attribute_processor.processHtmlTag(new_op_code, "");
		/* Add new item */
		var pos = parent_widget.code.items.items.addItem(new_op_code, dest_op_code, "after");
		/* Update items */
		this.updateItems(new_op_code, true);
		this.updateItems(parent_widget.code, false);
		return pos;
	},
	/**
	 * Remove op_code with items
	 */
	removeOpCode: function(dest_op_code)
	{
		/* Get widgets */
		var dest_widget = this.hash.get(dest_op_code);
		var parent_widget = this.hash.get(dest_widget.parent_code);
		if (!dest_widget)
		{
			return ;
		}
		if (!parent_widget)
		{
			return ;
		}
		/* Remove op_code */
		parent_widget.code.items.items.removeItem(dest_op_code);
		/* Remove tree item */
		parent_widget.tree_item.items.removeItem(dest_widget.tree_item);
		/* Remove item */
		this.remove(dest_op_code);
		this.removeItems(dest_op_code);
	},
	_init: function()
	{
		Runtime.BaseObject.prototype._init.call(this);
		this.page_model = null;
		this.hash = new Runtime.HashMap();
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetManager, Runtime.BaseObject);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetManager,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetManager";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseObject";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.WidgetManager);
window["BayLang.Constructor.Frontend.Editor.Widget.WidgetManager"] = BayLang.Constructor.Frontend.Editor.Widget.WidgetManager;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.WidgetManager;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
if (typeof BayLang.Constructor.Frontend.Editor.Widget == 'undefined') BayLang.Constructor.Frontend.Editor.Widget = {};
BayLang.Constructor.Frontend.Editor.Widget.WidgetRender = function()
{
	BayLang.Constructor.Frontend.Editor.Widget.Widget.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.Widget.WidgetRender.prototype = Object.create(BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype);
BayLang.Constructor.Frontend.Editor.Widget.WidgetRender.prototype.constructor = BayLang.Constructor.Frontend.Editor.Widget.WidgetRender;
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetRender.prototype,
{
	/**
	 * Returns true if component
	 */
	isComponent: function()
	{
		return true;
	},
	/**
	 * Returns true if component has model
	 */
	isModel: function()
	{
		return true;
	},
	_init: function()
	{
		BayLang.Constructor.Frontend.Editor.Widget.Widget.prototype._init.call(this);
		this.model_class_name = null;
		this.primary_model_code = null;
		this.model_codes = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetRender, BayLang.Constructor.Frontend.Editor.Widget.Widget);
Object.assign(BayLang.Constructor.Frontend.Editor.Widget.WidgetRender,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.WidgetRender";
	},
	getParentClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Widget.Widget";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Widget.WidgetRender);
window["BayLang.Constructor.Frontend.Editor.Widget.WidgetRender"] = BayLang.Constructor.Frontend.Editor.Widget.WidgetRender;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Widget.WidgetRender;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.Breadcrumbs = {
	name: "BayLang.Constructor.Frontend.Editor.Breadcrumbs",
	extends: Runtime.Web.Component,
	methods:
	{
		renderRow: function(item, pos, is_menu)
		{
			let __v = [];
			let selected_path = this.model.selected.path;
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["breadcrumbs__item_row"])});
			
			/* Element 'span' */
			let __v1 = this._e(__v0, "span", {"onClick":() =>
			{
				if (is_menu)
				{
					this.model.selectBreadcrumbs(pos);
				}
				else
				{
					this.model.breadcrumbs_selected = -1;
					this.model.selectItem(selected_path.slice(0, pos + 1));
				}
				this.model.context_menu.hide();
			},"onContextmenu":(e) =>
			{
				e.preventDefault();
				/* Select item */
				this.model.breadcrumbs_selected = -1;
				this.model.selectItem(selected_path.slice(0, pos + 1));
				/* Show context menu */
				var x = e.clientX;
				var y = e.clientY;
				this.model.context_menu.show(x, y);
				return false;
			},"class":this._class_name(["breadcrumbs__item_name"])});
			
			/* Render */
			this._t(__v1, (item != null) ? (item.label) : ("Select value"));
			
			if (is_menu)
			{
				/* Element 'div' */
				let __v2 = this._e(__v0, "div", {"onClick":() =>
				{
					this.model.selectBreadcrumbs(pos);
				},"class":this._class_name(["breadcrumbs__item_arrow"])});
				
				/* Raw */
				this._t(__v2, new Runtime.RawString("&#9661;"));
			}
			
			return this._flatten(__v);
		},
		renderMenu: function(parent_item, pos, is_last)
		{
			let __v = [];
			let selected_path = this.model.selected.path;
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["breadcrumbs__item_menu", ((this.model.breadcrumbs_selected == pos) ? ("breadcrumbs__item_menu--open") : (""))])});
			
			if (parent_item && parent_item.items)
			{
				for (let j = 0; j < parent_item.items.count(); j++)
				{
					let menu_item = parent_item.items.get(Runtime.Vector.from([j]));
					
					/* Element 'div' */
					let __v1 = this._e(__v0, "div", {"onClick":() =>
					{
						this.model.selectItem(selected_path.slice(0, pos).pushIm(j));
						this.model.context_menu.hide();
					},"class":this._class_name(["breadcrumbs__item_menu_name"])});
					
					/* Render */
					this._t(__v1, menu_item.label);
				}
			}
			
			if (is_last)
			{
				/* Element 'div' */
				let __v2 = this._e(__v0, "div", {"onClick":() =>
				{
					this.model.breadcrumbs_selected = -1;
					this.model.add_item_dialog.show(selected_path.slice(0, pos));
				},"class":this._class_name(["breadcrumbs__item_menu_name"])});
				
				/* Text */
				this._t(__v2, "+ Add Widget");
			}
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["breadcrumbs"])});
			let item = this.model.tree.root;
			let selected_path = this.model.selected.path;
			
			if (selected_path)
			{
				for (let i = 0; i < selected_path.count(); i++)
				{
					if (item != null)
					{
						let parent_item = item;
						item = item.get(Runtime.Vector.from([selected_path.get(i)]));
						
						/* Element 'div' */
						let __v1 = this._e(__v0, "div", {"class":this._class_name(["breadcrumbs__item breadcrumbs__item--value"])});
						
						/* Render row */
						if (i < selected_path.count() - 1)
						{
							/* Render */
							this._t(__v1, this.renderRow(item, i, false));
						}
						else
						{
							/* Render */
							this._t(__v1, this.renderRow(item, i, true));
							
							/* Render */
							this._t(__v1, this.renderMenu(parent_item, i, false));
						}
						
						/* Element 'div' */
						let __v2 = this._e(__v0, "div", {"class":this._class_name(["breadcrumbs__item breadcrumbs__item--next"])});
						
						/* Raw */
						this._t(__v2, new Runtime.RawString("->"));
					}
				}
				
				/* Element 'div' */
				let __v3 = this._e(__v0, "div", {"class":this._class_name(["breadcrumbs__item breadcrumbs__item--last"])});
				
				/* Render row */
				/* Render */
				this._t(__v3, this.renderRow(null, selected_path.count(), true));
				
				/* Render */
				this._t(__v3, this.renderMenu(item, selected_path.count(), true));
			}
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.Breadcrumbs,
{
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".breadcrumbs.h-f2af{display: flex;border-bottom: 1px var(--widget-color-border) solid;height: 32px;padding-left: 5px;overflow-x: auto;scrollbar-width: none}.breadcrumbs__item_row.h-f2af{display: flex}.breadcrumbs__item_name.h-f2af,.breadcrumbs__item_arrow.h-f2af,.breadcrumbs__item--next.h-f2af,.breadcrumbs__item_menu_name.h-f2af{display: flex;align-items: center;justify-content: center;min-height: 31px}.breadcrumbs__item_name.h-f2af{cursor: pointer;padding-left: 5px}.breadcrumbs__item_name.h-f2af span{flex: 1}.breadcrumbs__item_arrow.h-f2af{cursor: pointer;width: 20px}.breadcrumbs__item_menu.h-f2af{display: none;position: absolute;background-color: white;border: 1px var(--widget-color-border) solid}.breadcrumbs__item_menu--open.h-f2af{display: block}.breadcrumbs__item_menu_name.h-f2af{justify-content: flex-start;padding-left: 5px;padding-right: 5px;border-bottom: 1px var(--widget-color-border) solid;cursor: pointer}.breadcrumbs__item_menu_name.h-f2af:hover{background-color: var(--widget-color-hover)}.breadcrumbs__item_menu_name.h-f2af:last-child{border-bottom-width: 0px}.breadcrumbs__item--next.h-f2af{text-wrap: nowrap;padding: 0px 5px;width: 20px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.Breadcrumbs";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.Breadcrumbs);
window["BayLang.Constructor.Frontend.Editor.Breadcrumbs"] = BayLang.Constructor.Frontend.Editor.Breadcrumbs;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.Breadcrumbs;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.SelectedItem = {
	name: "BayLang.Constructor.Frontend.Editor.SelectedItem",
	extends: Runtime.Web.Component,
	props: {
		"type": {
			default: "params",
		},
	},
	data: function ()
	{
		return {
			current_tab: "params",
			tabs_items: Runtime.Vector.from([Runtime.Map.from({"key":"Params","value":"params"}),Runtime.Map.from({"key":"Styles","value":"styles"}),Runtime.Map.from({"key":"CSS","value":"css"})]),
		};
	},
	methods:
	{
		renderInput: function(selector, key, label, default_value)
		{
			if (default_value == undefined) default_value = "";
			let __v = [];
			let value = this.getCSSValue(selector, key, default_value);
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_css__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_css__key"])});
			
			/* Render */
			this._t(__v1, (label) ? (label) : (key));
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_css__value"])});
			
			/* Component 'Input' */
			let __v3 = this._c(__v2, "Runtime.Widget.Input", {"value":value,"onValueChange":(message) =>
			{
				this.setCSSValue(selector, key, message.value);
			}});
			
			return this._flatten(__v);
		},
		renderSelect: function(selector, key, label, options)
		{
			let __v = [];
			let value = this.getCSSValue(selector, key);
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_css__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_css__key"])});
			
			/* Render */
			this._t(__v1, (label) ? (label) : (key));
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_css__value"])});
			
			/* Component 'Select' */
			let __v3 = this._c(__v2, "Runtime.Widget.Select", {"value":value,"options":options,"onValueChange":(message) =>
			{
				this.setCSSValue(selector, key, message.value);
			}});
			
			return this._flatten(__v);
		},
		renderSelectImage: function(selector, key, label)
		{
			let __v = [];
			let value = this.getCSSValue(selector, key);
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_css__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_css__key"])});
			
			/* Render */
			this._t(__v1, (label) ? (label) : (key));
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_css__value"])});
			
			/* Component 'SelectImageButton' */
			let __v3 = this._c(__v2, "BayLang.Constructor.Frontend.Components.SelectImageButton", {"onValueChange":(message) =>
			{
				this.setCSSValue(selector, key, message.value);
			}});
			
			return this._flatten(__v);
		},
		renderComponentName: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_param__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_param__label"])});
			
			/* Text */
			this._t(__v1, "Component");
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_param__content"])});
			
			/* Render */
			this._t(__v2, this.model.selected.widget.code.tag_name);
			
			return this._flatten(__v);
		},
		renderWidgetName: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_param__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_param__label"])});
			
			/* Element 'div' */
			let __v2 = this._e(__v1, "div", {"class":this._class_name(["widget_param__text"])});
			
			/* Element 'div' */
			let __v3 = this._e(__v2, "div", {"class":this._class_name(["widget_param__text_label"])});
			
			/* Text */
			this._t(__v3, "Name");
			
			/* Element 'div' */
			let __v4 = this._e(__v2, "div", {"onClick":() =>
			{
				this.model.renameSelectedItem();
			},"class":this._class_name(["widget_param__text_button"])});
			
			/* Text */
			this._t(__v4, "[Edit]");
			
			/* Element 'div' */
			let __v5 = this._e(__v0, "div", {"class":this._class_name(["widget_param__content"])});
			
			/* Render */
			this._t(__v5, this.model.selected.widget.param_widget_name.value);
			
			return this._flatten(__v);
		},
		renderClassName: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_param__row"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_param__label"])});
			
			/* Text */
			this._t(__v1, "Class");
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_param__content"])});
			
			/* Component 'Tag' */
			let __v3 = this._c(__v2, "Runtime.Widget.Tag", {"value":this.model.selected.widget.param_class_name.value.slice(),"onValueChange":(message) =>
			{
				this.model.selected.widget.param_class_name.changeValue(message.value);
				this.model.updateFrameRender();
			}});
			
			return this._flatten(__v);
		},
		renderParams: function()
		{
			let __v = [];
			
			for (let i = 0; i < this.model.selected.widget.params.count(); i++)
			{
				let param = this.model.selected.widget.params.get(i);
				
				if (param.display)
				{
					let item_props = param.props;
					let class_name = param.component;
					
					/* Element 'div' */
					let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_param__row"])});
					
					/* Element 'div' */
					let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_param__label"])});
					
					/* Render */
					this._t(__v1, param.label);
					
					/* Element 'div' */
					let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_param__content"])});
					
					if (this.isAllowClassName(class_name))
					{
						/* Component '{class_name}' */
						let __v3 = this._c(__v2, class_name, this._merge_attrs({"value":param.value,"onValueChange":(message) =>
						{
							param.changeValue(message.value);
							this.model.updateFrameRender();
						}}, item_props));
					}
				}
			}
			
			return this._flatten(__v);
		},
		renderStyles: function()
		{
			let __v = [];
			let settings = this.model.selected.widget.settings;
			let selector = this.model.selected.widget.getSelector();
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v1, "Common");
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v2, this.renderInput(selector, "width", ""));
			
			/* Render */
			this._t(__v2, this.renderInput(selector, "height", ""));
			
			/* Render */
			this._t(__v2, this.renderInput(selector, "min-width", ""));
			
			/* Render */
			this._t(__v2, this.renderInput(selector, "min-height", ""));
			
			if (settings && this.isContainer(settings))
			{
				/* Element 'div' */
				let __v3 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
				
				/* Element 'div' */
				let __v4 = this._e(__v3, "div", {"class":this._class_name(["widget_css__label"])});
				
				/* Text */
				this._t(__v4, "Flex");
				
				/* Element 'div' */
				let __v5 = this._e(__v3, "div", {"class":this._class_name(["widget_css__items"])});
				
				/* Render */
				this._t(__v5, this.renderSelect(selector, "display", "", Runtime.Vector.from([Runtime.Map.from({"key":"block","value":"block"}),Runtime.Map.from({"key":"flex","value":"flex"})])));
				
				/* Render */
				this._t(__v5, this.renderSelect(selector, "align-items", "", Runtime.Vector.from([Runtime.Map.from({"key":"baseline","value":"baseline"}),Runtime.Map.from({"key":"center","value":"center"}),Runtime.Map.from({"key":"end","value":"end"}),Runtime.Map.from({"key":"flex-end","value":"flex-end"}),Runtime.Map.from({"key":"flex-start","value":"flex-start"}),Runtime.Map.from({"key":"start","value":"start"}),Runtime.Map.from({"key":"stretch","value":"stretch"}),Runtime.Map.from({"key":"revert","value":"revert"})])));
				
				/* Render */
				this._t(__v5, this.renderSelect(selector, "justify-content", "", Runtime.Vector.from([Runtime.Map.from({"key":"left","value":"left"}),Runtime.Map.from({"key":"center","value":"center"}),Runtime.Map.from({"key":"right","value":"right"}),Runtime.Map.from({"key":"space-around","value":"space-around"}),Runtime.Map.from({"key":"space-between","value":"space-between"}),Runtime.Map.from({"key":"start","value":"start"}),Runtime.Map.from({"key":"stretch","value":"stretch"}),Runtime.Map.from({"key":"end","value":"end"})])));
				
				/* Render */
				this._t(__v5, this.renderSelect(selector, "flex-wrap", "", Runtime.Vector.from([Runtime.Map.from({"key":"nowrap","value":"nowrap"}),Runtime.Map.from({"key":"wrap","value":"wrap"})])));
				
				/* Render */
				this._t(__v5, this.renderInput(selector, "gap", ""));
			}
			
			/* Element 'div' */
			let __v6 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v7 = this._e(__v6, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v7, "Padding");
			
			/* Element 'div' */
			let __v8 = this._e(__v6, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v8, this.renderInput(selector, "padding-top", ""));
			
			/* Render */
			this._t(__v8, this.renderInput(selector, "padding-bottom", ""));
			
			/* Render */
			this._t(__v8, this.renderInput(selector, "padding-left", ""));
			
			/* Render */
			this._t(__v8, this.renderInput(selector, "padding-right", ""));
			
			/* Element 'div' */
			let __v9 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v10 = this._e(__v9, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v10, "Margin");
			
			/* Element 'div' */
			let __v11 = this._e(__v9, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v11, this.renderInput(selector, "margin-top", ""));
			
			/* Render */
			this._t(__v11, this.renderInput(selector, "margin-bottom", ""));
			
			/* Render */
			this._t(__v11, this.renderInput(selector, "margin-left", ""));
			
			/* Render */
			this._t(__v11, this.renderInput(selector, "margin-right", ""));
			
			/* Element 'div' */
			let __v12 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v13 = this._e(__v12, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v13, "Font");
			
			/* Element 'div' */
			let __v14 = this._e(__v12, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v14, this.renderInput(selector, "color", ""));
			
			/* Render */
			this._t(__v14, this.renderInput(selector, "font-size", ""));
			
			/* Render */
			this._t(__v14, this.renderSelect(selector, "font-weight", "", Runtime.Vector.from([Runtime.Map.from({"key":"light","value":"lighter"}),Runtime.Map.from({"key":"normal","value":"normal"}),Runtime.Map.from({"key":"bold","value":"bold"}),Runtime.Map.from({"key":"bolder","value":"bolder"}),Runtime.Map.from({"key":"100","value":"100"}),Runtime.Map.from({"key":"200","value":"200"}),Runtime.Map.from({"key":"300","value":"300"}),Runtime.Map.from({"key":"400","value":"400"}),Runtime.Map.from({"key":"500","value":"500"}),Runtime.Map.from({"key":"600","value":"600"}),Runtime.Map.from({"key":"700","value":"700"}),Runtime.Map.from({"key":"800","value":"800"}),Runtime.Map.from({"key":"900","value":"900"})])));
			
			/* Render */
			this._t(__v14, this.renderSelect(selector, "text-align", "", Runtime.Vector.from([Runtime.Map.from({"key":"left","value":"left"}),Runtime.Map.from({"key":"center","value":"center"}),Runtime.Map.from({"key":"right","value":"right"}),Runtime.Map.from({"key":"justify","value":"justify"})])));
			
			/* Render */
			this._t(__v14, this.renderSelect(selector, "text-transform", "", Runtime.Vector.from([Runtime.Map.from({"key":"capitalize","value":"capitalize"}),Runtime.Map.from({"key":"lowercase","value":"lowercase"}),Runtime.Map.from({"key":"uppercase","value":"uppercase"}),Runtime.Map.from({"key":"inherit","value":"inherit"}),Runtime.Map.from({"key":"none","value":"none"})])));
			
			/* Render */
			this._t(__v14, this.renderInput(selector, "line-height", ""));
			
			/* Element 'div' */
			let __v15 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v16 = this._e(__v15, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v16, "Border");
			
			/* Element 'div' */
			let __v17 = this._e(__v15, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v17, this.renderInput(selector, "border-color", ""));
			
			/* Render */
			this._t(__v17, this.renderSelect(selector, "border-style", "", Runtime.Vector.from([Runtime.Map.from({"key":"dashed","value":"dashed"}),Runtime.Map.from({"key":"dotted","value":"dotted"}),Runtime.Map.from({"key":"double","value":"double"}),Runtime.Map.from({"key":"hidden","value":"hidden"}),Runtime.Map.from({"key":"inset","value":"inset"}),Runtime.Map.from({"key":"none","value":"none"}),Runtime.Map.from({"key":"outset","value":"outset"}),Runtime.Map.from({"key":"solid","value":"solid"}),Runtime.Map.from({"key":"inherit","value":"inherit"}),Runtime.Map.from({"key":"unset","value":"unset"})])));
			
			/* Render */
			this._t(__v17, this.renderInput(selector, "border-width", ""));
			
			/* Render */
			this._t(__v17, this.renderInput(selector, "border-radius", ""));
			
			/* Element 'div' */
			let __v18 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v19 = this._e(__v18, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v19, "Background");
			
			/* Element 'div' */
			let __v20 = this._e(__v18, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v20, this.renderInput(selector, "background-color", "Color"));
			
			/* Render */
			this._t(__v20, this.renderSelectImage(selector, "background-image", "Image"));
			
			/* Render */
			this._t(__v20, this.renderInput(selector, "background-position", "Position"));
			
			/* Render */
			this._t(__v20, this.renderSelect(selector, "background-repeat", "Repeat", Runtime.Vector.from([Runtime.Map.from({"key":"repeat","value":"repeat"}),Runtime.Map.from({"key":"repeat-x","value":"repeat-x"}),Runtime.Map.from({"key":"repeat-y","value":"repeat-y"}),Runtime.Map.from({"key":"no-repeat","value":"no-repeat"})])));
			
			/* Render */
			this._t(__v20, this.renderSelect(selector, "background-size", "Size", Runtime.Vector.from([Runtime.Map.from({"key":"contain","value":"contain"}),Runtime.Map.from({"key":"cover","value":"cover"})])));
			
			/* Element 'div' */
			let __v21 = this._e(__v, "div", {"class":this._class_name(["widget_css__content"])});
			
			/* Element 'div' */
			let __v22 = this._e(__v21, "div", {"class":this._class_name(["widget_css__label"])});
			
			/* Text */
			this._t(__v22, "CSS");
			
			/* Element 'div' */
			let __v23 = this._e(__v21, "div", {"class":this._class_name(["widget_css__items"])});
			
			/* Render */
			this._t(__v23, this.renderCSS());
			
			return this._flatten(__v);
		},
		renderCSS: function()
		{
			let __v = [];
			let selector_name = this.model.selected.widget.getSelectorName();
			
			/* Component 'TextEditable' */
			let __v0 = this._c(__v, "Runtime.Widget.TextEditable", {"value":this.model.styles.getSelectorContent(selector_name),"onValueChange":(message) =>
			{
				this.model.styles.changeSelectorContent(selector_name, message.value);
			},"class":this._class_name(["overflow"])});
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_param"])});
			
			if (this.model.selected.widget)
			{
				/* Render info */
				/* Render */
				this._t(__v0, this.renderComponentName());
				
				/* Render */
				this._t(__v0, this.renderWidgetName());
				
				/* Render */
				this._t(__v0, this.renderClassName());
				
				/* Render css */
				if (this.type == "css")
				{
					/* Render */
					this._t(__v0, this.renderStyles());
				}
				
				/* Render params */
				if (this.type == "params")
				{
					/* Render */
					this._t(__v0, this.renderParams());
				}
			}
			
			return this._flatten(__v);
		},
		/**
 * Returns true if class name is allowed
 */
		isAllowClassName: function(class_name)
		{
			if (class_name == "Runtime.Widget.Input")
			{
				return true;
			}
			if (class_name == "Runtime.Widget.Select")
			{
				return true;
			}
			if (class_name == "Runtime.Widget.SortableList")
			{
				return true;
			}
			if (class_name == "Runtime.Widget.Tag")
			{
				return true;
			}
			if (class_name == "Runtime.Widget.TextArea")
			{
				return true;
			}
			if (class_name == "Runtime.Widget.TextEditable")
			{
				return true;
			}
			if (class_name == "BayLang.Constructor.Frontend.Components.SelectImageButton")
			{
				return true;
			}
			if (class_name == "BayLang.Constructor.Frontend.Components.SortableParams")
			{
				return true;
			}
			return false;
		},
		/**
 * Returns true if widget is container
 */
		isContainer: function(settings)
		{
			if (!settings)
			{
				return false;
			}
			var iframe_window = this.model.getFrameWindow();
			return iframe_window.Runtime.rtl.is_instanceof(settings, "Runtime.Widget.WidgetSettings.Settings.ContainerSettings");
		},
		/**
 * Returns css value
 */
		getCSSValue: function(selector, key, default_value)
		{
			if (default_value == undefined) default_value = "";
			if (selector == null)
			{
				return default_value;
			}
			var value = selector.getStyle(key);
			return (value) ? (value.getValue()) : (default_value);
		},
		/**
 * Set css value
 */
		setCSSValue: function(selector, key, value)
		{
			if (value == undefined) value = "";
			if (!selector)
			{
				var selector_name = this.model.selected.widget.getSelectorName();
				selector = this.model.styles.createSelector(selector_name);
			}
			selector.changeStyleValue(key, value);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.SelectedItem,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Button","Runtime.Widget.Input","Runtime.Widget.Select","Runtime.Widget.Tag","Runtime.Widget.TextArea","Runtime.Widget.TextEditable","BayLang.Constructor.Frontend.Components.SelectImageButton","BayLang.Constructor.Frontend.Components.SortableParams","BayLang.Constructor.Frontend.Editor.WidgetStyle"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_param.h-c425{padding-bottom: 20px}.widget_param__row.h-c425{margin-bottom: 10px}.widget_param__label.h-c425{margin-bottom: 5px}.widget_param__title.h-c425{margin-bottom: 5px}.widget_param__text.h-c425{display: flex;gap: 10px}.widget_param__text_label.h-c425{overflow-wrap: anywhere}.widget_param__text_button.h-c425{cursor: pointer}.widget_param__text_button.h-c425:hover{text-decoration: underline}.widget_param.h-c425 .widget_select.h-d72d{padding: 7px;min-height: 37px}.widget_param.h-c425 .widget_input.h-f2df,.widget_param.h-c425 .widget_textarea.h-ee82{padding: 7px}.widget_param.h-c425 .widget_textarea.h-ee82{font-family: 'PT Mono';line-height: 1.5}.widget_css__label.h-c425{text-align: center;background-color: aliceblue;padding: 5px;margin-bottom: 5px}.widget_css__row.h-c425{display: flex;align-items: center;margin-bottom: 5px}.widget_css__key.h-c425{width: 100px}.widget_css__value.h-c425{width: calc(100% - 100px)}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.SelectedItem";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.SelectedItem);
window["BayLang.Constructor.Frontend.Editor.SelectedItem"] = BayLang.Constructor.Frontend.Editor.SelectedItem;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.SelectedItem;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.SelectedItemModel = function()
{
	Runtime.Web.BaseModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.SelectedItemModel.prototype = Object.create(Runtime.Web.BaseModel.prototype);
BayLang.Constructor.Frontend.Editor.SelectedItemModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.SelectedItemModel;
Object.assign(BayLang.Constructor.Frontend.Editor.SelectedItemModel.prototype,
{
	/**
	 * Select item
	 */
	selectItem: function(path)
	{
		/* Change path */
		this.path = (path) ? (path.slice()) : (null);
		/* Get item */
		var widget = this.parent_widget.widget_manager.getWidget(path);
		if (widget == this.widget)
		{
			return ;
		}
		/* Set widget */
		this.widget = widget;
		if (!this.widget)
		{
			return ;
		}
		/* Setup widget */
		this.widget.setup();
	},
	_init: function()
	{
		Runtime.Web.BaseModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.SelectedItem";
		this.widget_name = "selected";
		this.path = null;
		this.widget = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.SelectedItemModel, Runtime.Web.BaseModel);
Object.assign(BayLang.Constructor.Frontend.Editor.SelectedItemModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.SelectedItemModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BaseModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.SelectedItemModel);
window["BayLang.Constructor.Frontend.Editor.SelectedItemModel"] = BayLang.Constructor.Frontend.Editor.SelectedItemModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.SelectedItemModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.WidgetEditPage = {
	name: "BayLang.Constructor.Frontend.Editor.WidgetEditPage",
	extends: Runtime.Web.Component,
	data: function ()
	{
		return {
			menu_items: Runtime.Vector.from([Runtime.Map.from({"label":"Styles","value":"styles"}),Runtime.Map.from({"label":"CSS","value":"css"}),Runtime.Map.from({"label":"Params","value":"params"}),Runtime.Map.from({"label":"Tree","value":"tree"})]),
		};
	},
	methods:
	{
		renderSelectSize: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_edit_page__menu_item widget_edit_page__menu_item--select_size"])});
			
			for (let i = 0; i < this.model.iframe_sizes.count(); i++)
			{
				let size = this.model.iframe_sizes.get(i);
				
				/* Element 'div' */
				let __v1 = this._e(__v0, "div", {"onClick":() =>
				{
					this.model.selectIFrameSize(size);
				},"class":this._class_name(["widget_edit_page__iframe_size", ((this.model.iframe_current_size == size.get("label")) ? ("selected") : (""))])});
				
				/* Render */
				this._t(__v1, size.get("label"));
			}
			
			return this._flatten(__v);
		},
		renderMenu: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_edit_page__menu"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_edit_page__menu_item_gap"])});
			
			/* Element 'a' */
			let __v2 = this._e(__v1, "a", {"href":this.layout.url("baylang:project:widgets", Runtime.Map.from({"project_id":this.model.project_id,"module_id":this.model.module_id})),"class":this._class_name(["widget_edit_page__menu_item nolink"])});
			
			/* Text */
			this._t(__v2, "Back");
			
			/* Element 'div' */
			let __v3 = this._e(__v1, "div", {"onClick":(e) =>
			{
				this.model.saveWidget();
			},"class":this._class_name(["widget_edit_page__menu_item"])});
			
			/* Text */
			this._t(__v3, "Save");
			
			/* Element 'div' */
			let __v4 = this._e(__v1, "div", {"class":this._class_name(["widget_edit_page__menu_item"])});
			
			/* Text */
			this._t(__v4, "Export");
			
			/* Element 'div' */
			let __v5 = this._e(__v1, "div", {"class":this._class_name(["widget_edit_page__menu_item widget_edit_page__menu_item--status_message", ((this.isAppStatusError()) ? ("widget_edit_page__menu_item--error") : (""))])});
			
			/* Render */
			this._t(__v5, this.getAppStatusMessage());
			
			/* %render this.renderSelectSize(); */
			/* Element 'div' */
			let __v6 = this._e(__v0, "div", {"class":this._class_name(["widget_edit_page__menu_item_gap widget_edit_page__menu--right"])});
			
			for (let i = 0; i < this.menu_items.count(); i++)
			{
				let item = this.menu_items.get(i);
				
				/* Element 'div' */
				let __v7 = this._e(__v6, "div", {"onClick":(e) =>
				{
					this.toggleMenu(e, item.get("value"));
				},"class":this._class_name(["widget_edit_page__menu_item widget_edit_page__menu_item--button", ((this.model.menu_selected == item.get("value")) ? ("widget_edit_page__menu_item--selected") : (""))])});
				
				/* Render */
				this._t(__v7, item.get("label"));
			}
			
			return this._flatten(__v);
		},
		renderContent: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_edit_page__content"])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_edit_page__frame"])});
			
			/* Component 'Breadcrumbs' */
			let __v2 = this._c(__v1, "BayLang.Constructor.Frontend.Editor.Breadcrumbs", {"model":this._model(this.model)});
			
			/* Element 'div' */
			let __v3 = this._e(__v1, "div", {"class":this._class_name(["widget_edit_page__frame_wrap"])});
			
			/* Element 'iframe' */
			let __v4 = this._e(__v3, "iframe", {"ref":"iframe"});
			
			/* Component 'WidgetMenu' */
			let __v5 = this._c(__v0, "BayLang.Constructor.Frontend.Editor.WidgetMenu", {"model":this._model(this.model)});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.add_item_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.context_menu));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.remove_item_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.rename_item_dialog));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.select_image_dialog));
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_edit_page"])});
			
			/* Render */
			this._t(__v0, this.renderMenu());
			
			/* Render */
			this._t(__v0, this.renderContent());
			
			return this._flatten(__v);
		},
		/**
 * Returns true if app status is error
 */
		isAppStatusError: function()
		{
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_LOAD_ERROR)
			{
				return true;
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_SAVE_ERROR)
			{
				return true;
			}
			return false;
		},
		/**
 * Returns app status message
 */
		getAppStatusMessage: function()
		{
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_LOAD_PROCESS)
			{
				return "Loading...";
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_LOAD_SUCCESS)
			{
				return "Loaded";
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_LOAD_ERROR)
			{
				return this.model.load_error_message;
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_CHANGED)
			{
				return "";
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_SAVE_PROCESS)
			{
				return "Saving...";
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_SAVE_SUCCESS)
			{
				return "Saved";
			}
			if (this.model.app_status == BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.STATUS_SAVE_ERROR)
			{
				return "Save error";
			}
			return "";
		},
		/**
 * Toggle property
 */
		toggleMenu: function(e, name)
		{
			if (this.model.menu_selected != name)
			{
				this.model.menu_selected = name;
			}
			else
			{
				this.model.menu_selected = "";
			}
			this.nextTick(() =>
			{
				var page_model = this.model.getFramePageModel();
				if (page_model)
				{
					page_model.updateSelectedBox();
				}
			});
			e.preventDefault();
			e.stopPropagation();
			return false;
		},
		/**
 * Mounted
 */
		onMounted: function()
		{
			var iframe = this.getRef("iframe");
			var iframe_window = iframe.contentWindow;
			var iframe_document = iframe.contentDocument;
			/* Setup iframe */
			this.model.iframe = iframe;
			/* Load widget */
			this.model.loadWidget();
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetEditPage,
{
	components: function()
	{
		return Runtime.Vector.from(["BayLang.Constructor.Frontend.CSS","BayLang.Constructor.Frontend.Editor.Breadcrumbs","BayLang.Constructor.Frontend.Editor.WidgetMenu"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".index_page.h-c72c{display: flex;flex-direction: column;height: 100vh}.widget_edit_page__menu.h-c72c{display: flex;justify-content: flex-start;border-bottom: 1px var(--widget-color-border) solid}.widget_edit_page__menu--right.h-c72c{justify-content: right}.widget_edit_page__menu_item.h-c72c{cursor: pointer;user-select: none;padding: 10px}.widget_edit_page__menu_item--button.h-c72c{text-align: center;min-width: 40px}.widget_edit_page__menu_item--error.h-c72c{color: var(--widget-color-danger)}.widget_edit_page__menu_item--select_size.h-c72c{display: flex;padding: 0px}.widget_edit_page__menu_item--select_size.h-c72c .widget_edit_page__iframe_size.h-c72c{display: flex;justify-content: center;align-items: center;width: 40px;padding: 10px}.widget_edit_page__menu_item--select_size.h-c72c .widget_edit_page__iframe_size.selected.h-c72c{background-color: var(--widget-color-primary);color: var(--widget-color-primary-text)}.widget_edit_page__menu_item--selected.h-c72c{background-color: var(--widget-color-primary);color: var(--widget-color-primary-text)}.widget_edit_page__menu_item_gap.h-c72c{display: flex;flex: 1}.widget_edit_page__content.h-c72c{display: flex;flex: 1;height: calc(100vh - 41px)}.widget_edit_page__frame.h-c72c{display: flex;flex-direction: column;justify-content: stretch;align-items: stretch;width: calc(100% - 300px);position: relative;padding: 0px;flex: 1}.widget_edit_page__frame_wrap.h-c72c{display: flex;justify-content: center;flex: 1}.widget_edit_page__frame.h-c72c iframe{border-style: none;overflow: visible;width: 100%}");
		res += Runtime.rtl.toStr(".scroll-lock{overflow: hidden;padding-right: 0px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.WidgetEditPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.WidgetEditPage);
window["BayLang.Constructor.Frontend.Editor.WidgetEditPage"] = BayLang.Constructor.Frontend.Editor.WidgetEditPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.WidgetEditPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.WidgetEditPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.prototype.constructor = BayLang.Constructor.Frontend.Editor.WidgetEditPageModel;
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetEditPageModel.prototype,
{
	/**
	 * Returns iframe window
	 */
	getFrameWindow: function()
	{
		if (!this.isLoaded())
		{
			return null;
		}
		if (!this.iframe)
		{
			return null;
		}
		if (!this.iframe.contentWindow)
		{
			return null;
		}
		return this.iframe.contentWindow;
	},
	/**
	 * Returns iframe layout
	 */
	getFrameLayout: function()
	{
		if (!this.isLoaded())
		{
			return null;
		}
		if (!this.iframe)
		{
			return null;
		}
		if (!this.iframe.contentWindow)
		{
			return null;
		}
		if (!this.iframe.contentWindow.app_layout)
		{
			return null;
		}
		return this.iframe.contentWindow.app_layout;
	},
	/**
	 * Returns page model
	 */
	getFramePageModel: function()
	{
		var app_layout = this.getFrameLayout();
		if (!app_layout)
		{
			return null;
		}
		return app_layout.getPageModel();
	},
	/**
	 * Returns frame editor
	 */
	getFrameEditor: function()
	{
		var app_window = this.getFrameWindow();
		if (!app_window)
		{
			return null;
		}
		return app_window.global_context.provider("BayLang.Constructor.WidgetPage.EditorProvider");
	},
	/**
	 * Returns widget frame page
	 */
	getFramePageUrl: function()
	{
		var page_url = BayLang.Constructor.Frontend.ConstructorHook.getFramePageUrl(this.project_id, this.current_widget);
		return page_url;
	},
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		this.layout.setLayoutName("default");
		this.project_id = this.layout.route.matches.get("project_id");
		this.module_id = this.layout.request_query.get("module_id");
		this.current_widget = this.layout.route.matches.get("widget_name");
		/* Create widgets */
		this.selected = this.addWidget("BayLang.Constructor.Frontend.Editor.SelectedItemModel");
		this.styles = this.addWidget("BayLang.Constructor.Frontend.Editor.Styles.StylesModel");
		/* Create Tree */
		this.tree = this.addWidget("Runtime.Widget.Tree.TreeModel", Runtime.Map.from({"dnd":true,"icons":false}));
		this.tree.addListener("canDrag", new Runtime.Callback(this, "onCanTreeDrop"));
		this.tree.addListener("dragElement", new Runtime.Callback(this, "onTreeDragElement"));
		this.tree.addListener("selectItem", new Runtime.Callback(this, "onTreeSelectItem"));
		/* Add item dialog model */
		this.add_item_dialog = this.addWidget("BayLang.Constructor.Frontend.Editor.Dialog.AddItemDialogModel", Runtime.Map.from({"widget_name":"add_item_dialog"}));
		/* Remove item dialog model */
		this.remove_item_dialog = this.addWidget("BayLang.Constructor.Frontend.Editor.Dialog.RemoveItemDialogModel", Runtime.Map.from({"widget_name":"remove_item_dialog"}));
		/* Rename item dialog model */
		this.rename_item_dialog = this.addWidget("Runtime.Widget.Dialog.PromptDialogModel", Runtime.Map.from({"widget_name":"rename_item_dialog","confirm_button":"Rename","title":"Rename name","events":Runtime.Map.from({"confirm":new Runtime.Callback(this, "onRename")})}));
		/* Select image dialog */
		this.select_image_dialog = this.addWidget("BayLang.Constructor.Frontend.Editor.Dialog.SelectImageDialogModel", Runtime.Map.from({"widget_name":"select_image_dialog"}));
		/* Create ContextMenu */
		this.context_menu = this.addWidget("Runtime.Widget.ContextMenu.ContextMenuModel");
		/*
		this.context_menu.addItem({
			"label": "Append item",
			"key": "append"
		});
		*/
		this.context_menu.addItem(Runtime.Map.from({"label":"Insert item","key":"insert"}));
		this.context_menu.addItem(Runtime.Map.from({"label":"Rename item","key":"rename"}));
		this.context_menu.addItem(Runtime.Map.from({"label":"Duplicate item","key":"duplicate"}));
		this.context_menu.addItem(Runtime.Map.from({"label":"Remove item","key":"remove"}));
		this.context_menu.addListener("clickItem", new Runtime.Callback(this, "onContextClickItem"));
		this.tree.setContextMenu(this.context_menu);
		window.addEventListener("message", (event) => { Vue.reactive(this).onPostMessage(event); });
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle(this.current_widget);
	},
	/**
	 * Load widget
	 */
	loadWidget: async function()
	{
		var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.widget","method_name":"getOpCode","data":Runtime.Map.from({"project_id":this.project_id,"current_widget":this.current_widget})}));
		if (res.isSuccess())
		{
			/* Setup op code */
			this.component_processor.setupOpCode(res.data.get("component"));
			this.model_processor.setupOpCode(res.data.get("model"));
			/* Setup CSS styles */
			this.styles.setupStyles(this.component_processor.code);
			/* Load iframe page */
			this.iframe.src = this.getFramePageUrl();
		}
		else
		{
			this.app_status = this.constructor.STATUS_LOAD_ERROR;
			this.load_error_message = res.message;
		}
	},
	/**
	 * Save widget
	 */
	saveWidget: async function()
	{
		/*if (not this.isLoaded()) return;*/
		if (!this.component_processor.code)
		{
			return Promise.resolve();
		}
		var op_code_class = this.component_processor.code.findClass();
		if (!op_code_class)
		{
			return Promise.resolve();
		}
		/* Update widget html styles op_code */
		for (var i = 0; i < op_code_class.items.count(); i++)
		{
			var op_code = op_code_class.items.get(i);
			if (op_code instanceof BayLang.OpCodes.OpHtmlStyle)
			{
				this.styles.updateHtmlStyle(op_code);
			}
		}
		/* Serialize component */
		var serializer = new Runtime.SerializerBase64();
		serializer.setFlag(Runtime.Serializer.ALLOW_OBJECTS);
		var component = serializer.encode(this.component_processor.code);
		/* Serialize model */
		var serializer = new Runtime.SerializerBase64();
		serializer.setFlag(Runtime.Serializer.ALLOW_OBJECTS);
		var model = serializer.encode(this.model_processor.code);
		/* Save content */
		this.app_status = this.constructor.STATUS_SAVE_PROCESS;
		var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.widget","method_name":"save","data":Runtime.Map.from({"project_id":this.project_id,"current_widget":this.current_widget,"component":component,"model":model})}));
		/* Set result */
		if (res.isSuccess())
		{
			this.app_status = this.constructor.STATUS_SAVE_SUCCESS;
		}
		else
		{
			this.app_status = this.constructor.STATUS_SAVE_ERROR;
		}
	},
	/**
	 * Iframe loaded
	 */
	onAppLoaded: function()
	{
		this.app_status = this.constructor.STATUS_LOAD_SUCCESS;
		/* Setup main widget */
		this.main_widget.setup();
		/* Setup tree root */
		this.tree.root = this.main_widget.tree_item;
	},
	/**
	 * App is changed
	 */
	onAppChanged: function()
	{
		this.app_status = this.constructor.STATUS_CHANGED;
	},
	/**
	 * Post message event
	 */
	onPostMessage: function(event)
	{
		if (event.data.name == "app_loaded")
		{
			this.onAppLoaded();
		}
		else if (event.data.name == "add_widget")
		{
			this.showAddWidgetDialog(this.constructor.convertWidgetPath(event.data.path), event.data.kind);
		}
		else if (event.data.name == "move_widget")
		{
			this.moveWidget(this.constructor.convertWidgetPath(event.data.path), event.data.kind);
		}
		else if (event.data.name == "remove_widget")
		{
			this.showRemoveWidgetDialog();
		}
		else if (event.data.name == "select_item")
		{
			this.selectItem(this.constructor.convertWidgetPath(event.data.path));
		}
		else if (event.data.name == "context_menu")
		{
			this.onEditorContextMenuClick(event.data.x, event.data.y);
		}
	},
	/**
	 * Send message
	 */
	sendMessage: function(data)
	{
		var app_window = this.getFrameWindow();
		if (!app_window)
		{
			return ;
		}
		app_window.postMessage(data.toObject());
	},
	/**
	 * Returns true if app is loaded
	 */
	isLoaded: function()
	{
		return this.app_status > 0;
	},
	/**
	 * Context menu item click
	 */
	onContextClickItem: function(message)
	{
		var item = message.item;
		var item_key = item.get("key");
		this.context_menu.hide();
		/* Add item */
		if (item_key == "append")
		{
			this.add_item_dialog.show(this.selected.path, "after");
		}
		/* Insert item */
		if (item_key == "insert")
		{
			this.add_item_dialog.show(this.selected.path, "last");
		}
		/* Rename item */
		if (item_key == "rename")
		{
			this.renameSelectedItem();
		}
		/* Duplicate item */
		if (item_key == "duplicate")
		{
			this.duplicateWidget(this.selected.path);
		}
		/* Remove item */
		if (item_key == "remove")
		{
			this.showRemoveWidgetDialog();
		}
	},
	/**
	 * Show add widget dialog
	 */
	showAddWidgetDialog: function(selected_path, kind)
	{
		this.add_item_dialog.show(selected_path, kind);
	},
	/**
	 * Show remove widget dialog
	 */
	showRemoveWidgetDialog: function()
	{
		this.remove_item_dialog.title = "Remove item";
		this.remove_item_dialog.content = "Do you want to remove this item?";
		this.remove_item_dialog.show();
	},
	/**
	 * Select Frame size
	 */
	selectIFrameSize: function(size)
	{
		if (!this.isLoaded())
		{
			return ;
		}
		/* Select item */
		this.iframe_current_size = size.get("label");
		/* Set iframe width */
		var width = size.get("width");
		if (width > 1000)
		{
			this.iframe.style.width = "";
			this.iframe_current_size = "";
		}
		else
		{
			this.iframe.style.width = width + Runtime.rtl.toStr("px");
		}
		/* Update selected box */
		this.sendMessage(Runtime.Map.from({"name":"update_selected_box"}));
	},
	/**
	 * Update render
	 */
	updateFrameRender: function(render_name)
	{
		if (render_name == undefined) render_name = "render";
		/* Set app is changed */
		this.onAppChanged();
		/* Build render */
		this.sendMessage(Runtime.Map.from({"name":"update_render","render":render_name}));
	},
	/**
	 * Update global css
	 */
	updateFrameGlobalCSS: function()
	{
		/* Set app is changed */
		this.onAppChanged();
		/* Build global css */
		this.sendMessage(Runtime.Map.from({"name":"update_global_css"}));
	},
	/**
	 * Update css
	 */
	updateFrameCSS: function()
	{
		/* Set app is changed */
		this.onAppChanged();
		/* Build CSS */
		this.sendMessage(Runtime.Map.from({"name":"update_css"}));
	},
	/**
	 * Select item
	 */
	onTreeSelectItem: function(message)
	{
		if (!this.isLoaded())
		{
			return null;
		}
		if (this.selected.widget != null && message.item == this.selected.widget.tree_item)
		{
			return ;
		}
		this.selectItem(message.path);
	},
	/**
	 * Select item
	 */
	selectItem: function(path)
	{
		this.breadcrumbs_selected = -1;
		this.context_menu.hide();
		/* Select item */
		this.selected.selectItem(path);
		/* Select tree */
		this.tree.selectItem(path);
		/* Select item in frame */
		this.sendMessage(Runtime.Map.from({"name":"select_item","path":Runtime.rs.join(".", path)}));
	},
	/**
	 * Breadcrumbs
	 */
	selectBreadcrumbs: function(pos)
	{
		if (this.breadcrumbs_selected != pos)
		{
			this.breadcrumbs_selected = pos;
		}
		else
		{
			this.breadcrumbs_selected = -1;
		}
	},
	/**
	 * Context menu click
	 */
	onEditorContextMenuClick: function(x, y)
	{
		var rect = this.iframe.getBoundingClientRect();
		x = x + rect.x;
		y = y + rect.y;
		this.context_menu.show(x, y);
	},
	/**
	 * Can Tree drop
	 */
	onCanTreeDrop: function(message)
	{
		var src_widget = this.widget_manager.getWidget(message.src);
		var dest_widget = this.widget_manager.getWidget(message.dest);
		if (message.dest == null)
		{
			return ;
		}
		if (dest_widget == null)
		{
			return ;
		}
		/* Setup widget */
		if (dest_widget.is_initialized)
		{
			dest_widget.setup();
		}
		/* Check into drag */
		if (message.kind == "into" && !dest_widget.canInsert(src_widget.settings))
		{
			message.result = false;
			return ;
		}
	},
	/**
	 * Rename item
	 */
	renameSelectedItem: function()
	{
		this.rename_item_dialog.old_value = this.selected.widget.param_widget_name.value;
		this.rename_item_dialog.setTitle("Rename " + Runtime.rtl.toStr(this.rename_item_dialog.old_value));
		this.rename_item_dialog.setValue(this.rename_item_dialog.old_value);
		this.rename_item_dialog.show();
	},
	/**
	 * On rename item
	 */
	onRename: function(message)
	{
		var old_widget_name = this.rename_item_dialog.old_value;
		var new_widget_name = message.value;
		if (old_widget_name == new_widget_name)
		{
			return ;
		}
		var new_selector_name = new_widget_name;
		if (Runtime.rs.charAt(new_selector_name, 0) != ".")
		{
			new_selector_name = "." + Runtime.rtl.toStr(new_selector_name);
		}
		/* Rename widget */
		this.selected.widget.param_widget_name.changeValue(new_widget_name);
		/* Rename model name */
		if (this.selected.widget.is_model)
		{
			this.model_processor.setWidgetName(this.selected.widget, new_widget_name);
			/* Rename model */
			var iframe_page_model = this.getFramePageModel().widget_model;
			iframe_page_model.widgets.set(new_widget_name, iframe_page_model.widgets.get(old_widget_name));
			iframe_page_model.widgets.remove(old_widget_name);
			iframe_page_model[new_widget_name] = iframe_page_model[old_widget_name];
			iframe_page_model[old_widget_name] = null;
		}
		/* Create new style */
		if (!this.styles.selectors.has(new_selector_name))
		{
			var old_selector_name = "." + Runtime.rtl.toStr(old_widget_name);
			var css_content = this.styles.getSelectorContent(old_selector_name);
			this.styles.setSelectorContent(new_selector_name, css_content);
		}
		/* Update render */
		this.updateFrameCSS();
		this.updateFrameRender();
	},
	/**
	 * Move widget
	 */
	moveWidget: function(path, kind)
	{
		var dest_path_item = 0;
		var dest_path_kind = "";
		if (kind == "down")
		{
			dest_path_kind = "after";
			dest_path_item = path.last() + 1;
		}
		else if (kind == "up")
		{
			dest_path_kind = "before";
			dest_path_item = path.last() - 1;
		}
		var dest_path = path.setIm(path.count() - 1, dest_path_item);
		var src_op_code = this.widget_manager.getOpCode(path);
		var dest_op_code = this.widget_manager.getOpCode(dest_path);
		if (!dest_op_code)
		{
			return ;
		}
		/* Move op code */
		this.widget_manager.moveOpCode(src_op_code, dest_op_code, dest_path_kind);
		this.selectItem(dest_path);
		/* Update frame render */
		this.updateFrameRender();
	},
	/**
	 * Add widget op_code
	 */
	addOpCode: function(op_code, path, kind)
	{
		var dest_op_code = this.widget_manager.getOpCode(path);
		/* Root insert */
		if (dest_op_code == null)
		{
			dest_op_code = this.tree.root.code;
			kind = "last";
			path = Runtime.Vector.from([]);
		}
		/* Add op code */
		var pos = this.widget_manager.addOpCode(op_code, dest_op_code, kind);
		if (pos < 0)
		{
			return ;
		}
		/* Build new path */
		var new_src_path = (kind == "first" || kind == "last") ? (path.slice()) : (path.slice(0, -1));
		new_src_path.push(pos);
		/* Add model */
		var widget = this.widget_manager.getWidget(new_src_path);
		if (widget)
		{
			/* Setup widget */
			widget.setup();
			/* Create model op_code */
			this.model_processor.createModel(widget);
			/* Setup widget model */
			this.model_processor.setupWidget(widget);
			/* Add model widget */
			var content = this.model_processor.buildPrimaryContent(widget);
			if (content)
			{
				this.sendMessage(Runtime.Map.from({"name":"add_widget_model","widget":widget.getName(),"content":content}));
			}
		}
		/* Select new item */
		this.selectItem(new_src_path);
		/* Update frame render */
		this.updateFrameRender();
		/* Update CSS */
		this.updateFrameCSS();
		/* Update Global CSS */
		this.updateFrameGlobalCSS();
		return new_src_path;
	},
	/**
	 * Duplicate selected widget
	 */
	duplicateWidget: function(path)
	{
		/* Get op_code */
		var dest_op_code = this.widget_manager.getOpCode(path);
		if (!dest_op_code)
		{
			return ;
		}
		/* Duplicate */
		this.widget_manager.duplicateOpCode(dest_op_code);
		/* Update frame render */
		this.updateFrameRender();
	},
	/**
	 * Remove widget
	 */
	removeWidget: function(path, model)
	{
		if (model == undefined) model = true;
		if (path == null)
		{
			return ;
		}
		/* Get op_code */
		var dest_op_code = this.widget_manager.getOpCode(this.selected.path);
		if (!dest_op_code)
		{
			return ;
		}
		/* Remove model */
		if (model)
		{
			var widget = this.widget_manager.get(dest_op_code);
			if (widget)
			{
				this.model_processor.removeModel(widget);
			}
		}
		/* Remove */
		this.widget_manager.removeOpCode(dest_op_code);
		/* Set selected is null */
		this.selectItem(null);
		/* Update frame render */
		this.updateFrameRender();
	},
	/**
	 * Drag & Drop
	 */
	onTreeDragElement: function(message)
	{
		var kind = message.kind;
		var dest_item = message.dest_item;
		var dest_parent_item = message.dest_parent_item;
		var src_item = message.src_item;
		var src_parent_item = message.src_parent_item;
		/* Move item */
		this.widget_manager.moveOpCode(src_item.code, dest_item.code, kind);
		/* Select new item */
		this.selectItem(message.new_src_path);
		/* Update frame render */
		this.updateFrameRender();
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Editor.WidgetEditPage";
		this.project_id = "";
		this.module_id = "";
		this.current_widget = "";
		this.component_class_name = "";
		this.menu_selected = "params";
		this.iframe_current_size = "";
		this.load_error_message = "";
		this.app_status = this.constructor.STATUS_LOAD_PROCESS;
		this.breadcrumbs_selected = -1;
		this.iframe = null;
		this.tree = null;
		this.main_widget = null;
		this.attribute_processor = new BayLang.Constructor.Frontend.Editor.Processor.AttributeProcessor(this);
		this.component_processor = new BayLang.Constructor.Frontend.Editor.Processor.ComponentProcessor(this);
		this.model_processor = new BayLang.Constructor.Frontend.Editor.Processor.ModelProcessor(this);
		this.widget_manager = new BayLang.Constructor.Frontend.Editor.Widget.WidgetManager(this);
		this.selected = null;
		this.styles = null;
		this.context_menu = null;
		this.add_item_dialog = null;
		this.remove_item_dialog = null;
		this.rename_item_dialog = null;
		this.select_image_dialog = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetEditPageModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetEditPageModel,
{
	STATUS_LOAD_PROCESS: 0,
	STATUS_LOAD_SUCCESS: 1,
	STATUS_LOAD_ERROR: 2,
	STATUS_CHANGED: 3,
	STATUS_SAVE_PROCESS: 4,
	STATUS_SAVE_SUCCESS: 5,
	STATUS_SAVE_ERROR: 6,
	/**
	 * Convert widget_path to tree_path
	 */
	convertWidgetPath: function(path)
	{
		if (!path)
		{
			return null;
		}
		return Runtime.rs.split(".", path).map((s) =>
		{
			return Runtime.rtl.toInt(s);
		});
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.WidgetEditPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.WidgetEditPageModel);
window["BayLang.Constructor.Frontend.Editor.WidgetEditPageModel"] = BayLang.Constructor.Frontend.Editor.WidgetEditPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.WidgetEditPageModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.WidgetMenu = {
	name: "BayLang.Constructor.Frontend.Editor.WidgetMenu",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widget_menu", ((this.model.menu_selected != "") ? ("show") : ("hide"))])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["widget_menu__title"])});
			
			/* Render */
			this._t(__v1, this.getTitle());
			
			/* Element 'div' */
			let __v2 = this._e(__v0, "div", {"class":this._class_name(["widget_menu__item", ((this.model.menu_selected != "styles") ? ("hide") : (""))])});
			
			/* Component 'Styles' */
			let __v3 = this._c(__v2, "BayLang.Constructor.Frontend.Editor.Styles.Styles", {"model":this._model(this.model.styles)});
			
			/* Element 'div' */
			let __v4 = this._e(__v0, "div", {"class":this._class_name(["widget_menu__item", ((this.model.menu_selected != "css") ? ("hide") : (""))])});
			
			/* Component 'SelectedItem' */
			let __v5 = this._c(__v4, "BayLang.Constructor.Frontend.Editor.SelectedItem", {"model":this._model(this.model),"type":"css"});
			
			/* Element 'div' */
			let __v6 = this._e(__v0, "div", {"class":this._class_name(["widget_menu__item", ((this.model.menu_selected != "params") ? ("hide") : (""))])});
			
			/* Component 'SelectedItem' */
			let __v7 = this._c(__v6, "BayLang.Constructor.Frontend.Editor.SelectedItem", {"model":this._model(this.model),"type":"params"});
			
			/* Element 'div' */
			let __v8 = this._e(__v0, "div", {"class":this._class_name(["widget_menu__item", ((this.model.menu_selected != "tree") ? ("hide") : (""))])});
			
			/* Render */
			this._t(__v8, this.renderWidget(this.model.tree));
			
			return this._flatten(__v);
		},
		/**
 * Returns title
 */
		getTitle: function()
		{
			if (this.model.menu_selected == "css")
			{
				return "CSS";
			}
			if (this.model.menu_selected == "params")
			{
				return "Parameters";
			}
			if (this.model.menu_selected == "styles")
			{
				return "Styles";
			}
			if (this.model.menu_selected == "tree")
			{
				return "Tree";
			}
			return "";
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetMenu,
{
	components: function()
	{
		return Runtime.Vector.from(["BayLang.Constructor.Frontend.Editor.SelectedItem","BayLang.Constructor.Frontend.Editor.Styles.Styles"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".widget_menu.h-f350{display: flex;flex-wrap: wrap;flex-direction: column;justify-content: stretch;align-items: stretch;overflow: auto;height: 100%;width: 300px;border-left: 1px var(--widget-color-border) solid}.widget_menu.hide.h-f350{display: none}.widget_menu__title.h-f350{display: flex;align-items: center;justify-content: center;text-align: center;border-bottom: 1px var(--widget-color-border) solid;height: 32px}.widget_menu__item.h-f350{padding: 10px;overflow-y: auto;height: calc(100% - 32px);width: 100%}.widget_menu__item.hide.h-f350{display: none}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.WidgetMenu";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.WidgetMenu);
window["BayLang.Constructor.Frontend.Editor.WidgetMenu"] = BayLang.Constructor.Frontend.Editor.WidgetMenu;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.WidgetMenu;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Editor == 'undefined') BayLang.Constructor.Frontend.Editor = {};
BayLang.Constructor.Frontend.Editor.WidgetTreeItem = function(code)
{
	Runtime.Widget.Tree.TreeItem.call(this);
	this.code = code;
};
BayLang.Constructor.Frontend.Editor.WidgetTreeItem.prototype = Object.create(Runtime.Widget.Tree.TreeItem.prototype);
BayLang.Constructor.Frontend.Editor.WidgetTreeItem.prototype.constructor = BayLang.Constructor.Frontend.Editor.WidgetTreeItem;
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetTreeItem.prototype,
{
	/**
	 * Returns true if can insert inside
	 */
	canDragInside: function()
	{
		if (!this.code)
		{
			return false;
		}
		if (this.code.tag_name == "h1")
		{
			return false;
		}
		if (this.code.tag_name == "h2")
		{
			return false;
		}
		if (this.code.tag_name == "h3")
		{
			return false;
		}
		if (this.code.tag_name == "h4")
		{
			return false;
		}
		if (this.code.tag_name == "h5")
		{
			return false;
		}
		if (this.code.tag_name == "p")
		{
			return false;
		}
		if (this.code.tag_name == "span")
		{
			return false;
		}
		return true;
	},
	/**
	 * Update item
	 */
	updateLabel: function()
	{
		if (this.code instanceof BayLang.OpCodes.OpHtmlTag)
		{
			var names = this.constructor.getAttrValues(this.code.attrs, "class");
			if (names.count() == 0)
			{
				this.key = this.code.tag_name;
				this.label = this.code.tag_name;
			}
			else
			{
				var key = names.get(0);
				var keys = Runtime.rs.split(" ", key);
				this.key = key;
				this.label = this.code.tag_name + Runtime.rtl.toStr(".") + Runtime.rtl.toStr(keys.get(0));
			}
		}
		else if (this.code instanceof BayLang.OpCodes.OpHtmlSlot)
		{
			this.key = this.code.name;
			this.label = "slot." + Runtime.rtl.toStr(this.code.name);
		}
	},
	_init: function()
	{
		Runtime.Widget.Tree.TreeItem.prototype._init.call(this);
		this.code = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetTreeItem, Runtime.Widget.Tree.TreeItem);
Object.assign(BayLang.Constructor.Frontend.Editor.WidgetTreeItem,
{
	/**
	 * Returns attr values
	 */
	getAttrValues: function(attrs, name)
	{
		attrs = attrs.filter((code_attr) =>
		{
			if (code_attr.key != name)
			{
				return false;
			}
			if (!Runtime.rtl.is_instanceof(code_attr.value, "BayLang.OpCodes.OpString"))
			{
				return false;
			}
			return true;
		});
		attrs = attrs.map((code_attr) =>
		{
			return code_attr.value.value;
		});
		return attrs;
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Editor";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Editor.WidgetTreeItem";
	},
	getParentClassName: function()
	{
		return "Runtime.Widget.Tree.TreeItem";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Editor.WidgetTreeItem);
window["BayLang.Constructor.Frontend.Editor.WidgetTreeItem"] = BayLang.Constructor.Frontend.Editor.WidgetTreeItem;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Editor.WidgetTreeItem;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Layout == 'undefined') BayLang.Constructor.Frontend.Layout = {};
BayLang.Constructor.Frontend.Layout.ProjectLayout = {
	name: "BayLang.Constructor.Frontend.Layout.ProjectLayout",
	extends: Runtime.Web.DefaultLayout,
	methods:
	{
		renderMenu: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["menu"])});
			let menu = this.getMenu();
			
			for (let i = 0; i < menu.count(); i++)
			{
				let item = menu.get(i);
				
				/* Element 'div' */
				let __v1 = this._e(__v0, "div", {"class":this._class_name(["menu__item", this.menuActive(item.get("name"))])});
				
				/* Element 'a' */
				let __v2 = this._e(__v1, "a", {"href":item.get("href"),"class":this._class_name(["nolink"])});
				
				/* Render */
				this._t(__v2, item.get("label"));
			}
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["layout", "layout--" + Runtime.rtl.toStr(this.layout.layout_name)])});
			
			/* Element 'div' */
			let __v1 = this._e(__v0, "div", {"class":this._class_name(["layout__menu_wrap"])});
			
			/* Element 'div' */
			let __v2 = this._e(__v1, "div", {"class":this._class_name(["layout__title"])});
			
			/* Text */
			this._t(__v2, "Menu");
			
			/* Render */
			this._t(__v1, this.renderMenu());
			
			/* Element 'div' */
			let __v3 = this._e(__v0, "div", {"class":this._class_name(["layout__content_wrap"])});
			
			/* Element 'h1' */
			let __v4 = this._e(__v3, "h1", {"class":this._class_name(["layout__title"])});
			
			/* Render */
			this._t(__v4, this.layout.title);
			
			/* Render */
			this._t(__v3, this.renderCurrentPage());
			
			return this._flatten(__v);
		},
		/**
 * Returns menu
 */
		getMenu: function()
		{
			var arr = Runtime.Vector.from([Runtime.Map.from({"label":"Projects","name":"baylang:project:list","href":this.layout.url("baylang:project:list")}),Runtime.Map.from({"label":"Settings","name":"baylang:project:settings","href":this.layout.url("baylang:project:settings", Runtime.Map.from({"project_id":this.layout.project_id}))}),Runtime.Map.from({"label":"Widgets","name":"baylang:project:widgets","href":this.layout.url("baylang:project:widgets", Runtime.Map.from({"project_id":this.layout.project_id}))}),Runtime.Map.from({"label":"Code","name":"baylang:project:code","href":this.layout.url("baylang:project:code", Runtime.Map.from({"project_id":this.layout.project_id}))})]);
			return arr;
		},
		/**
 * Returns true if menu is active
 */
		menuActive: function(route_name)
		{
			if (this.layout.route == null)
			{
				return "";
			}
			if (this.layout.route.name == route_name)
			{
				return "menu__item--active";
			}
			return "";
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Layout.ProjectLayout,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Web.DefaultLayout"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".layout.h-1e91{position: relative;display: flex;align-items: stretch;min-height: 100%}.layout__menu_wrap.h-1e91{position: relative;width: 200px;padding-top: 10px;padding-right: 10px}.layout__content_wrap.h-1e91{position: relative;width: calc(100% - 200px);padding-top: 10px;padding-bottom: 10px}.layout__title.h-1e91{font-size: 16px;font-weight: normal;padding-bottom: 10px;margin: 0}.layout__menu_wrap.h-1e91 .layout__title{padding-left: 10px}.menu__item.h-1e91 a{display: block;padding: 10px;border-bottom: 1px solid var(--widget-color-border)}.menu__item.h-1e91 a:hover{background-color: var(--widget-color-hover)}.menu__item--active.h-1e91 a,.menu__item--active.h-1e91 a.nolink,.menu__item--active.h-1e91 a.nolink:visited{background-color: var(--widget-color-selected);border-color: var(--widget-color-selected);color: var(--widget-color-selected-text)}.menu__item.h-1e91:last-child a{border-bottom-width: 0px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Layout";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Layout.ProjectLayout";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.DefaultLayout";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Layout.ProjectLayout);
window["BayLang.Constructor.Frontend.Layout.ProjectLayout"] = BayLang.Constructor.Frontend.Layout.ProjectLayout;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Layout.ProjectLayout;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Layout == 'undefined') BayLang.Constructor.Frontend.Layout = {};
BayLang.Constructor.Frontend.Layout.ProjectLayoutModel = function()
{
	Runtime.Web.BaseLayoutModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Layout.ProjectLayoutModel.prototype = Object.create(Runtime.Web.BaseLayoutModel.prototype);
BayLang.Constructor.Frontend.Layout.ProjectLayoutModel.prototype.constructor = BayLang.Constructor.Frontend.Layout.ProjectLayoutModel;
Object.assign(BayLang.Constructor.Frontend.Layout.ProjectLayoutModel.prototype,
{
	/**
	 * Load data
	 */
	loadData: async function(container)
	{
		Runtime.Web.BaseLayoutModel.prototype.loadData.call(this, container);
		this.project_id = this.layout.route.matches.get("project_id");
		this.module_id = this.layout.route.matches.get("module_id");
	},
	/**
	 * Process frontend data
	 */
	serialize: function(serializer, data)
	{
		serializer.process(this, "module_id", data);
		serializer.process(this, "page_title", data);
		serializer.process(this, "project_id", data);
		Runtime.Web.BaseLayoutModel.prototype.serialize.call(this, serializer, data);
	},
	_init: function()
	{
		Runtime.Web.BaseLayoutModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Layout.ProjectLayout";
		this.page_title = "";
		this.project_id = "";
		this.module_id = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Layout.ProjectLayoutModel, Runtime.Web.BaseLayoutModel);
Object.assign(BayLang.Constructor.Frontend.Layout.ProjectLayoutModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Layout";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Layout.ProjectLayoutModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BaseLayoutModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Layout.ProjectLayoutModel);
window["BayLang.Constructor.Frontend.Layout.ProjectLayoutModel"] = BayLang.Constructor.Frontend.Layout.ProjectLayoutModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Layout.ProjectLayoutModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Module == 'undefined') BayLang.Constructor.Frontend.Module = {};
BayLang.Constructor.Frontend.Module.ModuleList = {
	name: "BayLang.Constructor.Frontend.Module.ModuleList",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["modules_list"])});
			
			/* Component 'Table' */
			let __v1 = this._c(__v0, "Runtime.Widget.Table.Table", {"model":this._model(this.model.table),"class":this._class_name(["modules_table"])});
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Module.ModuleList,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.RowButtons","Runtime.Widget.Table.Table"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".top_buttons.h-e97b{margin-bottom: 10px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Module";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Module.ModuleList";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Module.ModuleList);
window["BayLang.Constructor.Frontend.Module.ModuleList"] = BayLang.Constructor.Frontend.Module.ModuleList;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Module.ModuleList;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Module == 'undefined') BayLang.Constructor.Frontend.Module = {};
BayLang.Constructor.Frontend.Module.ModuleListModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Module.ModuleListModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Module.ModuleListModel.prototype.constructor = BayLang.Constructor.Frontend.Module.ModuleListModel;
Object.assign(BayLang.Constructor.Frontend.Module.ModuleListModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Project id */
		this.project_id = this.layout.route.matches.get("project_id");
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableModel", Runtime.Map.from({"widget_name":"table","get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "add")
			{
				return "Add module";
			}
			if (action == "edit")
			{
				return "Edit module " + Runtime.rtl.toStr(item.get("id"));
			}
			if (action == "delete")
			{
				return "Delete module " + Runtime.rtl.toStr(item.get("id"));
			}
			return "";
		},"styles":Runtime.Vector.from(["border"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"baylang.constructor.module::search"})),"foreign_key":Runtime.Map.from({"project_id":this.project_id}),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"id","label":"ID","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.RowButtonsModel", Runtime.Map.from({"buttons":Runtime.Vector.from([Runtime.Map.from({"widget_name":"open","content":"Open","href":(data) =>
		{
			var item = data.get("item");
			return this.layout.url("baylang:project:widgets", Runtime.Map.from({"project_id":this.project_id,"module_id":item.get("id")}));
		},"styles":Runtime.Vector.from(["default","small"])})])}))})])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Modules");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Module.ModuleList";
		this.project_id = "";
	},
});
Object.assign(BayLang.Constructor.Frontend.Module.ModuleListModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Module.ModuleListModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Module";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Module.ModuleListModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Module.ModuleListModel);
window["BayLang.Constructor.Frontend.Module.ModuleListModel"] = BayLang.Constructor.Frontend.Module.ModuleListModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Module.ModuleListModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Project == 'undefined') BayLang.Constructor.Frontend.Project = {};
BayLang.Constructor.Frontend.Project.ProjectList = {
	name: "BayLang.Constructor.Frontend.Project.ProjectList",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["project_list"])});
			
			/* Element 'h1' */
			let __v1 = this._e(__v0, "h1", {});
			
			/* Text */
			this._t(__v1, "Projects");
			
			/* Component 'RowButtons' */
			let __v2 = this._c(__v0, "Runtime.Widget.RowButtons", {"model":this._model(this.model.top_buttons),"class":this._class_name(["top_buttons"])});
			
			/* Component 'Table' */
			let __v3 = this._c(__v0, "Runtime.Widget.Table.Table", {"model":this._model(this.model.table),"class":this._class_name(["projects_table"])});
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Project.ProjectList,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.RowButtons","Runtime.Widget.Table.Table"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".top_buttons.h-c43e{margin-bottom: 10px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Project";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Project.ProjectList";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Project.ProjectList);
window["BayLang.Constructor.Frontend.Project.ProjectList"] = BayLang.Constructor.Frontend.Project.ProjectList;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Project.ProjectList;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Project == 'undefined') BayLang.Constructor.Frontend.Project = {};
BayLang.Constructor.Frontend.Project.ProjectListModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Project.ProjectListModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Project.ProjectListModel.prototype.constructor = BayLang.Constructor.Frontend.Project.ProjectListModel;
Object.assign(BayLang.Constructor.Frontend.Project.ProjectListModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "add")
			{
				return "Add item";
			}
			if (action == "edit")
			{
				return "Edit item " + Runtime.rtl.toStr(item.get("id"));
			}
			if (action == "delete")
			{
				return "Delete item " + Runtime.rtl.toStr(item.get("id"));
			}
			return "";
		},"styles":Runtime.Vector.from(["border"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"baylang.constructor.project::search"})),"add_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"add_form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSubmitStorage", Runtime.Map.from({"api_name":"baylang.constructor.project::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"id","label":"ID","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"template","label":"Template","component":"Runtime.Widget.Select","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":"web","value":"Web project"})])})}),Runtime.Map.from({"name":"description","label":"Description","component":"Runtime.Widget.TextArea"})])})),"edit_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"edit_form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSubmitStorage", Runtime.Map.from({"api_name":"baylang.constructor.project::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"id","label":"ID","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"description","label":"Description","component":"Runtime.Widget.TextArea"})])})),"delete_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"delete_form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormDeleteStorage", Runtime.Map.from({"api_name":"baylang.constructor.project::save"}))})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"id","label":"ID","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel", Runtime.Map.from({"buttons":Runtime.Vector.from([Runtime.Map.from({"href":(data) =>
		{
			var item = data.get("item");
			return this.layout.url("baylang:project:settings", Runtime.Map.from({"project_id":item.get("id")}));
		},"kind":"before","dest":"edit_button","content":"Open","widget_name":"open","styles":Runtime.Vector.from(["default","small"])})])}))})])}));
		/* Add top buttons */
		this.top_buttons = this.addWidget("Runtime.Widget.RowButtonsModel", Runtime.Map.from({"widget_name":"top_buttons","buttons":Runtime.Vector.from([new Runtime.Web.ModelFactory("Runtime.Widget.Table.AddButtonModel", Runtime.Map.from({"table":this.table}))])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Projects");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Project.ProjectList";
	},
});
Object.assign(BayLang.Constructor.Frontend.Project.ProjectListModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Project.ProjectListModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Project";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Project.ProjectListModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Project.ProjectListModel);
window["BayLang.Constructor.Frontend.Project.ProjectListModel"] = BayLang.Constructor.Frontend.Project.ProjectListModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Project.ProjectListModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Settings == 'undefined') BayLang.Constructor.Frontend.Settings = {};
BayLang.Constructor.Frontend.Settings.ReloadCache = {
	name: "BayLang.Constructor.Frontend.Settings.ReloadCache",
	extends: Runtime.Web.Component,
	data: function ()
	{
		return {
			result: new Runtime.Widget.WidgetResultModel(),
		};
	},
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["reload_cache"])});
			
			/* Component 'Button' */
			let __v1 = this._c(__v0, "Runtime.Widget.Button", {"onClick":this.onRefresh}, () => {
				let __v = [];
				
				/* Text */
				this._t(__v, "Reload");
				
				return this._flatten(__v);
			});
			
			/* Component 'WidgetResult' */
			let __v2 = this._c(__v0, "Runtime.Widget.WidgetResult", {"model":this._model(this.result)});
			
			return this._flatten(__v);
		},
		/**
 * Refresh item
 */
		onRefresh: async function()
		{
			this.result.clear();
			this.result.setWaitMessage();
			/* Get primary key */
			var form = this.data.get("form");
			var pk = form.getPrimaryKey(form.item);
			/* Reload cache */
			var res = await this.layout.callApi(Runtime.Map.from({"api_name":"baylang.constructor.project::save","method_name":"reloadCache","data":Runtime.Map.from({"pk":pk})}));
			this.result.setApiResult(res);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Settings.ReloadCache,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Button"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".reload_cache.h-5951{display: flex;align-items: center;gap: 5px}.reload_cache.h-5951 .widget_result.h-e870{margin-top: 0}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Settings";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Settings.ReloadCache";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Settings.ReloadCache);
window["BayLang.Constructor.Frontend.Settings.ReloadCache"] = BayLang.Constructor.Frontend.Settings.ReloadCache;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Settings.ReloadCache;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Settings == 'undefined') BayLang.Constructor.Frontend.Settings = {};
BayLang.Constructor.Frontend.Settings.Settings = {
	name: "BayLang.Constructor.Frontend.Settings.Settings",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["settings"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.edit_form));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Settings.Settings,
{
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr("");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Settings";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Settings.Settings";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Settings.Settings);
window["BayLang.Constructor.Frontend.Settings.Settings"] = BayLang.Constructor.Frontend.Settings.Settings;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Settings.Settings;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Settings == 'undefined') BayLang.Constructor.Frontend.Settings = {};
BayLang.Constructor.Frontend.Settings.SettingsModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Settings.SettingsModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Settings.SettingsModel.prototype.constructor = BayLang.Constructor.Frontend.Settings.SettingsModel;
Object.assign(BayLang.Constructor.Frontend.Settings.SettingsModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Project id */
		this.project_id = this.layout.route.matches.get("project_id");
		/* Edit form */
		this.edit_form = this.addWidget("Runtime.Widget.Form.FormSubmitModel", Runtime.Map.from({"widget_name":"edit_form","primary_key":Runtime.Vector.from(["id"]),"pk":Runtime.Map.from({"id":this.project_id}),"submit_button":Runtime.Map.from({"text":"Save","styles":Runtime.Vector.from(["success","large"])}),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSaveStorage", Runtime.Map.from({"api_name":"baylang.constructor.project::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"description","label":"Description","component":"Runtime.Widget.TextArea","props":Runtime.Map.from({"height":"150px"})}),Runtime.Map.from({"name":"reload_cache","label":"Reload cache","component":"BayLang.Constructor.Frontend.Settings.ReloadCache"})])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Settings");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Settings.Settings";
		this.project_id = "";
		this.edit_form = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Settings.SettingsModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Settings.SettingsModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Settings";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Settings.SettingsModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Settings.SettingsModel);
window["BayLang.Constructor.Frontend.Settings.SettingsModel"] = BayLang.Constructor.Frontend.Settings.SettingsModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Settings.SettingsModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Widget == 'undefined') BayLang.Constructor.Frontend.Widget = {};
BayLang.Constructor.Frontend.Widget.WidgetList = {
	name: "BayLang.Constructor.Frontend.Widget.WidgetList",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["widgets_list"])});
			
			/* Component 'RowButtons' */
			let __v1 = this._c(__v0, "Runtime.Widget.RowButtons", {"model":this._model(this.model.top_buttons),"class":this._class_name(["top_buttons"])});
			
			/* Component 'Table' */
			let __v2 = this._c(__v0, "Runtime.Widget.Table.Table", {"model":this._model(this.model.table),"class":this._class_name(["widgets_table"])});
			
			return this._flatten(__v);
		},
	},
};
Object.assign(BayLang.Constructor.Frontend.Widget.WidgetList,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.RowButtons","Runtime.Widget.Table.Table"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".top_buttons.h-1ea1{margin-bottom: 10px}");
		return res;
	},
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Widget.WidgetList";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Widget.WidgetList);
window["BayLang.Constructor.Frontend.Widget.WidgetList"] = BayLang.Constructor.Frontend.Widget.WidgetList;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Widget.WidgetList;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
if (typeof BayLang.Constructor.Frontend.Widget == 'undefined') BayLang.Constructor.Frontend.Widget = {};
BayLang.Constructor.Frontend.Widget.WidgetListModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
BayLang.Constructor.Frontend.Widget.WidgetListModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
BayLang.Constructor.Frontend.Widget.WidgetListModel.prototype.constructor = BayLang.Constructor.Frontend.Widget.WidgetListModel;
Object.assign(BayLang.Constructor.Frontend.Widget.WidgetListModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Set route matches */
		this.project_id = this.layout.route.matches.get("project_id");
		/* Modules */
		this.modules = this.addWidget("Runtime.Widget.SelectModel", Runtime.Map.from({"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"baylang.constructor.module::search"})),"widget_name":"modules","transform":(item) =>
		{
			return Runtime.Map.from({"key":item.get("id"),"value":item.get("id")});
		},"foreign_key":Runtime.Map.from({"project_id":this.project_id})}));
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "add")
			{
				return "Add widget";
			}
			if (action == "edit")
			{
				return "Edit widget " + Runtime.rtl.toStr(item.get("id"));
			}
			if (action == "delete")
			{
				return "Delete widget " + Runtime.rtl.toStr(item.get("id"));
			}
			return "";
		},"styles":Runtime.Vector.from(["border"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"baylang.constructor.widget::search"})),"add_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"add_form","primary_key":Runtime.Vector.from(["id"]),"foreign_key":Runtime.Map.from({"project_id":this.project_id}),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSubmitStorage", Runtime.Map.from({"api_name":"baylang.constructor.widget::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"module_id","label":"Modules","model":this.modules}),Runtime.Map.from({"name":"id","label":"Name","component":"Runtime.Widget.Input","default":"WidgetModel"})]),"events":Runtime.Map.from({"field_change":new Runtime.Callback(this, "onFormFieldChange")})})),"delete_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"delete_form","primary_key":Runtime.Vector.from(["id"]),"foreign_key":Runtime.Map.from({"project_id":this.project_id}),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormDeleteStorage", Runtime.Map.from({"api_name":"baylang.constructor.widget::save"}))})),"foreign_key":Runtime.Map.from({"project_id":this.project_id,"module_id":this.module_id}),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"id","label":"Widget name","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel", Runtime.Map.from({"edit":false,"buttons":Runtime.Vector.from([Runtime.Map.from({"widget_name":"edit_button","dest":"delete_button","kind":"before","href":(data) =>
		{
			var item = data.get("item");
			return this.layout.url("baylang:project:widget:edit", Runtime.Map.from({"project_id":this.project_id,"module_id":this.module_id,"widget_name":item.get("id")}));
		},"content":"Edit","styles":Runtime.Vector.from(["default","small"])})]),"events":Runtime.Map.from({"click":new Runtime.Callback(this, "onRowButtonClick")})}))})])}));
		/* Add top buttons */
		this.top_buttons = this.addWidget("Runtime.Widget.RowButtonsModel", Runtime.Map.from({"widget_name":"top_buttons","buttons":Runtime.Vector.from([new Runtime.Web.ModelFactory("Runtime.Widget.Table.AddButtonModel", Runtime.Map.from({"table":this.table}))])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Widgets");
	},
	/**
	 * Table row button click
	 */
	onRowButtonClick: function(message)
	{
		var button = message.widget;
		if (button.widget_name != "delete_button")
		{
			return ;
		}
		/* Set delete form foreign key */
		var module_id = message.data.get("item").get("module_id");
		this.table.delete_form.foreign_key.set("module_id", module_id);
	},
	/**
	 * Form field change
	 */
	onFormFieldChange: function(message)
	{
		var field_name = message.field_name;
		var old_value = message.old_value;
		var value = message.value;
		if (field_name != "module_id")
		{
			return ;
		}
		/* Get form */
		var form = message.widget;
		var widget_id = form.item.get("id");
		/* Set foreign key */
		form.foreign_key.set("module_id", value);
		/* Set widget name */
		if (Runtime.rs.indexOf(widget_id, old_value) == 0)
		{
			widget_id = Runtime.rs.substr(widget_id, Runtime.rs.strlen(old_value));
		}
		if (value != "" && Runtime.rs.indexOf(widget_id, value) == 0)
		{
			return ;
		}
		if (Runtime.rs.substr(widget_id, 0, 1) == ".")
		{
			widget_id = Runtime.rs.substr(widget_id, 1);
		}
		if (Runtime.rs.substr(widget_id, 0, 11) == "Components.")
		{
			widget_id = Runtime.rs.substr(widget_id, 11);
		}
		if (value != "")
		{
			widget_id = value + Runtime.rtl.toStr(".Components.") + Runtime.rtl.toStr(widget_id);
		}
		form.item.set("id", widget_id);
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "BayLang.Constructor.Frontend.Widget.WidgetList";
		this.project_id = "";
		this.module_id = "";
		this.modules = null;
		this.table = null;
		this.top_buttons = null;
	},
});
Object.assign(BayLang.Constructor.Frontend.Widget.WidgetListModel, Runtime.Web.BasePageModel);
Object.assign(BayLang.Constructor.Frontend.Widget.WidgetListModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend.Widget";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.Widget.WidgetListModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.Widget.WidgetListModel);
window["BayLang.Constructor.Frontend.Widget.WidgetListModel"] = BayLang.Constructor.Frontend.Widget.WidgetListModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.Widget.WidgetListModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
BayLang.Constructor.Frontend.ConstructorHook = function()
{
	Runtime.BaseHook.apply(this, arguments);
};
BayLang.Constructor.Frontend.ConstructorHook.prototype = Object.create(Runtime.BaseHook.prototype);
BayLang.Constructor.Frontend.ConstructorHook.prototype.constructor = BayLang.Constructor.Frontend.ConstructorHook;
Object.assign(BayLang.Constructor.Frontend.ConstructorHook.prototype,
{
	/**
	 * Register hooks
	 */
	register_hooks: function()
	{
		this.register(this.constructor.GET_FRAME_PAGE_URL);
	},
	/**
	 * Returns method name by hook name
	 */
	getMethodName: function(hook_name)
	{
		if (hook_name == this.constructor.GET_FRAME_PAGE_URL)
		{
			return "get_frame_page_url";
		}
		return "";
	},
	/**
	 * Returns projects list
	 */
	get_frame_page_url: function(params)
	{
		var page_url = "/project/" + Runtime.rtl.toStr(params.get("project_id")) + Runtime.rtl.toStr("/iframe/open/widget?widget_name=") + Runtime.rtl.toStr(params.get("current_widget"));
		params.set("page_url", page_url);
	},
});
Object.assign(BayLang.Constructor.Frontend.ConstructorHook, Runtime.BaseHook);
Object.assign(BayLang.Constructor.Frontend.ConstructorHook,
{
	GET_FRAME_PAGE_URL: "baylang.constructor::get_frame_page_url",
	/**
	 * Returns projects list
	 */
	getFramePageUrl: function(project_id, current_widget)
	{
		var result = Runtime.rtl.getContext().callHook(this.GET_FRAME_PAGE_URL, Runtime.Map.from({"page_url":"","project_id":project_id,"current_widget":current_widget}));
		return result.get("page_url");
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.ConstructorHook";
	},
	getParentClassName: function()
	{
		return "Runtime.BaseHook";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.ConstructorHook);
window["BayLang.Constructor.Frontend.ConstructorHook"] = BayLang.Constructor.Frontend.ConstructorHook;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.ConstructorHook;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof BayLang == 'undefined') BayLang = {};
if (typeof BayLang.Constructor == 'undefined') BayLang.Constructor = {};
if (typeof BayLang.Constructor.Frontend == 'undefined') BayLang.Constructor.Frontend = {};
BayLang.Constructor.Frontend.ModuleDescription = function()
{
};
Object.assign(BayLang.Constructor.Frontend.ModuleDescription.prototype,
{
});
Object.assign(BayLang.Constructor.Frontend.ModuleDescription,
{
	/**
	 * Returns module name
	 * @return string
	 */
	getModuleName: function()
	{
		return "BayLang.Constructor.Frontend";
	},
	/**
	 * Returns module name
	 * @return string
	 */
	getModuleVersion: function()
	{
		return "0.0.1";
	},
	/**
	 * Returns required modules
	 * @return Dict<string>
	 */
	requiredModules: function()
	{
		return Runtime.Map.from({"Runtime":">=0.12","Runtime.Web":">=0.12","Runtime.Widget":">=0.12"});
	},
	/**
	 * Returns enities
	 */
	entities: function()
	{
		return Runtime.Vector.from([new Runtime.Web.Annotations.SetupLayout(Runtime.Map.from({"project":"BayLang.Constructor.Frontend.Layout.ProjectLayoutModel"}))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "BayLang.Constructor.Frontend";
	},
	getClassName: function()
	{
		return "BayLang.Constructor.Frontend.ModuleDescription";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(BayLang.Constructor.Frontend.ModuleDescription);
window["BayLang.Constructor.Frontend.ModuleDescription"] = BayLang.Constructor.Frontend.ModuleDescription;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = BayLang.Constructor.Frontend.ModuleDescription;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.FormData == 'undefined') Runtime.WordPress.Admin.FormData = {};
Runtime.WordPress.Admin.FormData.FormDataPage = {
	name: "Runtime.WordPress.Admin.FormData.FormDataPage",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["form_data_page"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.table));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.FormData.FormDataPage,
{
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.FormData";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.FormData.FormDataPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.FormData.FormDataPage);
window["Runtime.WordPress.Admin.FormData.FormDataPage"] = Runtime.WordPress.Admin.FormData.FormDataPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.FormData.FormDataPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.FormData == 'undefined') Runtime.WordPress.Admin.FormData = {};
Runtime.WordPress.Admin.FormData.FormDataPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
Runtime.WordPress.Admin.FormData.FormDataPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
Runtime.WordPress.Admin.FormData.FormDataPageModel.prototype.constructor = Runtime.WordPress.Admin.FormData.FormDataPageModel;
Object.assign(Runtime.WordPress.Admin.FormData.FormDataPageModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Calculate data */
		var calculateData = (data) =>
		{
			var item = data.get("item");
			if (item.get("data") == null)
			{
				return "";
			}
			var items = item.get("data").transition((value, key) =>
			{
				return key + Runtime.rtl.toStr(": ") + Runtime.rtl.toStr(value);
			});
			if (data.has("table"))
			{
				return items;
			}
			return Runtime.rs.join("\n", items);
		};
		/* Add form */
		this.form = this.addWidget("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"form","primary_key":Runtime.Vector.from(["id"]),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"form_title","label":"Title","component":"Runtime.Widget.Input","props":Runtime.Map.from({"readonly":true})}),Runtime.Map.from({"name":"data","label":"Data","component":"Runtime.Widget.TextArea","calculate":calculateData,"props":Runtime.Map.from({"readonly":true})}),Runtime.Map.from({"name":"gmtime_add","label":"Data","component":"Runtime.Widget.Input","calculate":Runtime.lib.pipe().add(Runtime.lib.attr(Runtime.Vector.from(["item","gmtime_add"]))).add(Runtime.lib.normalizeDateTime()),"props":Runtime.Map.from({"readonly":true})})])}));
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","styles":Runtime.Vector.from(["border"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"admin.wordpress.forms.data::search"})),"page":this.layout.request_query.get("p", 1) - 1,"pagination_props":Runtime.Map.from({"name":"p"}),"edit_form":this.form,"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"form_title","label":"Title","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"data","label":"Data","calculate":calculateData,"component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"send_email_error","label":"Mail error","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"gmtime_add","label":"Date","calculate":Runtime.lib.pipe().add(Runtime.lib.attr(Runtime.Vector.from(["item","gmtime_add"]))).add(Runtime.lib.normalizeDateTime()),"component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel", Runtime.Map.from({"delete":false}))})])}));
		/* Remove save button */
		var save_dialog = this.table.getWidget("save_dialog");
		save_dialog.buttons.removeItemByName("confirm_button");
		/* Change cancel button text */
		var cancel_button = save_dialog.buttons.findItemByName("cancel_button");
		cancel_button.content = "Close";
		/* Table row buttons */
		var row_buttons = this.table.getWidget("row_buttons");
		var edit_button = row_buttons.findItemByName("edit_button");
		edit_button.content = "View";
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Forms data");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.FormData.FormDataPage";
		this.form = null;
		this.table = null;
	},
});
Object.assign(Runtime.WordPress.Admin.FormData.FormDataPageModel, Runtime.Web.BasePageModel);
Object.assign(Runtime.WordPress.Admin.FormData.FormDataPageModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.FormData";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.FormData.FormDataPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.FormData.FormDataPageModel);
window["Runtime.WordPress.Admin.FormData.FormDataPageModel"] = Runtime.WordPress.Admin.FormData.FormDataPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.FormData.FormDataPageModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.FormSettings == 'undefined') Runtime.WordPress.Admin.FormSettings = {};
Runtime.WordPress.Admin.FormSettings.FormSettingsPage = {
	name: "Runtime.WordPress.Admin.FormSettings.FormSettingsPage",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["form_settings_page"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.top_buttons));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.table));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.FormSettings.FormSettingsPage,
{
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.FormSettings";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.FormSettings.FormSettingsPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.FormSettings.FormSettingsPage);
window["Runtime.WordPress.Admin.FormSettings.FormSettingsPage"] = Runtime.WordPress.Admin.FormSettings.FormSettingsPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.FormSettings.FormSettingsPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.FormSettings == 'undefined') Runtime.WordPress.Admin.FormSettings = {};
Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel.prototype.constructor = Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel;
Object.assign(Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Add form */
		this.form = this.addWidget("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSaveStorage", Runtime.Map.from({"api_name":"admin.wordpress.forms.settings::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"api_name","label":"Api name","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"email_to","label":"Email to","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"settings","label":"Settings","component":"Runtime.Widget.TextArea"})])}));
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","styles":Runtime.Vector.from(["border"]),"get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "add")
			{
				return "Add form";
			}
			if (action == "edit")
			{
				return "Edit form '" + Runtime.rtl.toStr(item.get("api_name")) + Runtime.rtl.toStr("'");
			}
			if (action == "delete")
			{
				return "Delete form '" + Runtime.rtl.toStr(item.get("api_name")) + Runtime.rtl.toStr("'");
			}
			return "";
		},"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"admin.wordpress.forms.settings::search"})),"page":this.layout.request_query.get("p", 1) - 1,"pagination_props":Runtime.Map.from({"name":"p"}),"add_form":this.form,"edit_form":this.form,"delete_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"delete_form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormDeleteStorage", Runtime.Map.from({"api_name":"admin.wordpress.forms.settings::save"}))})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"name","label":"Name","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"api_name","label":"Api name","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"email_to","label":"Email to","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel")})])}));
		/* Add top buttons */
		this.top_buttons = this.addWidget("Runtime.Widget.RowButtonsModel", Runtime.Map.from({"widget_name":"top_buttons","styles":Runtime.Vector.from(["top_buttons"]),"buttons":Runtime.Vector.from([new Runtime.Web.ModelFactory("Runtime.Widget.Table.AddButtonModel", Runtime.Map.from({"table":this.table}))])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Forms settings");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.FormSettings.FormSettingsPage";
		this.form = null;
		this.table = null;
		this.top_buttons = null;
	},
});
Object.assign(Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel, Runtime.Web.BasePageModel);
Object.assign(Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.FormSettings";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel);
window["Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel"] = Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.FormSettings.FormSettingsPageModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.MailLog == 'undefined') Runtime.WordPress.Admin.MailLog = {};
Runtime.WordPress.Admin.MailLog.MailLogPage = {
	name: "Runtime.WordPress.Admin.MailLog.MailLogPage",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["form_settings_page"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.table));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.MailLog.MailLogPage,
{
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.MailLog";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.MailLog.MailLogPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.MailLog.MailLogPage);
window["Runtime.WordPress.Admin.MailLog.MailLogPage"] = Runtime.WordPress.Admin.MailLog.MailLogPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.MailLog.MailLogPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.MailLog == 'undefined') Runtime.WordPress.Admin.MailLog = {};
Runtime.WordPress.Admin.MailLog.MailLogPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
Runtime.WordPress.Admin.MailLog.MailLogPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
Runtime.WordPress.Admin.MailLog.MailLogPageModel.prototype.constructor = Runtime.WordPress.Admin.MailLog.MailLogPageModel;
Object.assign(Runtime.WordPress.Admin.MailLog.MailLogPageModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Normalize DateTime */
		var normalizeDateTime = (field_name) =>
		{
			return (data) =>
			{
				var item = data.get("item");
				var date_time = item.get(field_name);
				if (!date_time)
				{
					return "";
				}
				return date_time.normalize().getDateTimeString();
			};
		};
		/* Add form */
		this.form = this.addWidget("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"form","primary_key":Runtime.Vector.from(["id"]),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"gmtime_send","label":"Send time","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"status","label":"Status","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"send_email_error","label":"Error","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"dest","label":"Dest","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"title","label":"Title","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"message","label":"Message","component":"Runtime.Widget.TextArea","props":Runtime.Map.from({"readonly":true})}),Runtime.Map.from({"name":"worker","label":"Worker","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"plan","label":"Plan","component":"Runtime.Widget.Label"})])}));
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","styles":Runtime.Vector.from(["border"]),"get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "edit")
			{
				return item.get("title");
			}
			return "";
		},"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"admin.wordpress.mail.log::search"})),"page":this.layout.request_query.get("p", 1) - 1,"pagination_props":Runtime.Map.from({"name":"p"}),"add_form":this.form,"edit_form":this.form,"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"worker","label":"Worker","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"plan","label":"Plan","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"status","label":"Status","component":"Runtime.Widget.SelectLabel","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":-1,"value":"Cancel"})])})}),Runtime.Map.from({"name":"dest","label":"Dest","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"title","label":"Title","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"send_email_error","label":"Error","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"gmtime_send","label":"Send time","calculate":Runtime.lib.pipe().add(Runtime.lib.attr(Runtime.Vector.from(["item","gmtime_send"]))).add(Runtime.lib.normalizeDateTime()),"component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel", Runtime.Map.from({"delete":false}))})])}));
		/* Remove save button */
		var save_dialog = this.table.getWidget("save_dialog");
		save_dialog.buttons.removeItemByName("confirm_button");
		/* Change cancel button text */
		var cancel_button = save_dialog.buttons.findItemByName("cancel_button");
		cancel_button.content = "Close";
		/* Table row buttons */
		var row_buttons = this.table.getWidget("row_buttons");
		var edit_button = row_buttons.findItemByName("edit_button");
		edit_button.content = "View";
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Mail log");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.MailLog.MailLogPage";
		this.form = null;
		this.table = null;
		this.top_buttons = null;
	},
});
Object.assign(Runtime.WordPress.Admin.MailLog.MailLogPageModel, Runtime.Web.BasePageModel);
Object.assign(Runtime.WordPress.Admin.MailLog.MailLogPageModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.MailLog";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.MailLog.MailLogPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.MailLog.MailLogPageModel);
window["Runtime.WordPress.Admin.MailLog.MailLogPageModel"] = Runtime.WordPress.Admin.MailLog.MailLogPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.MailLog.MailLogPageModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.MailSettings == 'undefined') Runtime.WordPress.Admin.MailSettings = {};
Runtime.WordPress.Admin.MailSettings.MailSettingsPage = {
	name: "Runtime.WordPress.Admin.MailSettings.MailSettingsPage",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["form_settings_page"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.top_buttons));
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.table));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.MailSettings.MailSettingsPage,
{
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.MailSettings";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.MailSettings.MailSettingsPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.MailSettings.MailSettingsPage);
window["Runtime.WordPress.Admin.MailSettings.MailSettingsPage"] = Runtime.WordPress.Admin.MailSettings.MailSettingsPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.MailSettings.MailSettingsPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.MailSettings == 'undefined') Runtime.WordPress.Admin.MailSettings = {};
Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel.prototype.constructor = Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel;
Object.assign(Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Add form */
		this.form = this.addWidget("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSaveStorage", Runtime.Map.from({"api_name":"admin.wordpress.mail.settings::save"})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"enable","label":"Enable","component":"Runtime.Widget.Select","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":"0","value":"No"}),Runtime.Map.from({"key":"1","value":"Yes"})])})}),Runtime.Map.from({"name":"plan","label":"Plan","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"host","label":"Host","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"port","label":"Port","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"login","label":"Login","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"password","label":"Password","component":"Runtime.Widget.Input"}),Runtime.Map.from({"name":"ssl_enable","label":"SSL","component":"Runtime.Widget.Select","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":"0","value":"No"}),Runtime.Map.from({"key":"1","value":"Yes"})])})})])}));
		/* Add table */
		this.table = this.addWidget("Runtime.Widget.Table.TableDialogModel", Runtime.Map.from({"widget_name":"table","styles":Runtime.Vector.from(["border"]),"get_title":(params) =>
		{
			var action = params.get("action");
			var item = params.get("item");
			if (action == "add")
			{
				return "Add mail";
			}
			if (action == "edit")
			{
				return "Edit mail '" + Runtime.rtl.toStr(item.get("plan")) + Runtime.rtl.toStr("'");
			}
			if (action == "delete")
			{
				return "Delete mail '" + Runtime.rtl.toStr(item.get("plan")) + Runtime.rtl.toStr("'");
			}
			return "";
		},"storage":new Runtime.Entity.Factory("Runtime.Widget.Table.TableStorage", Runtime.Map.from({"api_name":"admin.wordpress.mail.settings::search"})),"page":this.layout.request_query.get("p", 1) - 1,"pagination_props":Runtime.Map.from({"name":"p"}),"add_form":this.form,"edit_form":this.form,"delete_form":new Runtime.Web.ModelFactory("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"delete_form","primary_key":Runtime.Vector.from(["id"]),"storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormDeleteStorage", Runtime.Map.from({"api_name":"admin.wordpress.mail.settings::save"}))})),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"row_number"}),Runtime.Map.from({"name":"enable","label":"Enable","component":"Runtime.Widget.SelectLabel","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":"0","value":"No"}),Runtime.Map.from({"key":"1","value":"Yes"})])})}),Runtime.Map.from({"name":"plan","label":"Plan","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"host","label":"Host","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"port","label":"Port","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"login","label":"Login","component":"Runtime.Widget.Label"}),Runtime.Map.from({"name":"ssl_enable","label":"SSL","component":"Runtime.Widget.SelectLabel","props":Runtime.Map.from({"options":Runtime.Vector.from([Runtime.Map.from({"key":"0","value":"No"}),Runtime.Map.from({"key":"1","value":"Yes"})])})}),Runtime.Map.from({"name":"row_buttons","model":new Runtime.Web.ModelFactory("Runtime.Widget.Table.TableRowButtonsModel")})])}));
		/* Add top buttons */
		this.top_buttons = this.addWidget("Runtime.Widget.RowButtonsModel", Runtime.Map.from({"widget_name":"top_buttons","styles":Runtime.Vector.from(["top_buttons"]),"buttons":Runtime.Vector.from([new Runtime.Web.ModelFactory("Runtime.Widget.Table.AddButtonModel", Runtime.Map.from({"table":this.table}))])}));
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Mail settings");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.MailSettings.MailSettingsPage";
		this.form = null;
		this.table = null;
		this.top_buttons = null;
	},
});
Object.assign(Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel, Runtime.Web.BasePageModel);
Object.assign(Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.MailSettings";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel);
window["Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel"] = Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.MailSettings.MailSettingsPageModel;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.Robots == 'undefined') Runtime.WordPress.Admin.Robots = {};
Runtime.WordPress.Admin.Robots.RobotsPage = {
	name: "Runtime.WordPress.Admin.Robots.RobotsPage",
	extends: Runtime.Web.Component,
	methods:
	{
		render: function()
		{
			let __v = [];
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["form_settings_page"])});
			
			/* Render */
			this._t(__v0, this.renderWidget(this.model.form));
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.Robots.RobotsPage,
{
	css: function(vars)
	{
		var res = "";
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.Robots";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.Robots.RobotsPage";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.Robots.RobotsPage);
window["Runtime.WordPress.Admin.Robots.RobotsPage"] = Runtime.WordPress.Admin.Robots.RobotsPage;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.Robots.RobotsPage;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
if (typeof Runtime.WordPress.Admin.Robots == 'undefined') Runtime.WordPress.Admin.Robots = {};
Runtime.WordPress.Admin.Robots.RobotsPageModel = function()
{
	Runtime.Web.BasePageModel.apply(this, arguments);
};
Runtime.WordPress.Admin.Robots.RobotsPageModel.prototype = Object.create(Runtime.Web.BasePageModel.prototype);
Runtime.WordPress.Admin.Robots.RobotsPageModel.prototype.constructor = Runtime.WordPress.Admin.Robots.RobotsPageModel;
Object.assign(Runtime.WordPress.Admin.Robots.RobotsPageModel.prototype,
{
	/**
	 * Init widget settings
	 */
	initWidget: function(params)
	{
		Runtime.Web.BasePageModel.prototype.initWidget.call(this, params);
		/* Add form */
		this.form = this.addWidget("Runtime.Widget.Form.FormModel", Runtime.Map.from({"widget_name":"form","storage":new Runtime.Entity.Factory("Runtime.Widget.Form.FormSaveStorage", Runtime.Map.from({"api_name":"admin.wordpress.robots::save"})),"pk":Runtime.Vector.from([]),"fields":Runtime.Vector.from([Runtime.Map.from({"name":"content","component":"Runtime.Widget.TextArea"})])}));
		/* Add save button */
		this.form.bottom_buttons.addButton(Runtime.Map.from({"widget_name":"save_button","content":"Save","styles":Runtime.Vector.from(["large","primary"]),"events":Runtime.Map.from({"click":new Runtime.Callback(this, "onSave")})}));
	},
	/**
	 * Save form
	 */
	onSave: async function()
	{
		await this.form.submit();
	},
	/**
	 * Build title
	 */
	buildTitle: function(container)
	{
		this.layout.setPageTitle("Robots TXT");
	},
	_init: function()
	{
		Runtime.Web.BasePageModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.Robots.RobotsPage";
		this.form = null;
	},
});
Object.assign(Runtime.WordPress.Admin.Robots.RobotsPageModel, Runtime.Web.BasePageModel);
Object.assign(Runtime.WordPress.Admin.Robots.RobotsPageModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin.Robots";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.Robots.RobotsPageModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BasePageModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.Robots.RobotsPageModel);
window["Runtime.WordPress.Admin.Robots.RobotsPageModel"] = Runtime.WordPress.Admin.Robots.RobotsPageModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.Robots.RobotsPageModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
Runtime.WordPress.Admin.AppHook = function()
{
	Runtime.Web.Hooks.AppHook.apply(this, arguments);
};
Runtime.WordPress.Admin.AppHook.prototype = Object.create(Runtime.Web.Hooks.AppHook.prototype);
Runtime.WordPress.Admin.AppHook.prototype.constructor = Runtime.WordPress.Admin.AppHook;
Object.assign(Runtime.WordPress.Admin.AppHook.prototype,
{
	/**
	 * Register hooks
	 */
	register_hooks: function()
	{
		this.register(this.constructor.CALL_API_BEFORE);
		this.register(this.constructor.GET_FRAME_PAGE_URL, "get_frame_page_url");
	},
	/**
	 * Call api before
	 */
	call_api_before: function(params)
	{
		var api_url = "/wp-admin/admin-ajax.php?action=admin_call_api&api_name=" + Runtime.rtl.toStr(Runtime.rs.url_encode(params.get("post_data").get("api_name")));
		params.set("api_url", api_url);
	},
	/**
	 * Returns projects list
	 */
	get_frame_page_url: function(params)
	{
		var page_url = "/open/widget?widget_name=" + Runtime.rtl.toStr(params.get("current_widget"));
		params.set("page_url", page_url);
	},
});
Object.assign(Runtime.WordPress.Admin.AppHook, Runtime.Web.Hooks.AppHook);
Object.assign(Runtime.WordPress.Admin.AppHook,
{
	GET_FRAME_PAGE_URL: "baylang.constructor::get_frame_page_url",
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.AppHook";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Hooks.AppHook";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.AppHook);
window["Runtime.WordPress.Admin.AppHook"] = Runtime.WordPress.Admin.AppHook;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.AppHook;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
Runtime.WordPress.Admin.CSS = {
	name: "Runtime.WordPress.Admin.CSS",
	extends: Runtime.Web.Component,
	methods:
	{
	},
};
Object.assign(Runtime.WordPress.Admin.CSS,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Widget.Button","Runtime.Widget.Input","Runtime.Widget.RowButtons","Runtime.Widget.Select","Runtime.Widget.TextArea","Runtime.Widget.Dialog.Dialog","Runtime.Widget.Table.Table"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(":root{--widget-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif}#core_ui_root{margin-top: 20px}.widget_table.h-6434 .widget_table__top_buttons.h-a598{margin-bottom: calc(var(--widget-space) * 2)}.widget_table.h-6434 .widget_table__table{border: 1px solid #ccc;border-radius: 4px}.widget_table.h-6434 .widget_table__th{text-align: left}.widget_table.h-6434 .widget_table__th,.widget_table.h-6434 .widget_table__td{border-bottom: 1px solid #ccc;padding: 10px}.widget_table.h-6434 .widget_table__tr:nth-child(odd){background-color: white}.widget_table.h-6434 .widget_table__tr:nth-child(even){background-color: #f0f0f0}.widget_select.h-d72d{max-width: 100%}");
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.CSS";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.Component";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.CSS);
window["Runtime.WordPress.Admin.CSS"] = Runtime.WordPress.Admin.CSS;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.CSS;
"use strict;"
/*
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
Runtime.WordPress.Admin.DefaultLayout = {
	name: "Runtime.WordPress.Admin.DefaultLayout",
	extends: Runtime.Web.DefaultLayout,
	methods:
	{
		renderTitle: function()
		{
			let __v = [];
			
			/* Text */
			this._t(__v, "    ");
			
			/* Element 'h1' */
			let __v0 = this._e(__v, "h1", {"class":this._class_name(["wp-heading-inline"])});
			
			/* Render */
			this._t(__v0, this.layout.title);
			
			return this._flatten(__v);
		},
		render: function()
		{
			let __v = [];
			
			/* Text */
			this._t(__v, "    ");
			
			/* Element 'div' */
			let __v0 = this._e(__v, "div", {"class":this._class_name(["default_layout wrap"])});
			
			/* Render */
			this._t(__v0, this.renderTitle());
			
			/* Render */
			this._t(__v0, this.renderCurrentPage());
			
			/* Text */
			this._t(__v0, "    ");
			
			return this._flatten(__v);
		},
	},
};
Object.assign(Runtime.WordPress.Admin.DefaultLayout,
{
	components: function()
	{
		return Runtime.Vector.from(["Runtime.Web.DefaultLayout"]);
	},
	css: function(vars)
	{
		var res = "";
		res += Runtime.rtl.toStr(".wp-heading-inline.h-f4f4{padding: 0;margin-bottom: 14px}");
		return res;
	},
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.DefaultLayout";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.DefaultLayout";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.DefaultLayout);
window["Runtime.WordPress.Admin.DefaultLayout"] = Runtime.WordPress.Admin.DefaultLayout;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.DefaultLayout;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
Runtime.WordPress.Admin.DefaultLayoutModel = function()
{
	Runtime.Web.BaseLayoutModel.apply(this, arguments);
};
Runtime.WordPress.Admin.DefaultLayoutModel.prototype = Object.create(Runtime.Web.BaseLayoutModel.prototype);
Runtime.WordPress.Admin.DefaultLayoutModel.prototype.constructor = Runtime.WordPress.Admin.DefaultLayoutModel;
Object.assign(Runtime.WordPress.Admin.DefaultLayoutModel.prototype,
{
	_init: function()
	{
		Runtime.Web.BaseLayoutModel.prototype._init.call(this);
		this.component = "Runtime.WordPress.Admin.DefaultLayout";
	},
});
Object.assign(Runtime.WordPress.Admin.DefaultLayoutModel, Runtime.Web.BaseLayoutModel);
Object.assign(Runtime.WordPress.Admin.DefaultLayoutModel,
{
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.DefaultLayoutModel";
	},
	getParentClassName: function()
	{
		return "Runtime.Web.BaseLayoutModel";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.DefaultLayoutModel);
window["Runtime.WordPress.Admin.DefaultLayoutModel"] = Runtime.WordPress.Admin.DefaultLayoutModel;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.DefaultLayoutModel;
"use strict;"
/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
if (typeof Runtime == 'undefined') Runtime = {};
if (typeof Runtime.WordPress == 'undefined') Runtime.WordPress = {};
if (typeof Runtime.WordPress.Admin == 'undefined') Runtime.WordPress.Admin = {};
Runtime.WordPress.Admin.ModuleDescription = function()
{
};
Object.assign(Runtime.WordPress.Admin.ModuleDescription.prototype,
{
});
Object.assign(Runtime.WordPress.Admin.ModuleDescription,
{
	/**
	 * Returns module name
	 */
	getModuleName: function()
	{
		return "Runtime.WordPress.Admin";
	},
	/**
	 * Returns module version
	 */
	getModuleVersion: function()
	{
		return "0.0.1";
	},
	/**
	 * Returns required modules
	 * @return Map<string>
	 */
	requiredModules: function()
	{
		return Runtime.Map.from({"BayLang":">=0.12","BayLang.Constructor":">=0.12","Runtime.WordPress":">=0.1"});
	},
	/**
	 * Returns enities
	 */
	entities: function()
	{
		return Runtime.Vector.from([new Runtime.Entity.Hook("Runtime.WordPress.Admin.AppHook"),Runtime.Web.Hooks.SetupLayout.hook(Runtime.Map.from({"default":"Runtime.WordPress.Admin.DefaultLayoutModel"})),Runtime.Web.Hooks.Components.hook(Runtime.Vector.from(["Runtime.WordPress.Admin.CSS"]))]);
	},
	/* ======================= Class Init Functions ======================= */
	getNamespace: function()
	{
		return "Runtime.WordPress.Admin";
	},
	getClassName: function()
	{
		return "Runtime.WordPress.Admin.ModuleDescription";
	},
	getParentClassName: function()
	{
		return "";
	},
	getClassInfo: function()
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return Map.from({
			"annotations": Vector.from([
			]),
		});
	},
	getFieldsList: function()
	{
		var a = [];
		return Runtime.Vector.from(a);
	},
	getFieldInfoByName: function(field_name)
	{
		var Vector = Runtime.Vector;
		var Map = Runtime.Map;
		return null;
	},
	getMethodsList: function()
	{
		var a=[
		];
		return Runtime.Vector.from(a);
	},
	getMethodInfoByName: function(field_name)
	{
		return null;
	},
});
Runtime.rtl.defClass(Runtime.WordPress.Admin.ModuleDescription);
window["Runtime.WordPress.Admin.ModuleDescription"] = Runtime.WordPress.Admin.ModuleDescription;
if (typeof module != "undefined" && typeof module.exports != "undefined") module.exports = Runtime.WordPress.Admin.ModuleDescription;
